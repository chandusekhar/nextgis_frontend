(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.OlMapAdapter = {})));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    /**
     * @module ol/LayerType
     */

    /**
     * A layer type used when creating layer renderers.
     * @enum {string}
     */
    var LayerType = {
      IMAGE: 'IMAGE',
      TILE: 'TILE',
      VECTOR_TILE: 'VECTOR_TILE',
      VECTOR: 'VECTOR'
    };

    /**
     * @module ol/obj
     */


    /**
     * Polyfill for Object.assign().  Assigns enumerable and own properties from
     * one or more source objects to a target object.
     * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
     *
     * @param {!Object} target The target object.
     * @param {...Object} var_sources The source object(s).
     * @return {!Object} The modified target object.
     */
    var assign = (typeof Object.assign === 'function') ? Object.assign : function(target, var_sources) {
      var arguments$1 = arguments;

      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var output = Object(target);
      for (var i = 1, ii = arguments.length; i < ii; ++i) {
        var source = arguments$1[i];
        if (source !== undefined && source !== null) {
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              output[key] = source[key];
            }
          }
        }
      }
      return output;
    };


    /**
     * Removes all properties from an object.
     * @param {Object} object The object to clear.
     */
    function clear(object) {
      for (var property in object) {
        delete object[property];
      }
    }


    /**
     * Get an array of property values from an object.
     * @param {Object<K,V>} object The object from which to get the values.
     * @return {!Array<V>} The property values.
     * @template K,V
     */
    function getValues(object) {
      var values = [];
      for (var property in object) {
        values.push(object[property]);
      }
      return values;
    }


    /**
     * Determine if an object has any properties.
     * @param {Object} object The object to check.
     * @return {boolean} The object is empty.
     */
    function isEmpty(object) {
      var property;
      for (property in object) {
        return false;
      }
      return !property;
    }

    /**
     * @module ol/events
     */


    /**
     * Key to use with {@link module:ol/Observable~Observable#unByKey}.
     * @typedef {Object} EventsKey
     * @property {Object} [bindTo]
     * @property {module:ol/events~ListenerFunction} [boundListener]
     * @property {boolean} callOnce
     * @property {number} [deleteIndex]
     * @property {module:ol/events~ListenerFunction} listener
     * @property {EventTarget|module:ol/events/EventTarget} target
     * @property {string} type
     * @api
     */


    /**
     * Listener function. This function is called with an event object as argument.
     * When the function returns `false`, event propagation will stop.
     *
     * @typedef {function(module:ol/events/Event)|function(module:ol/events/Event): boolean} ListenerFunction
     * @api
     */


    /**
     * @param {module:ol/events~EventsKey} listenerObj Listener object.
     * @return {module:ol/events~ListenerFunction} Bound listener.
     */
    function bindListener(listenerObj) {
      var boundListener = function(evt) {
        var listener = listenerObj.listener;
        var bindTo = listenerObj.bindTo || listenerObj.target;
        if (listenerObj.callOnce) {
          unlistenByKey(listenerObj);
        }
        return listener.call(bindTo, evt);
      };
      listenerObj.boundListener = boundListener;
      return boundListener;
    }


    /**
     * Finds the matching {@link module:ol/events~EventsKey} in the given listener
     * array.
     *
     * @param {!Array<!module:ol/events~EventsKey>} listeners Array of listeners.
     * @param {!Function} listener The listener function.
     * @param {Object=} opt_this The `this` value inside the listener.
     * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
     *     listener, for {@link module:ol/events~unlistenByKey}.
     * @return {module:ol/events~EventsKey|undefined} The matching listener object.
     */
    function findListener(listeners, listener, opt_this, opt_setDeleteIndex) {
      var listenerObj;
      for (var i = 0, ii = listeners.length; i < ii; ++i) {
        listenerObj = listeners[i];
        if (listenerObj.listener === listener &&
            listenerObj.bindTo === opt_this) {
          if (opt_setDeleteIndex) {
            listenerObj.deleteIndex = i;
          }
          return listenerObj;
        }
      }
      return undefined;
    }


    /**
     * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
     * @param {string} type Type.
     * @return {Array.<module:ol/events~EventsKey>|undefined} Listeners.
     */
    function getListeners(target, type) {
      var listenerMap = target.ol_lm;
      return listenerMap ? listenerMap[type] : undefined;
    }


    /**
     * Get the lookup of listeners.  If one does not exist on the target, it is
     * created.
     * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
     * @return {!Object.<string, Array.<module:ol/events~EventsKey>>} Map of
     *     listeners by event type.
     */
    function getListenerMap(target) {
      var listenerMap = target.ol_lm;
      if (!listenerMap) {
        listenerMap = target.ol_lm = {};
      }
      return listenerMap;
    }


    /**
     * Clean up all listener objects of the given type.  All properties on the
     * listener objects will be removed, and if no listeners remain in the listener
     * map, it will be removed from the target.
     * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
     * @param {string} type Type.
     */
    function removeListeners(target, type) {
      var listeners = getListeners(target, type);
      if (listeners) {
        for (var i = 0, ii = listeners.length; i < ii; ++i) {
          target.removeEventListener(type, listeners[i].boundListener);
          clear(listeners[i]);
        }
        listeners.length = 0;
        var listenerMap = target.ol_lm;
        if (listenerMap) {
          delete listenerMap[type];
          if (Object.keys(listenerMap).length === 0) {
            delete target.ol_lm;
          }
        }
      }
    }


    /**
     * Registers an event listener on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * This function efficiently binds a `listener` to a `this` object, and returns
     * a key for use with {@link module:ol/events~unlistenByKey}.
     *
     * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
     * @param {string} type Event type.
     * @param {module:ol/events~ListenerFunction} listener Listener.
     * @param {Object=} opt_this Object referenced by the `this` keyword in the
     *     listener. Default is the `target`.
     * @param {boolean=} opt_once If true, add the listener as one-off listener.
     * @return {module:ol/events~EventsKey} Unique key for the listener.
     */
    function listen(target, type, listener, opt_this, opt_once) {
      var listenerMap = getListenerMap(target);
      var listeners = listenerMap[type];
      if (!listeners) {
        listeners = listenerMap[type] = [];
      }
      var listenerObj = findListener(listeners, listener, opt_this, false);
      if (listenerObj) {
        if (!opt_once) {
          // Turn one-off listener into a permanent one.
          listenerObj.callOnce = false;
        }
      } else {
        listenerObj = /** @type {module:ol/events~EventsKey} */ ({
          bindTo: opt_this,
          callOnce: !!opt_once,
          listener: listener,
          target: target,
          type: type
        });
        target.addEventListener(type, bindListener(listenerObj));
        listeners.push(listenerObj);
      }

      return listenerObj;
    }


    /**
     * Registers a one-off event listener on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * This function efficiently binds a `listener` as self-unregistering listener
     * to a `this` object, and returns a key for use with
     * {@link module:ol/events~unlistenByKey} in case the listener needs to be
     * unregistered before it is called.
     *
     * When {@link module:ol/events~listen} is called with the same arguments after this
     * function, the self-unregistering listener will be turned into a permanent
     * listener.
     *
     * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
     * @param {string} type Event type.
     * @param {module:ol/events~ListenerFunction} listener Listener.
     * @param {Object=} opt_this Object referenced by the `this` keyword in the
     *     listener. Default is the `target`.
     * @return {module:ol/events~EventsKey} Key for unlistenByKey.
     */
    function listenOnce(target, type, listener, opt_this) {
      return listen(target, type, listener, opt_this, true);
    }


    /**
     * Unregisters an event listener on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * To return a listener, this function needs to be called with the exact same
     * arguments that were used for a previous {@link module:ol/events~listen} call.
     *
     * @param {module:ol/events/EventTarget~EventTargetLike} target Event target.
     * @param {string} type Event type.
     * @param {module:ol/events~ListenerFunction} listener Listener.
     * @param {Object=} opt_this Object referenced by the `this` keyword in the
     *     listener. Default is the `target`.
     */
    function unlisten(target, type, listener, opt_this) {
      var listeners = getListeners(target, type);
      if (listeners) {
        var listenerObj = findListener(listeners, listener, opt_this, true);
        if (listenerObj) {
          unlistenByKey(listenerObj);
        }
      }
    }


    /**
     * Unregisters event listeners on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * The argument passed to this function is the key returned from
     * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
     *
     * @param {module:ol/events~EventsKey} key The key.
     */
    function unlistenByKey(key) {
      if (key && key.target) {
        key.target.removeEventListener(key.type, key.boundListener);
        var listeners = getListeners(key.target, key.type);
        if (listeners) {
          var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
          if (i !== -1) {
            listeners.splice(i, 1);
          }
          if (listeners.length === 0) {
            removeListeners(key.target, key.type);
          }
        }
        clear(key);
      }
    }


    /**
     * Unregisters all event listeners on an event target. Inspired by
     * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
     *
     * @param {module:ol/events/EventTarget~EventTargetLike} target Target.
     */
    function unlistenAll(target) {
      var listenerMap = getListenerMap(target);
      for (var type in listenerMap) {
        removeListeners(target, type);
      }
    }

    /**
     * @module ol/events/EventType
     */

    /**
     * @enum {string}
     * @const
     */
    var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~Event#change
       * @api
       */
      CHANGE: 'change',

      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      ERROR: 'error',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      MOUSEDOWN: 'mousedown',
      MOUSEMOVE: 'mousemove',
      MOUSEOUT: 'mouseout',
      MOUSEUP: 'mouseup',
      MOUSEWHEEL: 'mousewheel',
      MSPOINTERDOWN: 'MSPointerDown',
      RESIZE: 'resize',
      TOUCHSTART: 'touchstart',
      TOUCHMOVE: 'touchmove',
      TOUCHEND: 'touchend',
      WHEEL: 'wheel'
    };

    /**
     * @module ol/util
     */

    /**
     * Counter for getUid.
     * @type {number}
     * @private
     */
    var uidCounter_ = 0;

    /**
     * Gets a unique ID for an object. This mutates the object so that further calls
     * with the same object as a parameter returns the same value. Unique IDs are generated
     * as a strictly increasing sequence. Adapted from goog.getUid.
     *
     * @param {Object} obj The object to get the unique ID for.
     * @return {number} The unique ID for the object.
     */
    function getUid(obj) {
      return obj.ol_uid || (obj.ol_uid = ++uidCounter_);
    }

    /**
     * OpenLayers version.
     * @type {string}
     */
    var VERSION = '5.1.3';

    /**
     * @module ol/ObjectEventType
     */

    /**
     * @enum {string}
     */
    var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object~ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange'
    };

    /**
     * @module ol/functions
     */

    /**
     * Always returns true.
     * @returns {boolean} true.
     */
    function TRUE() {
      return true;
    }

    /**
     * Always returns false.
     * @returns {boolean} false.
     */
    function FALSE() {
      return false;
    }

    /**
     * A reusable function, used e.g. as a default for callbacks.
     *
     * @return {undefined} Nothing.
     */
    function UNDEFINED() {}

    /**
     * @module ol/Disposable
     */

    /**
     * @classdesc
     * Objects that need to clean up after themselves.
     */
    var Disposable = function Disposable () {};

    Disposable.prototype.dispose = function dispose () {
      if (!this.disposed_) {
        this.disposed_ = true;
        this.disposeInternal();
      }
    };

    /**
     * The object has already been disposed.
     * @type {boolean}
     * @private
     */
    Disposable.prototype.disposed_ = false;

    /**
     * Extension point for disposable objects.
     * @protected
     */
    Disposable.prototype.disposeInternal = UNDEFINED;

    /**
     * @module ol/events/Event
     */

    /**
     * @classdesc
     * Stripped down implementation of the W3C DOM Level 2 Event interface.
     * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
     *
     * This implementation only provides `type` and `target` properties, and
     * `stopPropagation` and `preventDefault` methods. It is meant as base class
     * for higher level events defined in the library, and works with
     * {@link module:ol/events/EventTarget~EventTarget}.
     */
    var Event = function Event(type) {

      /**
       * @type {boolean}
       */
      this.propagationStopped;

      /**
       * The event type.
       * @type {string}
       * @api
       */
      this.type = type;

      /**
       * The event target.
       * @type {Object}
       * @api
       */
      this.target = null;
    };

    /**
     * Stop event propagation.
     * @function
     * @api
     */
    Event.prototype.preventDefault = function preventDefault () {
      this.propagationStopped = true;
    };

    /**
     * Stop event propagation.
     * @function
     * @api
     */
    Event.prototype.stopPropagation = function stopPropagation () {
      this.propagationStopped = true;
    };


    /**
     * @param {Event|module:ol/events/Event} evt Event
     */
    function stopPropagation(evt) {
      evt.stopPropagation();
    }

    /**
     * @module ol/events/EventTarget
     */


    /**
     * @typedef {EventTarget|module:ol/events/EventTarget} EventTargetLike
     */


    /**
     * @classdesc
     * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
     * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
     *
     * There are two important simplifications compared to the specification:
     *
     * 1. The handling of `useCapture` in `addEventListener` and
     *    `removeEventListener`. There is no real capture model.
     * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
     *    There is no event target hierarchy. When a listener calls
     *    `stopPropagation` or `preventDefault` on an event object, it means that no
     *    more listeners after this one will be called. Same as when the listener
     *    returns false.
     */
    var EventTarget = (function (Disposable$$1) {
      function EventTarget() {

        Disposable$$1.call(this);

        /**
         * @private
         * @type {!Object.<string, number>}
         */
        this.pendingRemovals_ = {};

        /**
         * @private
         * @type {!Object.<string, number>}
         */
        this.dispatching_ = {};

        /**
         * @private
         * @type {!Object.<string, Array.<module:ol/events~ListenerFunction>>}
         */
        this.listeners_ = {};

      }

      if ( Disposable$$1 ) EventTarget.__proto__ = Disposable$$1;
      EventTarget.prototype = Object.create( Disposable$$1 && Disposable$$1.prototype );
      EventTarget.prototype.constructor = EventTarget;

      /**
       * @param {string} type Type.
       * @param {module:ol/events~ListenerFunction} listener Listener.
       */
      EventTarget.prototype.addEventListener = function addEventListener (type, listener) {
        var listeners = this.listeners_[type];
        if (!listeners) {
          listeners = this.listeners_[type] = [];
        }
        if (listeners.indexOf(listener) === -1) {
          listeners.push(listener);
        }
      };

      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {{type: string,
       *     target: (EventTarget|module:ol/events/EventTarget|undefined)}|
       *     module:ol/events/Event|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @function
       * @api
       */
      EventTarget.prototype.dispatchEvent = function dispatchEvent (event) {
        var this$1 = this;

        var evt = typeof event === 'string' ? new Event(event) : event;
        var type = evt.type;
        evt.target = this;
        var listeners = this.listeners_[type];
        var propagate;
        if (listeners) {
          if (!(type in this.dispatching_)) {
            this.dispatching_[type] = 0;
            this.pendingRemovals_[type] = 0;
          }
          ++this.dispatching_[type];
          for (var i = 0, ii = listeners.length; i < ii; ++i) {
            if (listeners[i].call(this$1, evt) === false || evt.propagationStopped) {
              propagate = false;
              break;
            }
          }
          --this.dispatching_[type];
          if (this.dispatching_[type] === 0) {
            var pendingRemovals = this.pendingRemovals_[type];
            delete this.pendingRemovals_[type];
            while (pendingRemovals--) {
              this$1.removeEventListener(type, UNDEFINED);
            }
            delete this.dispatching_[type];
          }
          return propagate;
        }
      };

      /**
       * @inheritDoc
       */
      EventTarget.prototype.disposeInternal = function disposeInternal () {
        unlistenAll(this);
      };

      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array.<module:ol/events~ListenerFunction>} Listeners.
       */
      EventTarget.prototype.getListeners = function getListeners$$1 (type) {
        return this.listeners_[type];
      };

      /**
       * @param {string=} opt_type Type. If not provided,
       *     `true` will be returned if this EventTarget has any listeners.
       * @return {boolean} Has listeners.
       */
      EventTarget.prototype.hasListener = function hasListener (opt_type) {
        return opt_type ?
          opt_type in this.listeners_ :
          Object.keys(this.listeners_).length > 0;
      };

      /**
       * @param {string} type Type.
       * @param {module:ol/events~ListenerFunction} listener Listener.
       */
      EventTarget.prototype.removeEventListener = function removeEventListener (type, listener) {
        var listeners = this.listeners_[type];
        if (listeners) {
          var index = listeners.indexOf(listener);
          if (type in this.pendingRemovals_) {
            // make listener a no-op, and remove later in #dispatchEvent()
            listeners[index] = UNDEFINED;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      };

      return EventTarget;
    }(Disposable));

    /**
     * @module ol/Observable
     */

    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * An event target providing convenient methods for listener registration
     * and unregistration. A generic `change` event is always available through
     * {@link module:ol/Observable~Observable#changed}.
     *
     * @fires module:ol/events/Event~Event
     * @api
     */
    var Observable = (function (EventTarget$$1) {
      function Observable() {

        EventTarget$$1.call(this);

        /**
         * @private
         * @type {number}
         */
        this.revision_ = 0;

      }

      if ( EventTarget$$1 ) Observable.__proto__ = EventTarget$$1;
      Observable.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      Observable.prototype.constructor = Observable;

      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      Observable.prototype.changed = function changed () {
        ++this.revision_;
        this.dispatchEvent(EventType.CHANGE);
      };

      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      Observable.prototype.getRevision = function getRevision () {
        return this.revision_;
      };

      /**
       * Listen for a certain type of event.
       * @param {string|Array.<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.on = function on (type, listener) {
        var this$1 = this;

        if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
            keys[i] = listen(this$1, type[i], listener);
          }
          return keys;
        } else {
          return listen(this, /** @type {string} */ (type), listener);
        }
      };

      /**
       * Listen once for a certain type of event.
       * @param {string|Array.<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {module:ol/events~EventsKey|Array.<module:ol/events~EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.once = function once (type, listener) {
        var this$1 = this;

        if (Array.isArray(type)) {
          var len = type.length;
          var keys = new Array(len);
          for (var i = 0; i < len; ++i) {
            keys[i] = listenOnce(this$1, type[i], listener);
          }
          return keys;
        } else {
          return listenOnce(this, /** @type {string} */ (type), listener);
        }
      };

      /**
       * Unlisten for a certain type of event.
       * @param {string|Array.<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @api
       */
      Observable.prototype.un = function un (type, listener) {
        var this$1 = this;

        if (Array.isArray(type)) {
          for (var i = 0, ii = type.length; i < ii; ++i) {
            unlisten(this$1, type[i], listener);
          }
          return;
        } else {
          unlisten(this, /** @type {string} */ (type), listener);
        }
      };

      return Observable;
    }(EventTarget));

    /**
     * @module ol/Object
     */


    /**
     * @classdesc
     * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
      */
    var ObjectEvent = (function (Event$$1) {
      function ObjectEvent(type, key, oldValue) {
        Event$$1.call(this, type);

        /**
         * The name of the property whose value is changing.
         * @type {string}
         * @api
         */
        this.key = key;

        /**
         * The old value. To get the new value use `e.target.get(e.key)` where
         * `e` is the event object.
         * @type {*}
         * @api
         */
        this.oldValue = oldValue;

      }

      if ( Event$$1 ) ObjectEvent.__proto__ = Event$$1;
      ObjectEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      ObjectEvent.prototype.constructor = ObjectEvent;

      return ObjectEvent;
    }(Event));


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Most non-trivial classes inherit from this.
     *
     * This extends {@link module:ol/Observable} with observable
     * properties, where each property is observable as well as the object as a
     * whole.
     *
     * Classes that inherit from this have pre-defined properties, to which you can
     * add your owns. The pre-defined properties are listed in this documentation as
     * 'Observable Properties', and have their own accessors; for example,
     * {@link module:ol/Map~Map} has a `target` property, accessed with
     * `getTarget()` and changed with `setTarget()`. Not all properties are however
     * settable. There are also general-purpose accessors `get()` and `set()`. For
     * example, `get('target')` is equivalent to `getTarget()`.
     *
     * The `set` accessors trigger a change event, and you can monitor this by
     * registering a listener. For example, {@link module:ol/View~View} has a
     * `center` property, so `view.on('change:center', function(evt) {...});` would
     * call the function whenever the value of the center property changes. Within
     * the function, `evt.target` would be the view, so `evt.target.getCenter()`
     * would return the new center.
     *
     * You can add your own observable properties with
     * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
     * You can listen for changes on that property value with
     * `object.on('change:prop', listener)`. You can get a list of all
     * properties with {@link module:ol/Object~BaseObject#getProperties}.
     *
     * Note that the observable properties are separate from standard JS properties.
     * You can, for example, give your map object a title with
     * `map.title='New title'` and with `map.set('title', 'Another title')`. The
     * first will be a `hasOwnProperty`; the second will appear in
     * `getProperties()`. Only the second is observable.
     *
     * Properties can be deleted by using the unset method. E.g.
     * object.unset('foo').
     *
     * @fires module:ol/Object~ObjectEvent
     * @api
     */
    var BaseObject = (function (Observable$$1) {
      function BaseObject(opt_values) {
        Observable$$1.call(this);

        // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
        // the same as the order in which they were created.  This also helps to
        // ensure that object properties are always added in the same order, which
        // helps many JavaScript engines generate faster code.
        getUid(this);

        /**
         * @private
         * @type {!Object.<string, *>}
         */
        this.values_ = {};

        if (opt_values !== undefined) {
          this.setProperties(opt_values);
        }
      }

      if ( Observable$$1 ) BaseObject.__proto__ = Observable$$1;
      BaseObject.prototype = Object.create( Observable$$1 && Observable$$1.prototype );
      BaseObject.prototype.constructor = BaseObject;

      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      BaseObject.prototype.get = function get (key) {
        var value;
        if (this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      };

      /**
       * Get a list of object property names.
       * @return {Array.<string>} List of property names.
       * @api
       */
      BaseObject.prototype.getKeys = function getKeys () {
        return Object.keys(this.values_);
      };

      /**
       * Get an object of all property names and values.
       * @return {Object.<string, *>} Object.
       * @api
       */
      BaseObject.prototype.getProperties = function getProperties () {
        return assign({}, this.values_);
      };

      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      BaseObject.prototype.notify = function notify (key, oldValue) {
        var eventType;
        eventType = getChangeEventType(key);
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        eventType = ObjectEventType.PROPERTYCHANGE;
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      };

      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.set = function set (key, value, opt_silent) {
        if (opt_silent) {
          this.values_[key] = value;
        } else {
          var oldValue = this.values_[key];
          this.values_[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      };

      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object.<string, *>} values Values.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.setProperties = function setProperties (values, opt_silent) {
        var this$1 = this;

        for (var key in values) {
          this$1.set(key, values[key], opt_silent);
        }
      };

      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean=} opt_silent Unset without triggering an event.
       * @api
       */
      BaseObject.prototype.unset = function unset (key, opt_silent) {
        if (key in this.values_) {
          var oldValue = this.values_[key];
          delete this.values_[key];
          if (!opt_silent) {
            this.notify(key, oldValue);
          }
        }
      };

      return BaseObject;
    }(Observable));


    /**
     * @type {Object.<string, string>}
     */
    var changeEventTypeCache = {};


    /**
     * @param {string} key Key name.
     * @return {string} Change name.
     */
    function getChangeEventType(key) {
      return changeEventTypeCache.hasOwnProperty(key) ?
        changeEventTypeCache[key] :
        (changeEventTypeCache[key] = 'change:' + key);
    }

    /**
     * @module ol/layer/Property
     */

    /**
     * @enum {string}
     */
    var LayerProperty = {
      OPACITY: 'opacity',
      VISIBLE: 'visible',
      EXTENT: 'extent',
      Z_INDEX: 'zIndex',
      MAX_RESOLUTION: 'maxResolution',
      MIN_RESOLUTION: 'minResolution',
      SOURCE: 'source'
    };

    /**
     * @module ol/AssertionError
     */

    /**
     * Error object thrown when an assertion failed. This is an ECMA-262 Error,
     * extended with a `code` property.
     * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
     */
    var AssertionError = (function (Error) {
      function AssertionError(code) {
        var path = VERSION.split('-')[0];
        var message = 'Assertion failed. See https://openlayers.org/en/' + path +
        '/doc/errors/#' + code + ' for details.';

        Error.call(this, message);

        /**
         * Error code. The meaning of the code can be found on
         * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
         * the version found in the OpenLayers script's header comment if a version
         * other than the latest is used).
         * @type {number}
         * @api
         */
        this.code = code;

        /**
         * @type {string}
         */
        this.name = 'AssertionError';

        // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
        this.message = message;
      }

      if ( Error ) AssertionError.__proto__ = Error;
      AssertionError.prototype = Object.create( Error && Error.prototype );
      AssertionError.prototype.constructor = AssertionError;

      return AssertionError;
    }(Error));

    /**
     * @module ol/asserts
     */

    /**
     * @param {*} assertion Assertion we expected to be truthy.
     * @param {number} errorCode Error code.
     */
    function assert(assertion, errorCode) {
      if (!assertion) {
        throw new AssertionError(errorCode);
      }
    }

    /**
     * @module ol/math
     */

    /**
     * Takes a number and clamps it to within the provided bounds.
     * @param {number} value The input number.
     * @param {number} min The minimum value to return.
     * @param {number} max The maximum value to return.
     * @return {number} The input number if it is within bounds, or the nearest
     *     number within the bounds.
     */
    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }


    /**
     * Return the hyperbolic cosine of a given number. The method will use the
     * native `Math.cosh` function if it is available, otherwise the hyperbolic
     * cosine will be calculated via the reference implementation of the Mozilla
     * developer network.
     *
     * @param {number} x X.
     * @return {number} Hyperbolic cosine of x.
     */
    var cosh = (function() {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var cosh;
      if ('cosh' in Math) {
        // The environment supports the native Math.cosh function, use it…
        cosh = Math.cosh;
      } else {
        // … else, use the reference implementation of MDN:
        cosh = function(x) {
          var y = Math.exp(x);
          return (y + 1 / y) / 2;
        };
      }
      return cosh;
    }());


    /**
     * Returns the square of the closest distance between the point (x, y) and the
     * line segment (x1, y1) to (x2, y2).
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} x1 X1.
     * @param {number} y1 Y1.
     * @param {number} x2 X2.
     * @param {number} y2 Y2.
     * @return {number} Squared distance.
     */
    function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      if (dx !== 0 || dy !== 0) {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          x1 = x2;
          y1 = y2;
        } else if (t > 0) {
          x1 += dx * t;
          y1 += dy * t;
        }
      }
      return squaredDistance(x, y, x1, y1);
    }


    /**
     * Returns the square of the distance between the points (x1, y1) and (x2, y2).
     * @param {number} x1 X1.
     * @param {number} y1 Y1.
     * @param {number} x2 X2.
     * @param {number} y2 Y2.
     * @return {number} Squared distance.
     */
    function squaredDistance(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return dx * dx + dy * dy;
    }


    /**
     * Solves system of linear equations using Gaussian elimination method.
     *
     * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
     *                                     in row-major order.
     * @return {Array.<number>} The resulting vector.
     */
    function solveLinearSystem(mat) {
      var n = mat.length;

      for (var i = 0; i < n; i++) {
        // Find max in the i-th column (ignoring i - 1 first rows)
        var maxRow = i;
        var maxEl = Math.abs(mat[i][i]);
        for (var r = i + 1; r < n; r++) {
          var absValue = Math.abs(mat[r][i]);
          if (absValue > maxEl) {
            maxEl = absValue;
            maxRow = r;
          }
        }

        if (maxEl === 0) {
          return null; // matrix is singular
        }

        // Swap max row with i-th (current) row
        var tmp = mat[maxRow];
        mat[maxRow] = mat[i];
        mat[i] = tmp;

        // Subtract the i-th row to make all the remaining rows 0 in the i-th column
        for (var j = i + 1; j < n; j++) {
          var coef = -mat[j][i] / mat[i][i];
          for (var k = i; k < n + 1; k++) {
            if (i == k) {
              mat[j][k] = 0;
            } else {
              mat[j][k] += coef * mat[i][k];
            }
          }
        }
      }

      // Solve Ax=b for upper triangular matrix A (mat)
      var x = new Array(n);
      for (var l = n - 1; l >= 0; l--) {
        x[l] = mat[l][n] / mat[l][l];
        for (var m = l - 1; m >= 0; m--) {
          mat[m][n] -= mat[m][l] * x[l];
        }
      }
      return x;
    }


    /**
     * Converts degrees to radians.
     *
     * @param {number} angleInDegrees Angle in degrees.
     * @return {number} Angle in radians.
     */
    function toRadians(angleInDegrees) {
      return angleInDegrees * Math.PI / 180;
    }

    /**
     * Returns the modulo of a / b, depending on the sign of b.
     *
     * @param {number} a Dividend.
     * @param {number} b Divisor.
     * @return {number} Modulo.
     */
    function modulo(a, b) {
      var r = a % b;
      return r * b < 0 ? r + b : r;
    }

    /**
     * Calculates the linearly interpolated value of x between a and b.
     *
     * @param {number} a Number
     * @param {number} b Number
     * @param {number} x Value to be interpolated.
     * @return {number} Interpolated value.
     */
    function lerp(a, b, x) {
      return a + x * (b - a);
    }

    /**
     * @module ol/layer/Base
     */


    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     */


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
     * the options is set as a {@link module:ol/Object} property on the layer object, so
     * is observable, and has get/set accessors.
     *
     * @api
     */
    var BaseLayer = (function (BaseObject$$1) {
      function BaseLayer(options) {

        BaseObject$$1.call(this);

        /**
        * @type {Object.<string, *>}
        */
        var properties = assign({}, options);
        properties[LayerProperty.OPACITY] =
           options.opacity !== undefined ? options.opacity : 1;
        properties[LayerProperty.VISIBLE] =
           options.visible !== undefined ? options.visible : true;
        properties[LayerProperty.Z_INDEX] =
           options.zIndex !== undefined ? options.zIndex : 0;
        properties[LayerProperty.MAX_RESOLUTION] =
           options.maxResolution !== undefined ? options.maxResolution : Infinity;
        properties[LayerProperty.MIN_RESOLUTION] =
           options.minResolution !== undefined ? options.minResolution : 0;

        this.setProperties(properties);

        /**
        * @type {module:ol/layer/Layer~State}
        * @private
        */
        this.state_ = /** @type {module:ol/layer/Layer~State} */ ({
          layer: /** @type {module:ol/layer/Layer} */ (this),
          managed: true
        });

        /**
        * The layer type.
        * @type {module:ol/LayerType}
        * @protected;
        */
        this.type;

      }

      if ( BaseObject$$1 ) BaseLayer.__proto__ = BaseObject$$1;
      BaseLayer.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      BaseLayer.prototype.constructor = BaseLayer;

      /**
      * Get the layer type (used when creating a layer renderer).
      * @return {module:ol/LayerType} The layer type.
      */
      BaseLayer.prototype.getType = function getType () {
        return this.type;
      };

      /**
      * @return {module:ol/layer/Layer~State} Layer state.
      */
      BaseLayer.prototype.getLayerState = function getLayerState () {
        this.state_.opacity = clamp(this.getOpacity(), 0, 1);
        this.state_.sourceState = this.getSourceState();
        this.state_.visible = this.getVisible();
        this.state_.extent = this.getExtent();
        this.state_.zIndex = this.getZIndex();
        this.state_.maxResolution = this.getMaxResolution();
        this.state_.minResolution = Math.max(this.getMinResolution(), 0);

        return this.state_;
      };

      /**
      * @abstract
      * @param {Array.<module:ol/layer/Layer>=} opt_array Array of layers (to be
      *     modified in place).
      * @return {Array.<module:ol/layer/Layer>} Array of layers.
      */
      BaseLayer.prototype.getLayersArray = function getLayersArray (opt_array) {};

      /**
      * @abstract
      * @param {Array.<module:ol/layer/Layer~State>=} opt_states Optional list of layer
      *     states (to be modified in place).
      * @return {Array.<module:ol/layer/Layer~State>} List of layer states.
      */
      BaseLayer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {};

      /**
      * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
      * will be visible regardless of extent.
      * @return {module:ol/extent~Extent|undefined} The layer extent.
      * @observable
      * @api
      */
      BaseLayer.prototype.getExtent = function getExtent () {
        return (
        /** @type {module:ol/extent~Extent|undefined} */ (this.get(LayerProperty.EXTENT))
        );
      };

      /**
      * Return the maximum resolution of the layer.
      * @return {number} The maximum resolution of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.getMaxResolution = function getMaxResolution () {
        return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));
      };

      /**
      * Return the minimum resolution of the layer.
      * @return {number} The minimum resolution of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.getMinResolution = function getMinResolution () {
        return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));
      };

      /**
      * Return the opacity of the layer (between 0 and 1).
      * @return {number} The opacity of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.getOpacity = function getOpacity () {
        return /** @type {number} */ (this.get(LayerProperty.OPACITY));
      };

      /**
      * @abstract
      * @return {module:ol/source/State} Source state.
      */
      BaseLayer.prototype.getSourceState = function getSourceState () {};

      /**
      * Return the visibility of the layer (`true` or `false`).
      * @return {boolean} The visibility of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.getVisible = function getVisible () {
        return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));
      };

      /**
      * Return the Z-index of the layer, which is used to order layers before
      * rendering. The default Z-index is 0.
      * @return {number} The Z-index of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.getZIndex = function getZIndex () {
        return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));
      };

      /**
      * Set the extent at which the layer is visible.  If `undefined`, the layer
      * will be visible at all extents.
      * @param {module:ol/extent~Extent|undefined} extent The extent of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setExtent = function setExtent (extent) {
        this.set(LayerProperty.EXTENT, extent);
      };

      /**
      * Set the maximum resolution at which the layer is visible.
      * @param {number} maxResolution The maximum resolution of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setMaxResolution = function setMaxResolution (maxResolution) {
        this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
      };

      /**
      * Set the minimum resolution at which the layer is visible.
      * @param {number} minResolution The minimum resolution of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setMinResolution = function setMinResolution (minResolution) {
        this.set(LayerProperty.MIN_RESOLUTION, minResolution);
      };

      /**
      * Set the opacity of the layer, allowed values range from 0 to 1.
      * @param {number} opacity The opacity of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setOpacity = function setOpacity (opacity) {
        this.set(LayerProperty.OPACITY, opacity);
      };

      /**
      * Set the visibility of the layer (`true` or `false`).
      * @param {boolean} visible The visibility of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setVisible = function setVisible (visible) {
        this.set(LayerProperty.VISIBLE, visible);
      };

      /**
      * Set Z-index of the layer, which is used to order layers before rendering.
      * The default Z-index is 0.
      * @param {number} zindex The z-index of the layer.
      * @observable
      * @api
      */
      BaseLayer.prototype.setZIndex = function setZIndex (zindex) {
        this.set(LayerProperty.Z_INDEX, zindex);
      };

      return BaseLayer;
    }(BaseObject));

    /**
     * @module ol/render/EventType
     */

    /**
     * @enum {string}
     */
    var RenderEventType = {
      /**
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: 'postcompose',
      /**
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: 'precompose',
      /**
       * @event module:ol/render/Event~RenderEvent#render
       * @api
       */
      RENDER: 'render'
    };

    /**
     * @module ol/source/State
     */

    /**
     * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
     * @enum {string}
     */
    var SourceState = {
      UNDEFINED: 'undefined',
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error'
    };

    /**
     * @module ol/layer/Layer
     */


    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {module:ol/source/Source} [source] Source for this layer.  If not provided to the constructor,
     * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
     * construction.
     */


    /**
     * @typedef {Object} State
     * @property {module:ol/layer/Layer} layer
     * @property {number} opacity
     * @property {module:ol/source/Source~State} sourceState
     * @property {boolean} visible
     * @property {boolean} managed
     * @property {module:ol/extent~Extent} [extent]
     * @property {number} zIndex
     * @property {number} maxResolution
     * @property {number} minResolution
     */

    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * A visual representation of raster or vector map data.
     * Layers group together those properties that pertain to how the data is to be
     * displayed, irrespective of the source of that data.
     *
     * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
     * like {@link module:ol/interaction/Select~Select} use unmanaged layers
     * internally. These unmanaged layers are associated with the map using
     * {@link module:ol/layer/Layer~Layer#setMap} instead.
     *
     * A generic `change` event is fired when the state of the source changes.
     *
     * @fires module:ol/render/Event~RenderEvent
     */
    var Layer = (function (BaseLayer$$1) {
      function Layer(options) {

        var baseOptions = assign({}, options);
        delete baseOptions.source;

        BaseLayer$$1.call(this, baseOptions);

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.mapPrecomposeKey_ = null;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.mapRenderKey_ = null;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.sourceChangeKey_ = null;

        if (options.map) {
          this.setMap(options.map);
        }

        listen(this,
          getChangeEventType(LayerProperty.SOURCE),
          this.handleSourcePropertyChange_, this);

        var source = options.source ? options.source : null;
        this.setSource(source);
      }

      if ( BaseLayer$$1 ) Layer.__proto__ = BaseLayer$$1;
      Layer.prototype = Object.create( BaseLayer$$1 && BaseLayer$$1.prototype );
      Layer.prototype.constructor = Layer;

      /**
       * @inheritDoc
       */
      Layer.prototype.getLayersArray = function getLayersArray (opt_array) {
        var array = opt_array ? opt_array : [];
        array.push(this);
        return array;
      };

      /**
       * @inheritDoc
       */
      Layer.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
        var states = opt_states ? opt_states : [];
        states.push(this.getLayerState());
        return states;
      };

      /**
       * Get the layer source.
       * @return {module:ol/source/Source} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      Layer.prototype.getSource = function getSource () {
        var source = this.get(LayerProperty.SOURCE);
        return (
          /** @type {module:ol/source/Source} */ (source) || null
        );
      };

      /**
        * @inheritDoc
        */
      Layer.prototype.getSourceState = function getSourceState () {
        var source = this.getSource();
        return !source ? SourceState.UNDEFINED : source.getState();
      };

      /**
       * @private
       */
      Layer.prototype.handleSourceChange_ = function handleSourceChange_ () {
        this.changed();
      };

      /**
       * @private
       */
      Layer.prototype.handleSourcePropertyChange_ = function handleSourcePropertyChange_ () {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        var source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(source,
            EventType.CHANGE, this.handleSourceChange_, this);
        }
        this.changed();
      };

      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection, and the callback in
       * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map#addLayer} instead.
       * @param {module:ol/PluggableMap} map Map.
       * @api
       */
      Layer.prototype.setMap = function setMap (map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {
            var layerState = this.getLayerState();
            layerState.managed = false;
            layerState.zIndex = Infinity;
            evt.frameState.layerStatesArray.push(layerState);
            evt.frameState.layerStates[getUid(this)] = layerState;
          }, this);
          this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
          this.changed();
        }
      };

      /**
       * Set the layer source.
       * @param {module:ol/source/Source} source The layer source.
       * @observable
       * @api
       */
      Layer.prototype.setSource = function setSource (source) {
        this.set(LayerProperty.SOURCE, source);
      };

      return Layer;
    }(BaseLayer));


    /**
     * Return `true` if the layer is visible, and if the passed resolution is
     * between the layer's minResolution and maxResolution. The comparison is
     * inclusive for `minResolution` and exclusive for `maxResolution`.
     * @param {module:ol/layer/Layer~State} layerState Layer state.
     * @param {number} resolution Resolution.
     * @return {boolean} The layer is visible at the given resolution.
     */
    function visibleAtResolution(layerState, resolution) {
      return layerState.visible && resolution >= layerState.minResolution &&
          resolution < layerState.maxResolution;
    }

    /**
     * @module ol/layer/TileProperty
     */

    /**
     * @enum {string}
     */
    var TileProperty = {
      PRELOAD: 'preload',
      USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
    };

    /**
     * @module ol/layer/Tile
     */


    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
     * means no preloading.
     * @property {module:ol/source/Tile} [source] Source for this layer.
     * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module:ol/Map#addLayer}.
     * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
     */

    /**
     * @classdesc
     * For layer sources that provide pre-rendered, tiled images in grids that are
     * organized by zoom levels for specific resolutions.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @api
     */
    var TileLayer = (function (Layer$$1) {
      function TileLayer(opt_options) {
        var options = opt_options ? opt_options : {};

        var baseOptions = assign({}, options);

        delete baseOptions.preload;
        delete baseOptions.useInterimTilesOnError;
        Layer$$1.call(this, baseOptions);

        this.setPreload(options.preload !== undefined ? options.preload : 0);
        this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ?
          options.useInterimTilesOnError : true);

        /**
        * The layer type.
        * @protected
        * @type {module:ol/LayerType}
        */
        this.type = LayerType.TILE;

      }

      if ( Layer$$1 ) TileLayer.__proto__ = Layer$$1;
      TileLayer.prototype = Object.create( Layer$$1 && Layer$$1.prototype );
      TileLayer.prototype.constructor = TileLayer;

      /**
      * Return the level as number to which we will preload tiles up to.
      * @return {number} The level to preload tiles up to.
      * @observable
      * @api
      */
      TileLayer.prototype.getPreload = function getPreload () {
        return /** @type {number} */ (this.get(TileProperty.PRELOAD));
      };

      /**
      * Set the level as number to which we will preload tiles up to.
      * @param {number} preload The level to preload tiles up to.
      * @observable
      * @api
      */
      TileLayer.prototype.setPreload = function setPreload (preload) {
        this.set(TileProperty.PRELOAD, preload);
      };

      /**
      * Whether we use interim tiles on error.
      * @return {boolean} Use interim tiles on error.
      * @observable
      * @api
      */
      TileLayer.prototype.getUseInterimTilesOnError = function getUseInterimTilesOnError () {
        return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));
      };

      /**
      * Set whether we use interim tiles on error.
      * @param {boolean} useInterimTilesOnError Use interim tiles on error.
      * @observable
      * @api
      */
      TileLayer.prototype.setUseInterimTilesOnError = function setUseInterimTilesOnError (useInterimTilesOnError) {
        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      };

      return TileLayer;
    }(Layer));


    /**
     * Return the associated {@link module:ol/source/Tile tilesource} of the layer.
     * @function
     * @return {module:ol/source/Tile} Source.
     * @api
     */
    TileLayer.prototype.getSource;

    /**
     * @module ol/CollectionEventType
     */

    /**
     * @enum {string}
     */
    var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection~CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection~CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove'
    };

    /**
     * @module ol/Collection
     */


    /**
     * @enum {string}
     * @private
     */
    var Property = {
      LENGTH: 'length'
    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
     * type.
     */
    var CollectionEvent = (function (Event$$1) {
      function CollectionEvent(type, opt_element) {
        Event$$1.call(this, type);

        /**
         * The element that is added to or removed from the collection.
         * @type {*}
         * @api
         */
        this.element = opt_element;

      }

      if ( Event$$1 ) CollectionEvent.__proto__ = Event$$1;
      CollectionEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      CollectionEvent.prototype.constructor = CollectionEvent;

      return CollectionEvent;
    }(Event));


    /**
     * @typedef {Object} Options
     * @property {boolean} [unique=false] Disallow the same item from being added to
     * the collection twice.
     */

    /**
     * @classdesc
     * An expanded version of standard JS Array, adding convenience methods for
     * manipulation. Add and remove changes to the Collection trigger a Collection
     * event. Note that this does not cover changes to the objects _within_ the
     * Collection; they trigger events on the appropriate object, not on the
     * Collection as a whole.
     *
     * @template T
     * @api
     */
    var Collection = (function (BaseObject$$1) {
      function Collection(opt_array, opt_options) {
        var this$1 = this;


        BaseObject$$1.call(this);

        var options = opt_options || {};

        /**
         * @private
         * @type {boolean}
         */
        this.unique_ = !!options.unique;

        /**
         * @private
         * @type {!Array.<T>}
         */
        this.array_ = opt_array ? opt_array : [];

        if (this.unique_) {
          for (var i = 0, ii = this.array_.length; i < ii; ++i) {
            this$1.assertUnique_(this$1.array_[i], i);
          }
        }

        this.updateLength_();

      }

      if ( BaseObject$$1 ) Collection.__proto__ = BaseObject$$1;
      Collection.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Collection.prototype.constructor = Collection;

      /**
       * Remove all elements from the collection.
       * @api
       */
      Collection.prototype.clear = function clear () {
        var this$1 = this;

        while (this.getLength() > 0) {
          this$1.pop();
        }
      };

      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array.<T>} arr Array.
       * @return {module:ol/Collection.<T>} This collection.
       * @api
       */
      Collection.prototype.extend = function extend (arr) {
        var this$1 = this;

        for (var i = 0, ii = arr.length; i < ii; ++i) {
          this$1.push(arr[i]);
        }
        return this;
      };

      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array.<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      Collection.prototype.forEach = function forEach (f) {
        var array = this.array_;
        for (var i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      };

      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array.<T>} Array.
       * @api
       */
      Collection.prototype.getArray = function getArray () {
        return this.array_;
      };

      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      Collection.prototype.item = function item (index) {
        return this.array_[index];
      };

      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      Collection.prototype.getLength = function getLength () {
        return /** @type {number} */ (this.get(Property.LENGTH));
      };

      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.insertAt = function insertAt (index, elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType.ADD, elem));
      };

      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      Collection.prototype.pop = function pop () {
        return this.removeAt(this.getLength() - 1);
      };

      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      Collection.prototype.push = function push (elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        var n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      };

      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      Collection.prototype.remove = function remove (elem) {
        var this$1 = this;

        var arr = this.array_;
        for (var i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this$1.removeAt(i);
          }
        }
        return undefined;
      };

      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      Collection.prototype.removeAt = function removeAt (index) {
        var prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev));
        return prev;
      };

      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.setAt = function setAt (index, elem) {
        var this$1 = this;

        var n = this.getLength();
        if (index < n) {
          if (this.unique_) {
            this.assertUnique_(elem, index);
          }
          var prev = this.array_[index];
          this.array_[index] = elem;
          this.dispatchEvent(
            new CollectionEvent(CollectionEventType.REMOVE, prev));
          this.dispatchEvent(
            new CollectionEvent(CollectionEventType.ADD, elem));
        } else {
          for (var j = n; j < index; ++j) {
            this$1.insertAt(j, undefined);
          }
          this.insertAt(index, elem);
        }
      };

      /**
       * @private
       */
      Collection.prototype.updateLength_ = function updateLength_ () {
        this.set(Property.LENGTH, this.array_.length);
      };

      /**
       * @private
       * @param {T} elem Element.
       * @param {number=} opt_except Optional index to ignore.
       */
      Collection.prototype.assertUnique_ = function assertUnique_ (elem, opt_except) {
        var this$1 = this;

        for (var i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this$1.array_[i] === elem && i !== opt_except) {
            throw new AssertionError(58);
          }
        }
      };

      return Collection;
    }(BaseObject));

    /**
     * @module ol/MapEvent
     */

    /**
     * @classdesc
     * Events emitted as map events are instances of this type.
     * See {@link module:ol/Map~Map} for which events trigger a map event.
     */
    var MapEvent = (function (Event$$1) {
      function MapEvent(type, map, opt_frameState) {

        Event$$1.call(this, type);

        /**
         * The map where the event occurred.
         * @type {module:ol/PluggableMap}
         * @api
         */
        this.map = map;

        /**
         * The frame state at the time of the event.
         * @type {?module:ol/PluggableMap~FrameState}
         * @api
         */
        this.frameState = opt_frameState !== undefined ? opt_frameState : null;

      }

      if ( Event$$1 ) MapEvent.__proto__ = Event$$1;
      MapEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      MapEvent.prototype.constructor = MapEvent;

      return MapEvent;
    }(Event));

    /**
     * @module ol/MapBrowserEvent
     */

    /**
     * @classdesc
     * Events emitted as map browser events are instances of this type.
     * See {@link module:ol/Map~Map} for which events trigger a map browser event.
     */
    var MapBrowserEvent = (function (MapEvent$$1) {
      function MapBrowserEvent(type, map, browserEvent, opt_dragging, opt_frameState) {

        MapEvent$$1.call(this, type, map, opt_frameState);

        /**
         * The original browser event.
         * @const
         * @type {Event}
         * @api
         */
        this.originalEvent = browserEvent;

        /**
         * The map pixel relative to the viewport corresponding to the original browser event.
         * @type {module:ol/pixel~Pixel}
         * @api
         */
        this.pixel = map.getEventPixel(browserEvent);

        /**
         * The coordinate in view projection corresponding to the original browser event.
         * @type {module:ol/coordinate~Coordinate}
         * @api
         */
        this.coordinate = map.getCoordinateFromPixel(this.pixel);

        /**
         * Indicates if the map is currently being dragged. Only set for
         * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
         *
         * @type {boolean}
         * @api
         */
        this.dragging = opt_dragging !== undefined ? opt_dragging : false;

      }

      if ( MapEvent$$1 ) MapBrowserEvent.__proto__ = MapEvent$$1;
      MapBrowserEvent.prototype = Object.create( MapEvent$$1 && MapEvent$$1.prototype );
      MapBrowserEvent.prototype.constructor = MapBrowserEvent;

      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @override
       * @api
       */
      MapBrowserEvent.prototype.preventDefault = function preventDefault () {
        MapEvent$$1.prototype.preventDefault.call(this);
        this.originalEvent.preventDefault();
      };

      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @override
       * @api
       */
      MapBrowserEvent.prototype.stopPropagation = function stopPropagation () {
        MapEvent$$1.prototype.stopPropagation.call(this);
        this.originalEvent.stopPropagation();
      };

      return MapBrowserEvent;
    }(MapEvent));

    /**
     * @module ol/webgl
     */


    /** end of goog.webgl constants
     */


    /**
     * @const
     * @type {Array.<string>}
     */
    var CONTEXT_IDS = [
      'experimental-webgl',
      'webgl',
      'webkit-3d',
      'moz-webgl'
    ];


    /**
     * @param {HTMLCanvasElement} canvas Canvas.
     * @param {Object=} opt_attributes Attributes.
     * @return {WebGLRenderingContext} WebGL rendering context.
     */
    function getContext(canvas, opt_attributes) {
      var ii = CONTEXT_IDS.length;
      for (var i = 0; i < ii; ++i) {
        try {
          var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);
          if (context) {
            return /** @type {!WebGLRenderingContext} */ (context);
          }
        } catch (e) {
          // pass
        }
      }
      return null;
    }


    /**
     * The maximum supported WebGL texture size in pixels. If WebGL is not
     * supported, the value is set to `undefined`.
     * @type {number|undefined}
     */
    var MAX_TEXTURE_SIZE; // value is set below


    /**
     * List of supported WebGL extensions.
     * @type {Array.<string>}
     */
    var EXTENSIONS; // value is set below

    //TODO Remove side effects
    if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
      try {
        var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));
        var gl = getContext(canvas, {failIfMajorPerformanceCaveat: true});
        if (gl) {
          MAX_TEXTURE_SIZE = /** @type {number} */ (gl.getParameter(gl.MAX_TEXTURE_SIZE));
          EXTENSIONS = gl.getSupportedExtensions();
        }
      } catch (e) {
        // pass
      }
    }

    /**
     * @module ol/has
     */

    var ua = typeof navigator !== 'undefined' ?
      navigator.userAgent.toLowerCase() : '';

    /**
     * User agent string says we are dealing with Firefox as browser.
     * @type {boolean}
     */
    var FIREFOX = ua.indexOf('firefox') !== -1;

    /**
     * User agent string says we are dealing with Safari as browser.
     * @type {boolean}
     */
    var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

    /**
     * User agent string says we are dealing with a WebKit engine.
     * @type {boolean}
     */
    var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

    /**
     * User agent string says we are dealing with a Mac as platform.
     * @type {boolean}
     */
    var MAC = ua.indexOf('macintosh') !== -1;


    /**
     * The ratio between physical pixels and device-independent pixels
     * (dips) on the device (`window.devicePixelRatio`).
     * @const
     * @type {number}
     * @api
     */
    var DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;


    /**
     * True if the browser's Canvas implementation implements {get,set}LineDash.
     * @type {boolean}
     */
    var CANVAS_LINE_DASH = function() {
      var has = false;
      try {
        has = !!document.createElement('CANVAS').getContext('2d').setLineDash;
      } catch (e) {
        // pass
      }
      return has;
    }();


    /**
     * True if browser supports touch events.
     * @const
     * @type {boolean}
     * @api
     */
    var TOUCH = 'ontouchstart' in window;


    /**
     * True if browser supports pointer events.
     * @const
     * @type {boolean}
     */
    var POINTER = 'PointerEvent' in window;


    /**
     * True if browser supports ms pointer events (IE 10).
     * @const
     * @type {boolean}
     */
    var MSPOINTER = !!(navigator.msPointerEnabled);

    /**
     * @module ol/MapBrowserEventType
     */

    /**
     * Constants for event names.
     * @enum {string}
     */
    var MapBrowserEventType = {

      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',

      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,

      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,

      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',

      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',

      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel'
    };

    /**
     * @module ol/MapBrowserPointerEvent
     */

    var MapBrowserPointerEvent = (function (MapBrowserEvent$$1) {
      function MapBrowserPointerEvent(type, map, pointerEvent, opt_dragging, opt_frameState) {

        MapBrowserEvent$$1.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

        /**
         * @const
         * @type {module:ol/pointer/PointerEvent}
         */
        this.pointerEvent = pointerEvent;

      }

      if ( MapBrowserEvent$$1 ) MapBrowserPointerEvent.__proto__ = MapBrowserEvent$$1;
      MapBrowserPointerEvent.prototype = Object.create( MapBrowserEvent$$1 && MapBrowserEvent$$1.prototype );
      MapBrowserPointerEvent.prototype.constructor = MapBrowserPointerEvent;

      return MapBrowserPointerEvent;
    }(MapBrowserEvent));

    /**
     * @module ol/pointer/EventType
     */

    /**
     * Constants for event names.
     * @enum {string}
     */
    var PointerEventType = {
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel'
    };

    /**
     * @module ol/pointer/EventSource
     */

    var EventSource = function EventSource(dispatcher, mapping) {

      /**
       * @type {module:ol/pointer/PointerEventHandler}
       */
      this.dispatcher = dispatcher;

      /**
       * @private
       * @const
       * @type {!Object.<string, function(Event)>}
       */
      this.mapping_ = mapping;
    };

    /**
     * List of events supported by this source.
     * @return {Array.<string>} Event names
     */
    EventSource.prototype.getEvents = function getEvents () {
      return Object.keys(this.mapping_);
    };

    /**
     * Returns the handler that should handle a given event type.
     * @param {string} eventType The event type.
     * @return {function(Event)} Handler
     */
    EventSource.prototype.getHandlerForEvent = function getHandlerForEvent (eventType) {
      return this.mapping_[eventType];
    };

    /**
     * @module ol/pointer/MouseSource
     */


    /**
     * @type {number}
     */
    var POINTER_ID = 1;


    /**
     * @type {string}
     */
    var POINTER_TYPE = 'mouse';


    /**
     * Radius around touchend that swallows mouse events.
     *
     * @type {number}
     */
    var DEDUP_DIST = 25;

    /**
     * Handler for `mousedown`.
     *
     * @this {module:ol/pointer/MouseSource}
     * @param {MouseEvent} inEvent The in event.
     */
    function mousedown(inEvent) {
      if (!this.isEventSimulatedFromTouch_(inEvent)) {
        // TODO(dfreedman) workaround for some elements not sending mouseup
        // http://crbug/149091
        if (POINTER_ID.toString() in this.pointerMap) {
          this.cancel(inEvent);
        }
        var e = prepareEvent(inEvent, this.dispatcher);
        this.pointerMap[POINTER_ID.toString()] = inEvent;
        this.dispatcher.down(e, inEvent);
      }
    }

    /**
     * Handler for `mousemove`.
     *
     * @this {module:ol/pointer/MouseSource}
     * @param {MouseEvent} inEvent The in event.
     */
    function mousemove(inEvent) {
      if (!this.isEventSimulatedFromTouch_(inEvent)) {
        var e = prepareEvent(inEvent, this.dispatcher);
        this.dispatcher.move(e, inEvent);
      }
    }

    /**
     * Handler for `mouseup`.
     *
     * @this {module:ol/pointer/MouseSource}
     * @param {MouseEvent} inEvent The in event.
     */
    function mouseup(inEvent) {
      if (!this.isEventSimulatedFromTouch_(inEvent)) {
        var p = this.pointerMap[POINTER_ID.toString()];

        if (p && p.button === inEvent.button) {
          var e = prepareEvent(inEvent, this.dispatcher);
          this.dispatcher.up(e, inEvent);
          this.cleanupMouse();
        }
      }
    }

    /**
     * Handler for `mouseover`.
     *
     * @this {module:ol/pointer/MouseSource}
     * @param {MouseEvent} inEvent The in event.
     */
    function mouseover(inEvent) {
      if (!this.isEventSimulatedFromTouch_(inEvent)) {
        var e = prepareEvent(inEvent, this.dispatcher);
        this.dispatcher.enterOver(e, inEvent);
      }
    }

    /**
     * Handler for `mouseout`.
     *
     * @this {module:ol/pointer/MouseSource}
     * @param {MouseEvent} inEvent The in event.
     */
    function mouseout(inEvent) {
      if (!this.isEventSimulatedFromTouch_(inEvent)) {
        var e = prepareEvent(inEvent, this.dispatcher);
        this.dispatcher.leaveOut(e, inEvent);
      }
    }


    var MouseSource = (function (EventSource$$1) {
      function MouseSource(dispatcher) {
        var mapping = {
          'mousedown': mousedown,
          'mousemove': mousemove,
          'mouseup': mouseup,
          'mouseover': mouseover,
          'mouseout': mouseout
        };
        EventSource$$1.call(this, dispatcher, mapping);

        /**
         * @const
         * @type {!Object.<string, Event|Object>}
         */
        this.pointerMap = dispatcher.pointerMap;

        /**
         * @const
         * @type {Array.<module:ol/pixel~Pixel>}
         */
        this.lastTouches = [];
      }

      if ( EventSource$$1 ) MouseSource.__proto__ = EventSource$$1;
      MouseSource.prototype = Object.create( EventSource$$1 && EventSource$$1.prototype );
      MouseSource.prototype.constructor = MouseSource;

      /**
       * Detect if a mouse event was simulated from a touch by
       * checking if previously there was a touch event at the
       * same position.
       *
       * FIXME - Known problem with the native Android browser on
       * Samsung GT-I9100 (Android 4.1.2):
       * In case the page is scrolled, this function does not work
       * correctly when a canvas is used (WebGL or canvas renderer).
       * Mouse listeners on canvas elements (for this browser), create
       * two mouse events: One 'good' and one 'bad' one (on other browsers or
       * when a div is used, there is only one event). For the 'bad' one,
       * clientX/clientY and also pageX/pageY are wrong when the page
       * is scrolled. Because of that, this function can not detect if
       * the events were simulated from a touch event. As result, a
       * pointer event at a wrong position is dispatched, which confuses
       * the map interactions.
       * It is unclear, how one can get the correct position for the event
       * or detect that the positions are invalid.
       *
       * @private
       * @param {MouseEvent} inEvent The in event.
       * @return {boolean} True, if the event was generated by a touch.
       */
      MouseSource.prototype.isEventSimulatedFromTouch_ = function isEventSimulatedFromTouch_ (inEvent) {
        var lts = this.lastTouches;
        var x = inEvent.clientX;
        var y = inEvent.clientY;
        for (var i = 0, l = lts.length, t = (void 0); i < l && (t = lts[i]); i++) {
          // simulated mouse events will be swallowed near a primary touchend
          var dx = Math.abs(x - t[0]);
          var dy = Math.abs(y - t[1]);
          if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
            return true;
          }
        }
        return false;
      };

      /**
       * Dispatches a `pointercancel` event.
       *
       * @param {Event} inEvent The in event.
       */
      MouseSource.prototype.cancel = function cancel (inEvent) {
        var e = prepareEvent(inEvent, this.dispatcher);
        this.dispatcher.cancel(e, inEvent);
        this.cleanupMouse();
      };

      /**
       * Remove the mouse from the list of active pointers.
       */
      MouseSource.prototype.cleanupMouse = function cleanupMouse () {
        delete this.pointerMap[POINTER_ID.toString()];
      };

      return MouseSource;
    }(EventSource));


    /**
     * Creates a copy of the original event that will be used
     * for the fake pointer event.
     *
     * @param {Event} inEvent The in event.
     * @param {module:ol/pointer/PointerEventHandler} dispatcher Event handler.
     * @return {Object} The copied event.
     */
    function prepareEvent(inEvent, dispatcher) {
      var e = dispatcher.cloneEvent(inEvent, inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };

      e.pointerId = POINTER_ID;
      e.isPrimary = true;
      e.pointerType = POINTER_TYPE;

      return e;
    }

    /**
     * @module ol/pointer/MsSource
     */


    /**
     * @const
     * @type {Array.<string>}
     */
    var POINTER_TYPES = [
      '',
      'unavailable',
      'touch',
      'pen',
      'mouse'
    ];

    /**
     * Handler for `msPointerDown`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerDown(inEvent) {
      this.pointerMap[inEvent.pointerId.toString()] = inEvent;
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.down(e, inEvent);
    }

    /**
     * Handler for `msPointerMove`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerMove(inEvent) {
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.move(e, inEvent);
    }

    /**
     * Handler for `msPointerUp`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerUp(inEvent) {
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.up(e, inEvent);
      this.cleanup(inEvent.pointerId);
    }

    /**
     * Handler for `msPointerOut`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerOut(inEvent) {
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.leaveOut(e, inEvent);
    }

    /**
     * Handler for `msPointerOver`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerOver(inEvent) {
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.enterOver(e, inEvent);
    }

    /**
     * Handler for `msPointerCancel`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msPointerCancel(inEvent) {
      var e = this.prepareEvent_(inEvent);
      this.dispatcher.cancel(e, inEvent);
      this.cleanup(inEvent.pointerId);
    }

    /**
     * Handler for `msLostPointerCapture`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msLostPointerCapture(inEvent) {
      var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
      this.dispatcher.dispatchEvent(e);
    }

    /**
     * Handler for `msGotPointerCapture`.
     *
     * @this {module:ol/pointer/MsSource}
     * @param {MSPointerEvent} inEvent The in event.
     */
    function msGotPointerCapture(inEvent) {
      var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
      this.dispatcher.dispatchEvent(e);
    }

    var MsSource = (function (EventSource$$1) {
      function MsSource(dispatcher) {
        var mapping = {
          'MSPointerDown': msPointerDown,
          'MSPointerMove': msPointerMove,
          'MSPointerUp': msPointerUp,
          'MSPointerOut': msPointerOut,
          'MSPointerOver': msPointerOver,
          'MSPointerCancel': msPointerCancel,
          'MSGotPointerCapture': msGotPointerCapture,
          'MSLostPointerCapture': msLostPointerCapture
        };
        EventSource$$1.call(this, dispatcher, mapping);

        /**
         * @const
         * @type {!Object.<string, MSPointerEvent|Object>}
         */
        this.pointerMap = dispatcher.pointerMap;
      }

      if ( EventSource$$1 ) MsSource.__proto__ = EventSource$$1;
      MsSource.prototype = Object.create( EventSource$$1 && EventSource$$1.prototype );
      MsSource.prototype.constructor = MsSource;

      /**
       * Creates a copy of the original event that will be used
       * for the fake pointer event.
       *
       * @private
       * @param {MSPointerEvent} inEvent The in event.
       * @return {Object} The copied event.
       */
      MsSource.prototype.prepareEvent_ = function prepareEvent_ (inEvent) {
        var e = inEvent;
        if (typeof inEvent.pointerType === 'number') {
          e = this.dispatcher.cloneEvent(inEvent, inEvent);
          e.pointerType = POINTER_TYPES[inEvent.pointerType];
        }

        return e;
      };

      /**
       * Remove this pointer from the list of active pointers.
       * @param {number} pointerId Pointer identifier.
       */
      MsSource.prototype.cleanup = function cleanup (pointerId) {
        delete this.pointerMap[pointerId.toString()];
      };

      return MsSource;
    }(EventSource));

    /**
     * @module ol/pointer/NativeSource
     */

    /**
     * Handler for `pointerdown`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerDown(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `pointermove`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerMove(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `pointerup`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerUp(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `pointerout`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerOut(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `pointerover`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerOver(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `pointercancel`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function pointerCancel(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `lostpointercapture`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function lostPointerCapture(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    /**
     * Handler for `gotpointercapture`.
     *
     * @this {module:ol/pointer/NativeSource}
     * @param {Event} inEvent The in event.
     */
    function gotPointerCapture(inEvent) {
      this.dispatcher.fireNativeEvent(inEvent);
    }

    var NativeSource = (function (EventSource$$1) {
      function NativeSource(dispatcher) {
        var mapping = {
          'pointerdown': pointerDown,
          'pointermove': pointerMove,
          'pointerup': pointerUp,
          'pointerout': pointerOut,
          'pointerover': pointerOver,
          'pointercancel': pointerCancel,
          'gotpointercapture': gotPointerCapture,
          'lostpointercapture': lostPointerCapture
        };
        EventSource$$1.call(this, dispatcher, mapping);
      }

      if ( EventSource$$1 ) NativeSource.__proto__ = EventSource$$1;
      NativeSource.prototype = Object.create( EventSource$$1 && EventSource$$1.prototype );
      NativeSource.prototype.constructor = NativeSource;

      return NativeSource;
    }(EventSource));

    /**
     * @module ol/pointer/PointerEvent
     */


    /**
     * Is the `buttons` property supported?
     * @type {boolean}
     */
    var HAS_BUTTONS = false;


    var PointerEvent = (function (Event$$1) {
      function PointerEvent(type, originalEvent, opt_eventDict) {
        Event$$1.call(this, type);

        /**
         * @const
         * @type {Event}
         */
        this.originalEvent = originalEvent;

        var eventDict = opt_eventDict ? opt_eventDict : {};

        /**
         * @type {number}
         */
        this.buttons = this.getButtons_(eventDict);

        /**
         * @type {number}
         */
        this.pressure = this.getPressure_(eventDict, this.buttons);

        // MouseEvent related properties

        /**
         * @type {boolean}
         */
        this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

        /**
         * @type {boolean}
         */
        this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

        /**
         * @type {Object}
         */
        this.view = 'view' in eventDict ? eventDict['view'] : null;

        /**
         * @type {number}
         */
        this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

        /**
         * @type {number}
         */
        this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

        /**
         * @type {number}
         */
        this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

        /**
         * @type {number}
         */
        this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

        /**
         * @type {number}
         */
        this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

        /**
         * @type {boolean}
         */
        this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

        /**
         * @type {boolean}
         */
        this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

        /**
         * @type {boolean}
         */
        this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

        /**
         * @type {boolean}
         */
        this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

        /**
         * @type {number}
         */
        this.button = 'button' in eventDict ? eventDict['button'] : 0;

        /**
         * @type {Node}
         */
        this.relatedTarget = 'relatedTarget' in eventDict ?
          eventDict['relatedTarget'] : null;

        // PointerEvent related properties

        /**
         * @const
         * @type {number}
         */
        this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

        /**
         * @type {number}
         */
        this.width = 'width' in eventDict ? eventDict['width'] : 0;

        /**
         * @type {number}
         */
        this.height = 'height' in eventDict ? eventDict['height'] : 0;

        /**
         * @type {number}
         */
        this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

        /**
         * @type {number}
         */
        this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

        /**
         * @type {string}
         */
        this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

        /**
         * @type {number}
         */
        this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

        /**
         * @type {boolean}
         */
        this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

        // keep the semantics of preventDefault
        if (originalEvent.preventDefault) {
          this.preventDefault = function() {
            originalEvent.preventDefault();
          };
        }
      }

      if ( Event$$1 ) PointerEvent.__proto__ = Event$$1;
      PointerEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      PointerEvent.prototype.constructor = PointerEvent;

      /**
       * @private
       * @param {Object.<string, ?>} eventDict The event dictionary.
       * @return {number} Button indicator.
       */
      PointerEvent.prototype.getButtons_ = function getButtons_ (eventDict) {
        // According to the w3c spec,
        // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
        // MouseEvent.button == 0 can mean either no mouse button depressed, or the
        // left mouse button depressed.
        //
        // As of now, the only way to distinguish between the two states of
        // MouseEvent.button is by using the deprecated MouseEvent.which property, as
        // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
        // no mouse button is held.
        //
        // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
        // but initMouseEvent does not expose an argument with which to set
        // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
        // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
        // of app developers.
        //
        // The only way to propagate the correct state of MouseEvent.which and
        // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
        // is to call initMouseEvent with a buttonArg value of -1.
        //
        // This is fixed with DOM Level 4's use of buttons
        var buttons;
        if (eventDict.buttons || HAS_BUTTONS) {
          buttons = eventDict.buttons;
        } else {
          switch (eventDict.which) {
            case 1: buttons = 1; break;
            case 2: buttons = 4; break;
            case 3: buttons = 2; break;
            default: buttons = 0;
          }
        }
        return buttons;
      };

      /**
       * @private
       * @param {Object.<string, ?>} eventDict The event dictionary.
       * @param {number} buttons Button indicator.
       * @return {number} The pressure.
       */
      PointerEvent.prototype.getPressure_ = function getPressure_ (eventDict, buttons) {
        // Spec requires that pointers without pressure specified use 0.5 for down
        // state and 0 for up state.
        var pressure = 0;
        if (eventDict.pressure) {
          pressure = eventDict.pressure;
        } else {
          pressure = buttons ? 0.5 : 0;
        }
        return pressure;
      };

      return PointerEvent;
    }(Event));


    /**
     * Checks if the `buttons` property is supported.
     */
    (function() {
      try {
        var ev = new MouseEvent('click', {buttons: 1});
        HAS_BUTTONS = ev.buttons === 1;
      } catch (e) {
        // pass
      }
    })();

    /**
     * @module ol/array
     */


    /**
     * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
     * https://github.com/darkskyapp/binary-search
     *
     * @param {Array.<*>} haystack Items to search through.
     * @param {*} needle The item to look for.
     * @param {Function=} opt_comparator Comparator function.
     * @return {number} The index of the item if found, -1 if not.
     */
    function binarySearch(haystack, needle, opt_comparator) {
      var mid, cmp;
      var comparator = opt_comparator || numberSafeCompareFunction;
      var low = 0;
      var high = haystack.length;
      var found = false;

      while (low < high) {
        /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
         * to double (which gives the wrong results). */
        mid = low + (high - low >> 1);
        cmp = +comparator(haystack[mid], needle);

        if (cmp < 0.0) { /* Too low. */
          low = mid + 1;

        } else { /* Key found or too high */
          high = mid;
          found = !cmp;
        }
      }

      /* Key not found. */
      return found ? low : ~low;
    }


    /**
     * Compare function for array sort that is safe for numbers.
     * @param {*} a The first object to be compared.
     * @param {*} b The second object to be compared.
     * @return {number} A negative number, zero, or a positive number as the first
     *     argument is less than, equal to, or greater than the second.
     */
    function numberSafeCompareFunction(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
    }


    /**
     * Whether the array contains the given object.
     * @param {Array.<*>} arr The array to test for the presence of the element.
     * @param {*} obj The object for which to test.
     * @return {boolean} The object is in the array.
     */
    function includes(arr, obj) {
      return arr.indexOf(obj) >= 0;
    }


    /**
     * @param {Array.<number>} arr Array.
     * @param {number} target Target.
     * @param {number} direction 0 means return the nearest, > 0
     *    means return the largest nearest, < 0 means return the
     *    smallest nearest.
     * @return {number} Index.
     */
    function linearFindNearest(arr, target, direction) {
      var n = arr.length;
      if (arr[0] <= target) {
        return 0;
      } else if (target <= arr[n - 1]) {
        return n - 1;
      } else {
        var i;
        if (direction > 0) {
          for (i = 1; i < n; ++i) {
            if (arr[i] < target) {
              return i - 1;
            }
          }
        } else if (direction < 0) {
          for (i = 1; i < n; ++i) {
            if (arr[i] <= target) {
              return i;
            }
          }
        } else {
          for (i = 1; i < n; ++i) {
            if (arr[i] == target) {
              return i;
            } else if (arr[i] < target) {
              if (arr[i - 1] - target < target - arr[i]) {
                return i - 1;
              } else {
                return i;
              }
            }
          }
        }
        return n - 1;
      }
    }


    /**
     * @param {Array.<*>} arr Array.
     * @param {number} begin Begin index.
     * @param {number} end End index.
     */
    function reverseSubArray(arr, begin, end) {
      while (begin < end) {
        var tmp = arr[begin];
        arr[begin] = arr[end];
        arr[end] = tmp;
        ++begin;
        --end;
      }
    }


    /**
     * @param {Array.<VALUE>} arr The array to modify.
     * @param {!Array.<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
     * @template VALUE
     */
    function extend(arr, data) {
      var extension = Array.isArray(data) ? data : [data];
      var length = extension.length;
      for (var i = 0; i < length; i++) {
        arr[arr.length] = extension[i];
      }
    }


    /**
     * @param {Array.<VALUE>} arr The array to modify.
     * @param {VALUE} obj The element to remove.
     * @template VALUE
     * @return {boolean} If the element was removed.
     */
    function remove(arr, obj) {
      var i = arr.indexOf(obj);
      var found = i > -1;
      if (found) {
        arr.splice(i, 1);
      }
      return found;
    }


    /**
     * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
     * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
     * @return {boolean} Whether the two arrays are equal.
     */
    function equals(arr1, arr2) {
      var len1 = arr1.length;
      if (len1 !== arr2.length) {
        return false;
      }
      for (var i = 0; i < len1; i++) {
        if (arr1[i] !== arr2[i]) {
          return false;
        }
      }
      return true;
    }


    /**
     * @param {Array.<*>} arr The array to sort (modifies original).
     * @param {Function} compareFnc Comparison function.
     */
    function stableSort(arr, compareFnc) {
      var length = arr.length;
      var tmp = Array(arr.length);
      var i;
      for (i = 0; i < length; i++) {
        tmp[i] = {index: i, value: arr[i]};
      }
      tmp.sort(function(a, b) {
        return compareFnc(a.value, b.value) || a.index - b.index;
      });
      for (i = 0; i < arr.length; i++) {
        arr[i] = tmp[i].value;
      }
    }


    /**
     * @param {Array.<*>} arr The array to test.
     * @param {Function=} opt_func Comparison function.
     * @param {boolean=} opt_strict Strictly sorted (default false).
     * @return {boolean} Return index.
     */
    function isSorted(arr, opt_func, opt_strict) {
      var compare = opt_func || numberSafeCompareFunction;
      return arr.every(function(currentVal, index) {
        if (index === 0) {
          return true;
        }
        var res = compare(arr[index - 1], currentVal);
        return !(res > 0 || opt_strict && res === 0);
      });
    }

    /**
     * @module ol/pointer/TouchSource
     */


    /**
     * @type {number}
     */
    var CLICK_COUNT_TIMEOUT = 200;

    /**
     * @type {string}
     */
    var POINTER_TYPE$1 = 'touch';

    /**
     * Handler for `touchstart`, triggers `pointerover`,
     * `pointerenter` and `pointerdown` events.
     *
     * @this {module:ol/pointer/TouchSource}
     * @param {TouchEvent} inEvent The in event.
     */
    function touchstart(inEvent) {
      this.vacuumTouches_(inEvent);
      this.setPrimaryTouch_(inEvent.changedTouches[0]);
      this.dedupSynthMouse_(inEvent);
      this.clickCount_++;
      this.processTouches_(inEvent, this.overDown_);
    }

    /**
     * Handler for `touchmove`.
     *
     * @this {module:ol/pointer/TouchSource}
     * @param {TouchEvent} inEvent The in event.
     */
    function touchmove(inEvent) {
      inEvent.preventDefault();
      this.processTouches_(inEvent, this.moveOverOut_);
    }

    /**
     * Handler for `touchend`, triggers `pointerup`,
     * `pointerout` and `pointerleave` events.
     *
     * @this {module:ol/pointer/TouchSource}
     * @param {TouchEvent} inEvent The event.
     */
    function touchend(inEvent) {
      this.dedupSynthMouse_(inEvent);
      this.processTouches_(inEvent, this.upOut_);
    }

    /**
     * Handler for `touchcancel`, triggers `pointercancel`,
     * `pointerout` and `pointerleave` events.
     *
     * @this {module:ol/pointer/TouchSource}
     * @param {TouchEvent} inEvent The in event.
     */
    function touchcancel(inEvent) {
      this.processTouches_(inEvent, this.cancelOut_);
    }


    var TouchSource = (function (EventSource$$1) {
      function TouchSource(dispatcher, mouseSource) {
        var mapping = {
          'touchstart': touchstart,
          'touchmove': touchmove,
          'touchend': touchend,
          'touchcancel': touchcancel
        };
        EventSource$$1.call(this, dispatcher, mapping);

        /**
         * @const
         * @type {!Object.<string, Event|Object>}
         */
        this.pointerMap = dispatcher.pointerMap;

        /**
         * @const
         * @type {module:ol/pointer/MouseSource}
         */
        this.mouseSource = mouseSource;

        /**
         * @private
         * @type {number|undefined}
         */
        this.firstTouchId_ = undefined;

        /**
         * @private
         * @type {number}
         */
        this.clickCount_ = 0;

        /**
         * @private
         * @type {number|undefined}
         */
        this.resetId_ = undefined;

        /**
         * Mouse event timeout: This should be long enough to
         * ignore compat mouse events made by touch.
         * @private
         * @type {number}
         */
        this.dedupTimeout_ = 2500;
      }

      if ( EventSource$$1 ) TouchSource.__proto__ = EventSource$$1;
      TouchSource.prototype = Object.create( EventSource$$1 && EventSource$$1.prototype );
      TouchSource.prototype.constructor = TouchSource;

      /**
       * @private
       * @param {Touch} inTouch The in touch.
       * @return {boolean} True, if this is the primary touch.
       */
      TouchSource.prototype.isPrimaryTouch_ = function isPrimaryTouch_ (inTouch) {
        return this.firstTouchId_ === inTouch.identifier;
      };

      /**
       * Set primary touch if there are no pointers, or the only pointer is the mouse.
       * @param {Touch} inTouch The in touch.
       * @private
       */
      TouchSource.prototype.setPrimaryTouch_ = function setPrimaryTouch_ (inTouch) {
        var count = Object.keys(this.pointerMap).length;
        if (count === 0 || (count === 1 && POINTER_ID.toString() in this.pointerMap)) {
          this.firstTouchId_ = inTouch.identifier;
          this.cancelResetClickCount_();
        }
      };

      /**
       * @private
       * @param {PointerEvent} inPointer The in pointer object.
       */
      TouchSource.prototype.removePrimaryPointer_ = function removePrimaryPointer_ (inPointer) {
        if (inPointer.isPrimary) {
          this.firstTouchId_ = undefined;
          this.resetClickCount_();
        }
      };

      /**
       * @private
       */
      TouchSource.prototype.resetClickCount_ = function resetClickCount_ () {
        this.resetId_ = setTimeout(
          this.resetClickCountHandler_.bind(this),
          CLICK_COUNT_TIMEOUT);
      };

      /**
       * @private
       */
      TouchSource.prototype.resetClickCountHandler_ = function resetClickCountHandler_ () {
        this.clickCount_ = 0;
        this.resetId_ = undefined;
      };

      /**
       * @private
       */
      TouchSource.prototype.cancelResetClickCount_ = function cancelResetClickCount_ () {
        if (this.resetId_ !== undefined) {
          clearTimeout(this.resetId_);
        }
      };

      /**
       * @private
       * @param {TouchEvent} browserEvent Browser event
       * @param {Touch} inTouch Touch event
       * @return {PointerEvent} A pointer object.
       */
      TouchSource.prototype.touchToPointer_ = function touchToPointer_ (browserEvent, inTouch) {
        var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
        // Spec specifies that pointerId 1 is reserved for Mouse.
        // Touch identifiers can start at 0.
        // Add 2 to the touch identifier for compatibility.
        e.pointerId = inTouch.identifier + 2;
        // TODO: check if this is necessary?
        //e.target = findTarget(e);
        e.bubbles = true;
        e.cancelable = true;
        e.detail = this.clickCount_;
        e.button = 0;
        e.buttons = 1;
        e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
        e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
        e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
        e.isPrimary = this.isPrimaryTouch_(inTouch);
        e.pointerType = POINTER_TYPE$1;

        // make sure that the properties that are different for
        // each `Touch` object are not copied from the BrowserEvent object
        e.clientX = inTouch.clientX;
        e.clientY = inTouch.clientY;
        e.screenX = inTouch.screenX;
        e.screenY = inTouch.screenY;

        return e;
      };

      /**
       * @private
       * @param {TouchEvent} inEvent Touch event
       * @param {function(TouchEvent, PointerEvent)} inFunction In function.
       */
      TouchSource.prototype.processTouches_ = function processTouches_ (inEvent, inFunction) {
        var this$1 = this;

        var touches = Array.prototype.slice.call(inEvent.changedTouches);
        var count = touches.length;
        function preventDefault() {
          inEvent.preventDefault();
        }
        for (var i = 0; i < count; ++i) {
          var pointer = this$1.touchToPointer_(inEvent, touches[i]);
          // forward touch preventDefaults
          pointer.preventDefault = preventDefault;
          inFunction.call(this$1, inEvent, pointer);
        }
      };

      /**
       * @private
       * @param {TouchList} touchList The touch list.
       * @param {number} searchId Search identifier.
       * @return {boolean} True, if the `Touch` with the given id is in the list.
       */
      TouchSource.prototype.findTouch_ = function findTouch_ (touchList, searchId) {
        var l = touchList.length;
        for (var i = 0; i < l; i++) {
          var touch = touchList[i];
          if (touch.identifier === searchId) {
            return true;
          }
        }
        return false;
      };

      /**
       * In some instances, a touchstart can happen without a touchend. This
       * leaves the pointermap in a broken state.
       * Therefore, on every touchstart, we remove the touches that did not fire a
       * touchend event.
       * To keep state globally consistent, we fire a pointercancel for
       * this "abandoned" touch
       *
       * @private
       * @param {TouchEvent} inEvent The in event.
       */
      TouchSource.prototype.vacuumTouches_ = function vacuumTouches_ (inEvent) {
        var this$1 = this;

        var touchList = inEvent.touches;
        // pointerMap.getCount() should be < touchList.length here,
        // as the touchstart has not been processed yet.
        var keys = Object.keys(this.pointerMap);
        var count = keys.length;
        if (count >= touchList.length) {
          var d = [];
          for (var i = 0; i < count; ++i) {
            var key = keys[i];
            var value = this$1.pointerMap[key];
            // Never remove pointerId == 1, which is mouse.
            // Touch identifiers are 2 smaller than their pointerId, which is the
            // index in pointermap.
            if (key != POINTER_ID && !this$1.findTouch_(touchList, key - 2)) {
              d.push(value.out);
            }
          }
          for (var i$1 = 0; i$1 < d.length; ++i$1) {
            this$1.cancelOut_(inEvent, d[i$1]);
          }
        }
      };

      /**
       * @private
       * @param {TouchEvent} browserEvent The event.
       * @param {PointerEvent} inPointer The in pointer object.
       */
      TouchSource.prototype.overDown_ = function overDown_ (browserEvent, inPointer) {
        this.pointerMap[inPointer.pointerId] = {
          target: inPointer.target,
          out: inPointer,
          outTarget: inPointer.target
        };
        this.dispatcher.over(inPointer, browserEvent);
        this.dispatcher.enter(inPointer, browserEvent);
        this.dispatcher.down(inPointer, browserEvent);
      };

      /**
       * @private
       * @param {TouchEvent} browserEvent The event.
       * @param {PointerEvent} inPointer The in pointer.
       */
      TouchSource.prototype.moveOverOut_ = function moveOverOut_ (browserEvent, inPointer) {
        var event = inPointer;
        var pointer = this.pointerMap[event.pointerId];
        // a finger drifted off the screen, ignore it
        if (!pointer) {
          return;
        }
        var outEvent = pointer.out;
        var outTarget = pointer.outTarget;
        this.dispatcher.move(event, browserEvent);
        if (outEvent && outTarget !== event.target) {
          outEvent.relatedTarget = event.target;
          event.relatedTarget = outTarget;
          // recover from retargeting by shadow
          outEvent.target = outTarget;
          if (event.target) {
            this.dispatcher.leaveOut(outEvent, browserEvent);
            this.dispatcher.enterOver(event, browserEvent);
          } else {
            // clean up case when finger leaves the screen
            event.target = outTarget;
            event.relatedTarget = null;
            this.cancelOut_(browserEvent, event);
          }
        }
        pointer.out = event;
        pointer.outTarget = event.target;
      };

      /**
       * @private
       * @param {TouchEvent} browserEvent An event.
       * @param {PointerEvent} inPointer The inPointer object.
       */
      TouchSource.prototype.upOut_ = function upOut_ (browserEvent, inPointer) {
        this.dispatcher.up(inPointer, browserEvent);
        this.dispatcher.out(inPointer, browserEvent);
        this.dispatcher.leave(inPointer, browserEvent);
        this.cleanUpPointer_(inPointer);
      };

      /**
       * @private
       * @param {TouchEvent} browserEvent The event.
       * @param {PointerEvent} inPointer The in pointer.
       */
      TouchSource.prototype.cancelOut_ = function cancelOut_ (browserEvent, inPointer) {
        this.dispatcher.cancel(inPointer, browserEvent);
        this.dispatcher.out(inPointer, browserEvent);
        this.dispatcher.leave(inPointer, browserEvent);
        this.cleanUpPointer_(inPointer);
      };

      /**
       * @private
       * @param {PointerEvent} inPointer The inPointer object.
       */
      TouchSource.prototype.cleanUpPointer_ = function cleanUpPointer_ (inPointer) {
        delete this.pointerMap[inPointer.pointerId];
        this.removePrimaryPointer_(inPointer);
      };

      /**
       * Prevent synth mouse events from creating pointer events.
       *
       * @private
       * @param {TouchEvent} inEvent The in event.
       */
      TouchSource.prototype.dedupSynthMouse_ = function dedupSynthMouse_ (inEvent) {
        var lts = this.mouseSource.lastTouches;
        var t = inEvent.changedTouches[0];
        // only the primary finger will synth mouse events
        if (this.isPrimaryTouch_(t)) {
          // remember x/y of last touch
          var lt = [t.clientX, t.clientY];
          lts.push(lt);

          setTimeout(function() {
            // remove touch after timeout
            remove(lts, lt);
          }, this.dedupTimeout_);
        }
      };

      return TouchSource;
    }(EventSource));

    /**
     * @module ol/pointer/PointerEventHandler
     */


    /**
     * Properties to copy when cloning an event, with default values.
     * @type {Array.<Array>}
     */
    var CLONE_PROPS = [
      // MouseEvent
      ['bubbles', false],
      ['cancelable', false],
      ['view', null],
      ['detail', null],
      ['screenX', 0],
      ['screenY', 0],
      ['clientX', 0],
      ['clientY', 0],
      ['ctrlKey', false],
      ['altKey', false],
      ['shiftKey', false],
      ['metaKey', false],
      ['button', 0],
      ['relatedTarget', null],
      // DOM Level 3
      ['buttons', 0],
      // PointerEvent
      ['pointerId', 0],
      ['width', 0],
      ['height', 0],
      ['pressure', 0],
      ['tiltX', 0],
      ['tiltY', 0],
      ['pointerType', ''],
      ['hwTimestamp', 0],
      ['isPrimary', false],
      // event instance
      ['type', ''],
      ['target', null],
      ['currentTarget', null],
      ['which', 0]
    ];


    var PointerEventHandler = (function (EventTarget$$1) {
      function PointerEventHandler(element) {
        EventTarget$$1.call(this);

        /**
         * @const
         * @private
         * @type {Element|HTMLDocument}
         */
        this.element_ = element;

        /**
         * @const
         * @type {!Object.<string, Event|Object>}
         */
        this.pointerMap = {};

        /**
         * @type {Object.<string, function(Event)>}
         * @private
         */
        this.eventMap_ = {};

        /**
         * @type {Array.<module:ol/pointer/EventSource>}
         * @private
         */
        this.eventSourceList_ = [];

        this.registerSources();
      }

      if ( EventTarget$$1 ) PointerEventHandler.__proto__ = EventTarget$$1;
      PointerEventHandler.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      PointerEventHandler.prototype.constructor = PointerEventHandler;

      /**
       * Set up the event sources (mouse, touch and native pointers)
       * that generate pointer events.
       */
      PointerEventHandler.prototype.registerSources = function registerSources () {
        if (POINTER) {
          this.registerSource('native', new NativeSource(this));
        } else if (MSPOINTER) {
          this.registerSource('ms', new MsSource(this));
        } else {
          var mouseSource = new MouseSource(this);
          this.registerSource('mouse', mouseSource);

          if (TOUCH) {
            this.registerSource('touch', new TouchSource(this, mouseSource));
          }
        }

        // register events on the viewport element
        this.register_();
      };

      /**
       * Add a new event source that will generate pointer events.
       *
       * @param {string} name A name for the event source
       * @param {module:ol/pointer/EventSource} source The source event.
       */
      PointerEventHandler.prototype.registerSource = function registerSource (name, source) {
        var s = source;
        var newEvents = s.getEvents();

        if (newEvents) {
          newEvents.forEach(function(e) {
            var handler = s.getHandlerForEvent(e);

            if (handler) {
              this.eventMap_[e] = handler.bind(s);
            }
          }.bind(this));
          this.eventSourceList_.push(s);
        }
      };

      /**
       * Set up the events for all registered event sources.
       * @private
       */
      PointerEventHandler.prototype.register_ = function register_ () {
        var this$1 = this;

        var l = this.eventSourceList_.length;
        for (var i = 0; i < l; i++) {
          var eventSource = this$1.eventSourceList_[i];
          this$1.addEvents_(eventSource.getEvents());
        }
      };

      /**
       * Remove all registered events.
       * @private
       */
      PointerEventHandler.prototype.unregister_ = function unregister_ () {
        var this$1 = this;

        var l = this.eventSourceList_.length;
        for (var i = 0; i < l; i++) {
          var eventSource = this$1.eventSourceList_[i];
          this$1.removeEvents_(eventSource.getEvents());
        }
      };

      /**
       * Calls the right handler for a new event.
       * @private
       * @param {Event} inEvent Browser event.
       */
      PointerEventHandler.prototype.eventHandler_ = function eventHandler_ (inEvent) {
        var type = inEvent.type;
        var handler = this.eventMap_[type];
        if (handler) {
          handler(inEvent);
        }
      };

      /**
       * Setup listeners for the given events.
       * @private
       * @param {Array.<string>} events List of events.
       */
      PointerEventHandler.prototype.addEvents_ = function addEvents_ (events) {
        events.forEach(function(eventName) {
          listen(this.element_, eventName, this.eventHandler_, this);
        }.bind(this));
      };

      /**
       * Unregister listeners for the given events.
       * @private
       * @param {Array.<string>} events List of events.
       */
      PointerEventHandler.prototype.removeEvents_ = function removeEvents_ (events) {
        events.forEach(function(e) {
          unlisten(this.element_, e, this.eventHandler_, this);
        }.bind(this));
      };

      /**
       * Returns a snapshot of inEvent, with writable properties.
       *
       * @param {Event} event Browser event.
       * @param {Event|Touch} inEvent An event that contains
       *    properties to copy.
       * @return {Object} An object containing shallow copies of
       *    `inEvent`'s properties.
       */
      PointerEventHandler.prototype.cloneEvent = function cloneEvent (event, inEvent) {
        var eventCopy = {};
        for (var i = 0, ii = CLONE_PROPS.length; i < ii; i++) {
          var p = CLONE_PROPS[i][0];
          eventCopy[p] = event[p] || inEvent[p] || CLONE_PROPS[i][1];
        }

        return eventCopy;
      };

      // EVENTS


      /**
       * Triggers a 'pointerdown' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.down = function down (data, event) {
        this.fireEvent(PointerEventType.POINTERDOWN, data, event);
      };

      /**
       * Triggers a 'pointermove' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.move = function move (data, event) {
        this.fireEvent(PointerEventType.POINTERMOVE, data, event);
      };

      /**
       * Triggers a 'pointerup' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.up = function up (data, event) {
        this.fireEvent(PointerEventType.POINTERUP, data, event);
      };

      /**
       * Triggers a 'pointerenter' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.enter = function enter (data, event) {
        data.bubbles = false;
        this.fireEvent(PointerEventType.POINTERENTER, data, event);
      };

      /**
       * Triggers a 'pointerleave' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.leave = function leave (data, event) {
        data.bubbles = false;
        this.fireEvent(PointerEventType.POINTERLEAVE, data, event);
      };

      /**
       * Triggers a 'pointerover' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.over = function over (data, event) {
        data.bubbles = true;
        this.fireEvent(PointerEventType.POINTEROVER, data, event);
      };

      /**
       * Triggers a 'pointerout' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.out = function out (data, event) {
        data.bubbles = true;
        this.fireEvent(PointerEventType.POINTEROUT, data, event);
      };

      /**
       * Triggers a 'pointercancel' event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.cancel = function cancel (data, event) {
        this.fireEvent(PointerEventType.POINTERCANCEL, data, event);
      };

      /**
       * Triggers a combination of 'pointerout' and 'pointerleave' events.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.leaveOut = function leaveOut (data, event) {
        this.out(data, event);
        if (!this.contains_(data.target, data.relatedTarget)) {
          this.leave(data, event);
        }
      };

      /**
       * Triggers a combination of 'pointerover' and 'pointerevents' events.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.enterOver = function enterOver (data, event) {
        this.over(data, event);
        if (!this.contains_(data.target, data.relatedTarget)) {
          this.enter(data, event);
        }
      };

      /**
       * @private
       * @param {Element} container The container element.
       * @param {Element} contained The contained element.
       * @return {boolean} Returns true if the container element
       *   contains the other element.
       */
      PointerEventHandler.prototype.contains_ = function contains_ (container, contained) {
        if (!container || !contained) {
          return false;
        }
        return container.contains(contained);
      };

      // EVENT CREATION AND TRACKING
      /**
       * Creates a new Event of type `inType`, based on the information in
       * `data`.
       *
       * @param {string} inType A string representing the type of event to create.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       * @return {module:ol/pointer/PointerEvent} A PointerEvent of type `inType`.
       */
      PointerEventHandler.prototype.makeEvent = function makeEvent (inType, data, event) {
        return new PointerEvent(inType, event, data);
      };

      /**
       * Make and dispatch an event in one call.
       * @param {string} inType A string representing the type of event.
       * @param {Object} data Pointer event data.
       * @param {Event} event The event.
       */
      PointerEventHandler.prototype.fireEvent = function fireEvent (inType, data, event) {
        var e = this.makeEvent(inType, data, event);
        this.dispatchEvent(e);
      };

      /**
       * Creates a pointer event from a native pointer event
       * and dispatches this event.
       * @param {Event} event A platform event with a target.
       */
      PointerEventHandler.prototype.fireNativeEvent = function fireNativeEvent (event) {
        var e = this.makeEvent(event.type, event, event);
        this.dispatchEvent(e);
      };

      /**
       * Wrap a native mouse event into a pointer event.
       * This proxy method is required for the legacy IE support.
       * @param {string} eventType The pointer event type.
       * @param {Event} event The event.
       * @return {module:ol/pointer/PointerEvent} The wrapped event.
       */
      PointerEventHandler.prototype.wrapMouseEvent = function wrapMouseEvent (eventType, event) {
        var pointerEvent = this.makeEvent(
          eventType, MouseSource.prepareEvent(event, this), event);
        return pointerEvent;
      };

      /**
       * @inheritDoc
       */
      PointerEventHandler.prototype.disposeInternal = function disposeInternal () {
        this.unregister_();
        EventTarget$$1.prototype.disposeInternal.call(this);
      };

      return PointerEventHandler;
    }(EventTarget));

    /**
     * @module ol/MapBrowserEventHandler
     */

    var MapBrowserEventHandler = (function (EventTarget$$1) {
      function MapBrowserEventHandler(map, moveTolerance) {

        EventTarget$$1.call(this);

        /**
         * This is the element that we will listen to the real events on.
         * @type {module:ol/PluggableMap}
         * @private
         */
        this.map_ = map;

        /**
         * @type {number}
         * @private
         */
        this.clickTimeoutId_ = 0;

        /**
         * @type {boolean}
         * @private
         */
        this.dragging_ = false;

        /**
         * @type {!Array.<module:ol/events~EventsKey>}
         * @private
         */
        this.dragListenerKeys_ = [];

        /**
         * @type {number}
         * @private
         */
        this.moveTolerance_ = moveTolerance ?
          moveTolerance * DEVICE_PIXEL_RATIO : DEVICE_PIXEL_RATIO;

        /**
         * The most recent "down" type event (or null if none have occurred).
         * Set on pointerdown.
         * @type {module:ol/pointer/PointerEvent}
         * @private
         */
        this.down_ = null;

        var element = this.map_.getViewport();

        /**
         * @type {number}
         * @private
         */
        this.activePointers_ = 0;

        /**
         * @type {!Object.<number, boolean>}
         * @private
         */
        this.trackedTouches_ = {};

        /**
         * Event handler which generates pointer events for
         * the viewport element.
         *
         * @type {module:ol/pointer/PointerEventHandler}
         * @private
         */
        this.pointerEventHandler_ = new PointerEventHandler(element);

        /**
         * Event handler which generates pointer events for
         * the document (used when dragging).
         *
         * @type {module:ol/pointer/PointerEventHandler}
         * @private
         */
        this.documentPointerEventHandler_ = null;

        /**
         * @type {?module:ol/events~EventsKey}
         * @private
         */
        this.pointerdownListenerKey_ = listen(this.pointerEventHandler_,
          PointerEventType.POINTERDOWN,
          this.handlePointerDown_, this);

        /**
         * @type {?module:ol/events~EventsKey}
         * @private
         */
        this.relayedListenerKey_ = listen(this.pointerEventHandler_,
          PointerEventType.POINTERMOVE,
          this.relayEvent_, this);

      }

      if ( EventTarget$$1 ) MapBrowserEventHandler.__proto__ = EventTarget$$1;
      MapBrowserEventHandler.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      MapBrowserEventHandler.prototype.constructor = MapBrowserEventHandler;

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.emulateClick_ = function emulateClick_ (pointerEvent) {
        var newEvent = new MapBrowserPointerEvent(
          MapBrowserEventType.CLICK, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);
        if (this.clickTimeoutId_ !== 0) {
          // double-click
          clearTimeout(this.clickTimeoutId_);
          this.clickTimeoutId_ = 0;
          newEvent = new MapBrowserPointerEvent(
            MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
        } else {
          // click
          this.clickTimeoutId_ = setTimeout(function() {
            this.clickTimeoutId_ = 0;
            var newEvent = new MapBrowserPointerEvent(
              MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
            this.dispatchEvent(newEvent);
          }.bind(this), 250);
        }
      };

      /**
       * Keeps track on how many pointers are currently active.
       *
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.updateActivePointers_ = function updateActivePointers_ (pointerEvent) {
        var event = pointerEvent;

        if (event.type == MapBrowserEventType.POINTERUP ||
            event.type == MapBrowserEventType.POINTERCANCEL) {
          delete this.trackedTouches_[event.pointerId];
        } else if (event.type == MapBrowserEventType.POINTERDOWN) {
          this.trackedTouches_[event.pointerId] = true;
        }
        this.activePointers_ = Object.keys(this.trackedTouches_).length;
      };

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerUp_ = function handlePointerUp_ (pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserPointerEvent(
          MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);

        // We emulate click events on left mouse button click, touch contact, and pen
        // contact. isMouseActionButton returns true in these cases (evt.button is set
        // to 0).
        // See http://www.w3.org/TR/pointerevents/#button-states
        // We only fire click, singleclick, and doubleclick if nobody has called
        // event.stopPropagation() or event.preventDefault().
        if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
          this.emulateClick_(this.down_);
        }

        if (this.activePointers_ === 0) {
          this.dragListenerKeys_.forEach(unlistenByKey);
          this.dragListenerKeys_.length = 0;
          this.dragging_ = false;
          this.down_ = null;
          this.documentPointerEventHandler_.dispose();
          this.documentPointerEventHandler_ = null;
        }
      };

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} If the left mouse button was pressed.
       * @private
       */
      MapBrowserEventHandler.prototype.isMouseActionButton_ = function isMouseActionButton_ (pointerEvent) {
        return pointerEvent.button === 0;
      };

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerDown_ = function handlePointerDown_ (pointerEvent) {
        this.updateActivePointers_(pointerEvent);
        var newEvent = new MapBrowserPointerEvent(
          MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
        this.dispatchEvent(newEvent);

        this.down_ = pointerEvent;

        if (this.dragListenerKeys_.length === 0) {
          /* Set up a pointer event handler on the `document`,
           * which is required when the pointer is moved outside
           * the viewport when dragging.
           */
          this.documentPointerEventHandler_ =
              new PointerEventHandler(document);

          this.dragListenerKeys_.push(
            listen(this.documentPointerEventHandler_,
              MapBrowserEventType.POINTERMOVE,
              this.handlePointerMove_, this),
            listen(this.documentPointerEventHandler_,
              MapBrowserEventType.POINTERUP,
              this.handlePointerUp_, this),
            /* Note that the listener for `pointercancel is set up on
             * `pointerEventHandler_` and not `documentPointerEventHandler_` like
             * the `pointerup` and `pointermove` listeners.
             *
             * The reason for this is the following: `TouchSource.vacuumTouches_()`
             * issues `pointercancel` events, when there was no `touchend` for a
             * `touchstart`. Now, let's say a first `touchstart` is registered on
             * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
             * But `documentPointerEventHandler_` doesn't know about the first
             * `touchstart`. If there is no `touchend` for the `touchstart`, we can
             * only receive a `touchcancel` from `pointerEventHandler_`, because it is
             * only registered there.
             */
            listen(this.pointerEventHandler_,
              MapBrowserEventType.POINTERCANCEL,
              this.handlePointerUp_, this)
          );
        }
      };

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerMove_ = function handlePointerMove_ (pointerEvent) {
        // Between pointerdown and pointerup, pointermove events are triggered.
        // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
        // moved a significant distance.
        if (this.isMoving_(pointerEvent)) {
          this.dragging_ = true;
          var newEvent = new MapBrowserPointerEvent(
            MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent,
            this.dragging_);
          this.dispatchEvent(newEvent);
        }

        // Some native android browser triggers mousemove events during small period
        // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
        // https://code.google.com/p/android/issues/detail?id=19827
        // ex: Galaxy Tab P3110 + Android 4.1.1
        pointerEvent.preventDefault();
      };

      /**
       * Wrap and relay a pointer event.  Note that this requires that the type
       * string for the MapBrowserPointerEvent matches the PointerEvent type.
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.relayEvent_ = function relayEvent_ (pointerEvent) {
        var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
        this.dispatchEvent(new MapBrowserPointerEvent(
          pointerEvent.type, this.map_, pointerEvent, dragging));
      };

      /**
       * @param {module:ol/pointer/PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} Is moving.
       * @private
       */
      MapBrowserEventHandler.prototype.isMoving_ = function isMoving_ (pointerEvent) {
        return this.dragging_ ||
            Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ ||
            Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
      };

      /**
       * @inheritDoc
       */
      MapBrowserEventHandler.prototype.disposeInternal = function disposeInternal () {
        if (this.relayedListenerKey_) {
          unlistenByKey(this.relayedListenerKey_);
          this.relayedListenerKey_ = null;
        }
        if (this.pointerdownListenerKey_) {
          unlistenByKey(this.pointerdownListenerKey_);
          this.pointerdownListenerKey_ = null;
        }

        this.dragListenerKeys_.forEach(unlistenByKey);
        this.dragListenerKeys_.length = 0;

        if (this.documentPointerEventHandler_) {
          this.documentPointerEventHandler_.dispose();
          this.documentPointerEventHandler_ = null;
        }
        if (this.pointerEventHandler_) {
          this.pointerEventHandler_.dispose();
          this.pointerEventHandler_ = null;
        }
        EventTarget$$1.prototype.disposeInternal.call(this);
      };

      return MapBrowserEventHandler;
    }(EventTarget));

    /**
     * @module ol/MapEventType
     */

    /**
     * @enum {string}
     */
    var MapEventType = {

      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',

      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: 'movestart',

      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: 'moveend'

    };

    /**
     * @module ol/MapProperty
     */

    /**
     * @enum {string}
     */
    var MapProperty = {
      LAYERGROUP: 'layergroup',
      SIZE: 'size',
      TARGET: 'target',
      VIEW: 'view'
    };

    /**
     * @module ol/TileState
     */

    /**
     * @enum {number}
     */
    var TileState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4,
      ABORT: 5
    };

    /**
     * @module ol/structs/PriorityQueue
     */


    /**
     * @type {number}
     */
    var DROP = Infinity;


    /**
     * @classdesc
     * Priority queue.
     *
     * The implementation is inspired from the Closure Library's Heap class and
     * Python's heapq module.
     *
     * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
     * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
     *
     * @template T
     */
    var PriorityQueue = function PriorityQueue(priorityFunction, keyFunction) {

      /**
       * @type {function(T): number}
       * @private
       */
      this.priorityFunction_ = priorityFunction;

      /**
       * @type {function(T): string}
       * @private
       */
      this.keyFunction_ = keyFunction;

      /**
       * @type {Array.<T>}
       * @private
       */
      this.elements_ = [];

      /**
       * @type {Array.<number>}
       * @private
       */
      this.priorities_ = [];

      /**
       * @type {!Object.<string, boolean>}
       * @private
       */
      this.queuedElements_ = {};

    };

    /**
     * FIXME empty description for jsdoc
     */
    PriorityQueue.prototype.clear = function clear$1 () {
      this.elements_.length = 0;
      this.priorities_.length = 0;
      clear(this.queuedElements_);
    };


    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    PriorityQueue.prototype.dequeue = function dequeue () {
      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[0];
      if (elements.length == 1) {
        elements.length = 0;
        priorities.length = 0;
      } else {
        elements[0] = elements.pop();
        priorities[0] = priorities.pop();
        this.siftUp_(0);
      }
      var elementKey = this.keyFunction_(element);
      delete this.queuedElements_[elementKey];
      return element;
    };


    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    PriorityQueue.prototype.enqueue = function enqueue (element) {
      assert(!(this.keyFunction_(element) in this.queuedElements_),
        31); // Tried to enqueue an `element` that was already added to the queue
      var priority = this.priorityFunction_(element);
      if (priority != DROP) {
        this.elements_.push(element);
        this.priorities_.push(priority);
        this.queuedElements_[this.keyFunction_(element)] = true;
        this.siftDown_(0, this.elements_.length - 1);
        return true;
      }
      return false;
    };


    /**
     * @return {number} Count.
     */
    PriorityQueue.prototype.getCount = function getCount () {
      return this.elements_.length;
    };


    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    PriorityQueue.prototype.getLeftChildIndex_ = function getLeftChildIndex_ (index) {
      return index * 2 + 1;
    };


    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    PriorityQueue.prototype.getRightChildIndex_ = function getRightChildIndex_ (index) {
      return index * 2 + 2;
    };


    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    PriorityQueue.prototype.getParentIndex_ = function getParentIndex_ (index) {
      return (index - 1) >> 1;
    };


    /**
     * Make this a heap. O(N).
     * @private
     */
    PriorityQueue.prototype.heapify_ = function heapify_ () {
        var this$1 = this;

      var i;
      for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
        this$1.siftUp_(i);
      }
    };


    /**
     * @return {boolean} Is empty.
     */
    PriorityQueue.prototype.isEmpty = function isEmpty$$1 () {
      return this.elements_.length === 0;
    };


    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    PriorityQueue.prototype.isKeyQueued = function isKeyQueued (key) {
      return key in this.queuedElements_;
    };


    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    PriorityQueue.prototype.isQueued = function isQueued (element) {
      return this.isKeyQueued(this.keyFunction_(element));
    };


    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    PriorityQueue.prototype.siftUp_ = function siftUp_ (index) {
        var this$1 = this;

      var elements = this.elements_;
      var priorities = this.priorities_;
      var count = elements.length;
      var element = elements[index];
      var priority = priorities[index];
      var startIndex = index;

      while (index < (count >> 1)) {
        var lIndex = this$1.getLeftChildIndex_(index);
        var rIndex = this$1.getRightChildIndex_(index);

        var smallerChildIndex = rIndex < count &&
            priorities[rIndex] < priorities[lIndex] ?
          rIndex : lIndex;

        elements[index] = elements[smallerChildIndex];
        priorities[index] = priorities[smallerChildIndex];
        index = smallerChildIndex;
      }

      elements[index] = element;
      priorities[index] = priority;
      this.siftDown_(startIndex, index);
    };


    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    PriorityQueue.prototype.siftDown_ = function siftDown_ (startIndex, index) {
        var this$1 = this;

      var elements = this.elements_;
      var priorities = this.priorities_;
      var element = elements[index];
      var priority = priorities[index];

      while (index > startIndex) {
        var parentIndex = this$1.getParentIndex_(index);
        if (priorities[parentIndex] > priority) {
          elements[index] = elements[parentIndex];
          priorities[index] = priorities[parentIndex];
          index = parentIndex;
        } else {
          break;
        }
      }
      elements[index] = element;
      priorities[index] = priority;
    };


    /**
     * FIXME empty description for jsdoc
     */
    PriorityQueue.prototype.reprioritize = function reprioritize () {
        var this$1 = this;

      var priorityFunction = this.priorityFunction_;
      var elements = this.elements_;
      var priorities = this.priorities_;
      var index = 0;
      var n = elements.length;
      var element, i, priority;
      for (i = 0; i < n; ++i) {
        element = elements[i];
        priority = priorityFunction(element);
        if (priority == DROP) {
          delete this$1.queuedElements_[this$1.keyFunction_(element)];
        } else {
          priorities[index] = priority;
          elements[index++] = element;
        }
      }
      elements.length = index;
      priorities.length = index;
      this.heapify_();
    };

    /**
     * @module ol/TileQueue
     */


    /**
     * @typedef {function(module:ol/Tile, string, module:ol/coordinate~Coordinate, number): number} PriorityFunction
     */


    var TileQueue = (function (PriorityQueue$$1) {
      function TileQueue(tilePriorityFunction, tileChangeCallback) {

        PriorityQueue$$1.call(
          /**
           * @param {Array} element Element.
           * @return {number} Priority.
           */
          this, function(element) {
            return tilePriorityFunction.apply(null, element);
          },
          /**
           * @param {Array} element Element.
           * @return {string} Key.
           */
          function(element) {
            return (/** @type {module:ol/Tile} */ (element[0]).getKey());
          });

        /**
         * @private
         * @type {function(): ?}
         */
        this.tileChangeCallback_ = tileChangeCallback;

        /**
         * @private
         * @type {number}
         */
        this.tilesLoading_ = 0;

        /**
         * @private
         * @type {!Object.<string,boolean>}
         */
        this.tilesLoadingKeys_ = {};

      }

      if ( PriorityQueue$$1 ) TileQueue.__proto__ = PriorityQueue$$1;
      TileQueue.prototype = Object.create( PriorityQueue$$1 && PriorityQueue$$1.prototype );
      TileQueue.prototype.constructor = TileQueue;

      /**
       * @inheritDoc
       */
      TileQueue.prototype.enqueue = function enqueue (element) {
        var added = PriorityQueue$$1.prototype.enqueue.call(this, element);
        if (added) {
          var tile = element[0];
          listen(tile, EventType.CHANGE, this.handleTileChange, this);
        }
        return added;
      };

      /**
       * @return {number} Number of tiles loading.
       */
      TileQueue.prototype.getTilesLoading = function getTilesLoading () {
        return this.tilesLoading_;
      };

      /**
       * @param {module:ol/events/Event} event Event.
       * @protected
       */
      TileQueue.prototype.handleTileChange = function handleTileChange (event) {
        var tile = /** @type {module:ol/Tile} */ (event.target);
        var state = tile.getState();
        if (state === TileState.LOADED || state === TileState.ERROR ||
            state === TileState.EMPTY || state === TileState.ABORT) {
          unlisten(tile, EventType.CHANGE, this.handleTileChange, this);
          var tileKey = tile.getKey();
          if (tileKey in this.tilesLoadingKeys_) {
            delete this.tilesLoadingKeys_[tileKey];
            --this.tilesLoading_;
          }
          this.tileChangeCallback_();
        }
      };

      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */
      TileQueue.prototype.loadMoreTiles = function loadMoreTiles (maxTotalLoading, maxNewLoads) {
        var this$1 = this;

        var newLoads = 0;
        var abortedTiles = false;
        var state, tile, tileKey;
        while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads &&
               this.getCount() > 0) {
          tile = /** @type {module:ol/Tile} */ (this$1.dequeue()[0]);
          tileKey = tile.getKey();
          state = tile.getState();
          if (state === TileState.ABORT) {
            abortedTiles = true;
          } else if (state === TileState.IDLE && !(tileKey in this$1.tilesLoadingKeys_)) {
            this$1.tilesLoadingKeys_[tileKey] = true;
            ++this$1.tilesLoading_;
            ++newLoads;
            tile.load();
          }
        }
        if (newLoads === 0 && abortedTiles) {
          // Do not stop the render loop when all wanted tiles were aborted due to
          // a small, saturated tile cache.
          this.tileChangeCallback_();
        }
      };

      return TileQueue;
    }(PriorityQueue));

    /**
     * @module ol/tilegrid/common
     */

    /**
     * Default maximum zoom for default tile grids.
     * @type {number}
     */
    var DEFAULT_MAX_ZOOM = 42;

    /**
     * Default tile size.
     * @type {number}
     */
    var DEFAULT_TILE_SIZE = 256;

    /**
     * @module ol/centerconstraint
     */


    /**
     * @typedef {function((module:ol/coordinate~Coordinate|undefined)): (module:ol/coordinate~Coordinate|undefined)} Type
     */


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/centerconstraint~Type} The constraint.
     */
    function createExtent(extent) {
      return (
        /**
         * @param {module:ol/coordinate~Coordinate=} center Center.
         * @return {module:ol/coordinate~Coordinate|undefined} Center.
         */
        function(center) {
          if (center) {
            return [
              clamp(center[0], extent[0], extent[2]),
              clamp(center[1], extent[1], extent[3])
            ];
          } else {
            return undefined;
          }
        }
      );
    }


    /**
     * @param {module:ol/coordinate~Coordinate=} center Center.
     * @return {module:ol/coordinate~Coordinate|undefined} Center.
     */
    function none(center) {
      return center;
    }

    /**
     * @module ol/resolutionconstraint
     */


    /**
     * @typedef {function((number|undefined), number, number): (number|undefined)} Type
     */


    /**
     * @param {Array.<number>} resolutions Resolutions.
     * @return {module:ol/resolutionconstraint~Type} Zoom function.
     */
    function createSnapToResolutions(resolutions) {
      return (
        /**
         * @param {number|undefined} resolution Resolution.
         * @param {number} delta Delta.
         * @param {number} direction Direction.
         * @return {number|undefined} Resolution.
         */
        function(resolution, delta, direction) {
          if (resolution !== undefined) {
            var z = linearFindNearest(resolutions, resolution, direction);
            z = clamp(z + delta, 0, resolutions.length - 1);
            var index = Math.floor(z);
            if (z != index && index < resolutions.length - 1) {
              var power = resolutions[index] / resolutions[index + 1];
              return resolutions[index] / Math.pow(power, z - index);
            } else {
              return resolutions[index];
            }
          } else {
            return undefined;
          }
        }
      );
    }


    /**
     * @param {number} power Power.
     * @param {number} maxResolution Maximum resolution.
     * @param {number=} opt_maxLevel Maximum level.
     * @return {module:ol/resolutionconstraint~Type} Zoom function.
     */
    function createSnapToPower(power, maxResolution, opt_maxLevel) {
      return (
        /**
         * @param {number|undefined} resolution Resolution.
         * @param {number} delta Delta.
         * @param {number} direction Direction.
         * @return {number|undefined} Resolution.
         */
        function(resolution, delta, direction) {
          if (resolution !== undefined) {
            var offset = -direction / 2 + 0.5;
            var oldLevel = Math.floor(
              Math.log(maxResolution / resolution) / Math.log(power) + offset);
            var newLevel = Math.max(oldLevel + delta, 0);
            if (opt_maxLevel !== undefined) {
              newLevel = Math.min(newLevel, opt_maxLevel);
            }
            return maxResolution / Math.pow(power, newLevel);
          } else {
            return undefined;
          }
        });
    }

    /**
     * @module ol/rotationconstraint
     */


    /**
     * @typedef {function((number|undefined), number): (number|undefined)} Type
     */


    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function disable(rotation, delta) {
      if (rotation !== undefined) {
        return 0;
      } else {
        return undefined;
      }
    }


    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function none$1(rotation, delta) {
      if (rotation !== undefined) {
        return rotation + delta;
      } else {
        return undefined;
      }
    }


    /**
     * @param {number} n N.
     * @return {module:ol/rotationconstraint~Type} Rotation constraint.
     */
    function createSnapToN(n) {
      var theta = 2 * Math.PI / n;
      return (
        /**
         * @param {number|undefined} rotation Rotation.
         * @param {number} delta Delta.
         * @return {number|undefined} Rotation.
         */
        function(rotation, delta) {
          if (rotation !== undefined) {
            rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
            return rotation;
          } else {
            return undefined;
          }
        });
    }


    /**
     * @param {number=} opt_tolerance Tolerance.
     * @return {module:ol/rotationconstraint~Type} Rotation constraint.
     */
    function createSnapToZero(opt_tolerance) {
      var tolerance = opt_tolerance || toRadians(5);
      return (
        /**
         * @param {number|undefined} rotation Rotation.
         * @param {number} delta Delta.
         * @return {number|undefined} Rotation.
         */
        function(rotation, delta) {
          if (rotation !== undefined) {
            if (Math.abs(rotation + delta) <= tolerance) {
              return 0;
            } else {
              return rotation + delta;
            }
          } else {
            return undefined;
          }
        });
    }

    /**
     * @module ol/ViewHint
     */

    /**
     * @enum {number}
     */
    var ViewHint = {
      ANIMATING: 0,
      INTERACTING: 1
    };

    /**
     * @module ol/ViewProperty
     */

    /**
     * @enum {string}
     */
    var ViewProperty = {
      CENTER: 'center',
      RESOLUTION: 'resolution',
      ROTATION: 'rotation'
    };

    /**
     * @module ol/string
     */


    /**
     * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
     * @param {string|number} v1 First version
     * @param {string|number} v2 Second version
     * @returns {number} Value
     */
    function compareVersions(v1, v2) {
      var s1 = ('' + v1).split('.');
      var s2 = ('' + v2).split('.');

      for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
        var n1 = parseInt(s1[i] || '0', 10);
        var n2 = parseInt(s2[i] || '0', 10);

        if (n1 > n2) {
          return 1;
        }
        if (n2 > n1) {
          return -1;
        }
      }

      return 0;
    }

    /**
     * @module ol/coordinate
     */


    /**
     * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
     * @typedef {Array.<number>} Coordinate
     * @api
     */


    /**
     * A function that takes a {@link module:ol/coordinate~Coordinate} and
     * transforms it into a `{string}`.
     *
     * @typedef {function((module:ol/coordinate~Coordinate|undefined)): string} CoordinateFormat
     * @api
     */


    /**
     * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
     * by the function.
     *
     * Example:
     *
     *     import {add} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     add(coord, [-2, 4]);
     *     // coord is now [5.85, 51.983333]
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {module:ol/coordinate~Coordinate} delta Delta.
     * @return {module:ol/coordinate~Coordinate} The input coordinate adjusted by
     * the given delta.
     * @api
     */
    function add(coordinate, delta) {
      coordinate[0] += delta[0];
      coordinate[1] += delta[1];
      return coordinate;
    }


    /**
     * Calculates the point closest to the passed coordinate on the passed circle.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
     * @param {module:ol/geom/Circle} circle The circle.
     * @return {module:ol/coordinate~Coordinate} Closest point on the circumference.
     */
    function closestOnCircle(coordinate, circle) {
      var r = circle.getRadius();
      var center = circle.getCenter();
      var x0 = center[0];
      var y0 = center[1];
      var x1 = coordinate[0];
      var y1 = coordinate[1];

      var dx = x1 - x0;
      var dy = y1 - y0;
      if (dx === 0 && dy === 0) {
        dx = 1;
      }
      var d = Math.sqrt(dx * dx + dy * dy);

      var x = x0 + r * dx / d;
      var y = y0 + r * dy / d;

      return [x, y];
    }


    /**
     * Calculates the point closest to the passed coordinate on the passed segment.
     * This is the foot of the perpendicular of the coordinate to the segment when
     * the foot is on the segment, or the closest segment coordinate when the foot
     * is outside the segment.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
     * @param {Array.<module:ol/coordinate~Coordinate>} segment The two coordinates
     * of the segment.
     * @return {module:ol/coordinate~Coordinate} The foot of the perpendicular of
     * the coordinate to the segment.
     */
    function closestOnSegment(coordinate, segment) {
      var x0 = coordinate[0];
      var y0 = coordinate[1];
      var start = segment[0];
      var end = segment[1];
      var x1 = start[0];
      var y1 = start[1];
      var x2 = end[0];
      var y2 = end[1];
      var dx = x2 - x1;
      var dy = y2 - y1;
      var along = (dx === 0 && dy === 0) ? 0 :
        ((dx * (x0 - x1)) + (dy * (y0 - y1))) / ((dx * dx + dy * dy) || 0);
      var x, y;
      if (along <= 0) {
        x = x1;
        y = y1;
      } else if (along >= 1) {
        x = x2;
        y = y2;
      } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
      }
      return [x, y];
    }


    /**
     * @param {module:ol/coordinate~Coordinate} coordinate1 First coordinate.
     * @param {module:ol/coordinate~Coordinate} coordinate2 Second coordinate.
     * @return {boolean} The two coordinates are equal.
     */
    function equals$1(coordinate1, coordinate2) {
      var equals = true;
      for (var i = coordinate1.length - 1; i >= 0; --i) {
        if (coordinate1[i] != coordinate2[i]) {
          equals = false;
          break;
        }
      }
      return equals;
    }


    /**
     * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
     * returned by the function.
     *
     * Example:
     *
     *     import {rotate} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     var rotateRadians = Math.PI / 2; // 90 degrees
     *     rotate(coord, rotateRadians);
     *     // coord is now [-47.983333, 7.85]
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} angle Angle in radian.
     * @return {module:ol/coordinate~Coordinate} Coordinate.
     * @api
     */
    function rotate(coordinate, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);
      var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
      var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
      coordinate[0] = x;
      coordinate[1] = y;
      return coordinate;
    }


    /**
     * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
     * by the function.
     *
     * Example:
     *
     *     import {scale as scaleCoordinate} from 'ol/coordinate';
     *
     *     var coord = [7.85, 47.983333];
     *     var scale = 1.2;
     *     scaleCoordinate(coord, scale);
     *     // coord is now [9.42, 57.5799996]
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} scale Scale factor.
     * @return {module:ol/coordinate~Coordinate} Coordinate.
     */
    function scale(coordinate, scale) {
      coordinate[0] *= scale;
      coordinate[1] *= scale;
      return coordinate;
    }


    /**
     * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.
     * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.
     * @return {number} Squared distance between coord1 and coord2.
     */
    function squaredDistance$1(coord1, coord2) {
      var dx = coord1[0] - coord2[0];
      var dy = coord1[1] - coord2[1];
      return dx * dx + dy * dy;
    }


    /**
     * @param {module:ol/coordinate~Coordinate} coord1 First coordinate.
     * @param {module:ol/coordinate~Coordinate} coord2 Second coordinate.
     * @return {number} Distance between coord1 and coord2.
     */
    function distance(coord1, coord2) {
      return Math.sqrt(squaredDistance$1(coord1, coord2));
    }


    /**
     * Calculate the squared distance from a coordinate to a line segment.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate of the point.
     * @param {Array.<module:ol/coordinate~Coordinate>} segment Line segment (2
     * coordinates).
     * @return {number} Squared distance from the point to the line segment.
     */
    function squaredDistanceToSegment(coordinate, segment) {
      return squaredDistance$1(coordinate,
        closestOnSegment(coordinate, segment));
    }

    /**
     * @module ol/easing
     */


    /**
     * Start slow and speed up.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function easeIn(t) {
      return Math.pow(t, 3);
    }


    /**
     * Start fast and slow down.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function easeOut(t) {
      return 1 - easeIn(1 - t);
    }


    /**
     * Start slow, speed up, and then slow down again.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function inAndOut(t) {
      return 3 * t * t - 2 * t * t * t;
    }


    /**
     * Maintain a constant speed over time.
     * @param {number} t Input between 0 and 1.
     * @return {number} Output between 0 and 1.
     * @api
     */
    function linear(t) {
      return t;
    }

    /**
     * @module ol/extent/Corner
     */

    /**
     * Extent corner.
     * @enum {string}
     */
    var Corner = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right'
    };

    /**
     * @module ol/extent/Relationship
     */

    /**
     * Relationship to an extent.
     * @enum {number}
     */
    var Relationship = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };

    /**
     * @module ol/extent
     */


    /**
     * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
     * @typedef {Array.<number>} Extent
     * @api
     */

    /**
     * Build an extent that includes all given coordinates.
     *
     * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
     * @return {module:ol/extent~Extent} Bounding extent.
     * @api
     */
    function boundingExtent(coordinates) {
      var extent = createEmpty();
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
      }
      return extent;
    }


    /**
     * @param {Array.<number>} xs Xs.
     * @param {Array.<number>} ys Ys.
     * @param {module:ol/extent~Extent=} opt_extent Destination extent.
     * @private
     * @return {module:ol/extent~Extent} Extent.
     */
    function _boundingExtentXYs(xs, ys, opt_extent) {
      var minX = Math.min.apply(null, xs);
      var minY = Math.min.apply(null, ys);
      var maxX = Math.max.apply(null, xs);
      var maxY = Math.max.apply(null, ys);
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
    }


    /**
     * Return extent increased by the provided value.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} value The amount by which the extent should be buffered.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    function buffer(extent, value, opt_extent) {
      if (opt_extent) {
        opt_extent[0] = extent[0] - value;
        opt_extent[1] = extent[1] - value;
        opt_extent[2] = extent[2] + value;
        opt_extent[3] = extent[3] + value;
        return opt_extent;
      } else {
        return [
          extent[0] - value,
          extent[1] - value,
          extent[2] + value,
          extent[3] + value
        ];
      }
    }


    /**
     * Creates a clone of an extent.
     *
     * @param {module:ol/extent~Extent} extent Extent to clone.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} The clone.
     */
    function clone(extent, opt_extent) {
      if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
      } else {
        return extent.slice();
      }
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {number} Closest squared distance.
     */
    function closestSquaredDistanceXY(extent, x, y) {
      var dx, dy;
      if (x < extent[0]) {
        dx = extent[0] - x;
      } else if (extent[2] < x) {
        dx = x - extent[2];
      } else {
        dx = 0;
      }
      if (y < extent[1]) {
        dy = extent[1] - y;
      } else if (extent[3] < y) {
        dy = y - extent[3];
      } else {
        dy = 0;
      }
      return dx * dx + dy * dy;
    }


    /**
     * Check if the passed coordinate is contained or on the edge of the extent.
     *
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @return {boolean} The coordinate is contained in the extent.
     * @api
     */
    function containsCoordinate(extent, coordinate) {
      return containsXY(extent, coordinate[0], coordinate[1]);
    }


    /**
     * Check if one extent contains another.
     *
     * An extent is deemed contained if it lies completely within the other extent,
     * including if they share one or more edges.
     *
     * @param {module:ol/extent~Extent} extent1 Extent 1.
     * @param {module:ol/extent~Extent} extent2 Extent 2.
     * @return {boolean} The second extent is contained by or on the edge of the
     *     first.
     * @api
     */
    function containsExtent(extent1, extent2) {
      return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] &&
          extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
    }


    /**
     * Check if the passed coordinate is contained or on the edge of the extent.
     *
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} x X coordinate.
     * @param {number} y Y coordinate.
     * @return {boolean} The x, y values are contained in the extent.
     * @api
     */
    function containsXY(extent, x, y) {
      return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
    }


    /**
     * Get the relationship between a coordinate and extent.
     * @param {module:ol/extent~Extent} extent The extent.
     * @param {module:ol/coordinate~Coordinate} coordinate The coordinate.
     * @return {module:ol/extent/Relationship} The relationship (bitwise compare with
     *     module:ol/extent/Relationship~Relationship).
     */
    function coordinateRelationship(extent, coordinate) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var x = coordinate[0];
      var y = coordinate[1];
      var relationship = Relationship.UNKNOWN;
      if (x < minX) {
        relationship = relationship | Relationship.LEFT;
      } else if (x > maxX) {
        relationship = relationship | Relationship.RIGHT;
      }
      if (y < minY) {
        relationship = relationship | Relationship.BELOW;
      } else if (y > maxY) {
        relationship = relationship | Relationship.ABOVE;
      }
      if (relationship === Relationship.UNKNOWN) {
        relationship = Relationship.INTERSECTING;
      }
      return relationship;
    }


    /**
     * Create an empty extent.
     * @return {module:ol/extent~Extent} Empty extent.
     * @api
     */
    function createEmpty() {
      return [Infinity, Infinity, -Infinity, -Infinity];
    }


    /**
     * Create a new extent or update the provided extent.
     * @param {number} minX Minimum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxX Maximum X.
     * @param {number} maxY Maximum Y.
     * @param {module:ol/extent~Extent=} opt_extent Destination extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
      if (opt_extent) {
        opt_extent[0] = minX;
        opt_extent[1] = minY;
        opt_extent[2] = maxX;
        opt_extent[3] = maxY;
        return opt_extent;
      } else {
        return [minX, minY, maxX, maxY];
      }
    }


    /**
     * Create a new empty extent or make the provided one empty.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function createOrUpdateEmpty(opt_extent) {
      return createOrUpdate(
        Infinity, Infinity, -Infinity, -Infinity, opt_extent);
    }


    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function createOrUpdateFromCoordinate(coordinate, opt_extent) {
      var x = coordinate[0];
      var y = coordinate[1];
      return createOrUpdate(x, y, x, y, opt_extent);
    }


    /**
     * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function createOrUpdateFromCoordinates(coordinates, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendCoordinates(extent, coordinates);
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
    }


    /**
     * Determine if two extents are equivalent.
     * @param {module:ol/extent~Extent} extent1 Extent 1.
     * @param {module:ol/extent~Extent} extent2 Extent 2.
     * @return {boolean} The two extents are equivalent.
     * @api
     */
    function equals$2(extent1, extent2) {
      return extent1[0] == extent2[0] && extent1[2] == extent2[2] &&
          extent1[1] == extent2[1] && extent1[3] == extent2[3];
    }


    /**
     * Modify an extent to include another extent.
     * @param {module:ol/extent~Extent} extent1 The extent to be modified.
     * @param {module:ol/extent~Extent} extent2 The extent that will be included in the first.
     * @return {module:ol/extent~Extent} A reference to the first (extended) extent.
     * @api
     */
    function extend$1(extent1, extent2) {
      if (extent2[0] < extent1[0]) {
        extent1[0] = extent2[0];
      }
      if (extent2[2] > extent1[2]) {
        extent1[2] = extent2[2];
      }
      if (extent2[1] < extent1[1]) {
        extent1[1] = extent2[1];
      }
      if (extent2[3] > extent1[3]) {
        extent1[3] = extent2[3];
      }
      return extent1;
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     */
    function extendCoordinate(extent, coordinate) {
      if (coordinate[0] < extent[0]) {
        extent[0] = coordinate[0];
      }
      if (coordinate[0] > extent[2]) {
        extent[2] = coordinate[0];
      }
      if (coordinate[1] < extent[1]) {
        extent[1] = coordinate[1];
      }
      if (coordinate[1] > extent[3]) {
        extent[3] = coordinate[1];
      }
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
     * @return {module:ol/extent~Extent} Extent.
     */
    function extendCoordinates(extent, coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        extendCoordinate(extent, coordinates[i]);
      }
      return extent;
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {module:ol/extent~Extent} Extent.
     */
    function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
      for (; offset < end; offset += stride) {
        extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
      }
      return extent;
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} x X.
     * @param {number} y Y.
     */
    function extendXY(extent, x, y) {
      extent[0] = Math.min(extent[0], x);
      extent[1] = Math.min(extent[1], y);
      extent[2] = Math.max(extent[2], x);
      extent[3] = Math.max(extent[3], y);
    }


    /**
     * This function calls `callback` for each corner of the extent. If the
     * callback returns a truthy value the function returns that value
     * immediately. Otherwise the function returns `false`.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {function(this:T, module:ol/coordinate~Coordinate): S} callback Callback.
     * @param {T=} opt_this Value to use as `this` when executing `callback`.
     * @return {S|boolean} Value.
     * @template S, T
     */
    function forEachCorner(extent, callback, opt_this) {
      var val;
      val = callback.call(opt_this, getBottomLeft(extent));
      if (val) {
        return val;
      }
      val = callback.call(opt_this, getBottomRight(extent));
      if (val) {
        return val;
      }
      val = callback.call(opt_this, getTopRight(extent));
      if (val) {
        return val;
      }
      val = callback.call(opt_this, getTopLeft(extent));
      if (val) {
        return val;
      }
      return false;
    }


    /**
     * Get the size of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {number} Area.
     * @api
     */
    function getArea(extent) {
      var area = 0;
      if (!isEmpty$1(extent)) {
        area = getWidth(extent) * getHeight(extent);
      }
      return area;
    }


    /**
     * Get the bottom left coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/coordinate~Coordinate} Bottom left coordinate.
     * @api
     */
    function getBottomLeft(extent) {
      return [extent[0], extent[1]];
    }


    /**
     * Get the bottom right coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/coordinate~Coordinate} Bottom right coordinate.
     * @api
     */
    function getBottomRight(extent) {
      return [extent[2], extent[1]];
    }


    /**
     * Get the center coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/coordinate~Coordinate} Center.
     * @api
     */
    function getCenter(extent) {
      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
    }


    /**
     * Get a corner coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {module:ol/extent/Corner} corner Corner.
     * @return {module:ol/coordinate~Coordinate} Corner coordinate.
     */
    function getCorner(extent, corner) {
      var coordinate;
      if (corner === Corner.BOTTOM_LEFT) {
        coordinate = getBottomLeft(extent);
      } else if (corner === Corner.BOTTOM_RIGHT) {
        coordinate = getBottomRight(extent);
      } else if (corner === Corner.TOP_LEFT) {
        coordinate = getTopLeft(extent);
      } else if (corner === Corner.TOP_RIGHT) {
        coordinate = getTopRight(extent);
      } else {
        assert(false, 13); // Invalid corner
      }
      return (
        /** @type {!module:ol/coordinate~Coordinate} */ (coordinate)
      );
    }


    /**
     * @param {module:ol/coordinate~Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {module:ol/size~Size} size Size.
     * @param {module:ol/extent~Extent=} opt_extent Destination extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
      var dx = resolution * size[0] / 2;
      var dy = resolution * size[1] / 2;
      var cosRotation = Math.cos(rotation);
      var sinRotation = Math.sin(rotation);
      var xCos = dx * cosRotation;
      var xSin = dx * sinRotation;
      var yCos = dy * cosRotation;
      var ySin = dy * sinRotation;
      var x = center[0];
      var y = center[1];
      var x0 = x - xCos + ySin;
      var x1 = x - xCos - ySin;
      var x2 = x + xCos - ySin;
      var x3 = x + xCos + ySin;
      var y0 = y - xSin - yCos;
      var y1 = y - xSin + yCos;
      var y2 = y + xSin + yCos;
      var y3 = y + xSin - yCos;
      return createOrUpdate(
        Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3),
        Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3),
        opt_extent);
    }


    /**
     * Get the height of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {number} Height.
     * @api
     */
    function getHeight(extent) {
      return extent[3] - extent[1];
    }


    /**
     * Get the intersection of two extents.
     * @param {module:ol/extent~Extent} extent1 Extent 1.
     * @param {module:ol/extent~Extent} extent2 Extent 2.
     * @param {module:ol/extent~Extent=} opt_extent Optional extent to populate with intersection.
     * @return {module:ol/extent~Extent} Intersecting extent.
     * @api
     */
    function getIntersection(extent1, extent2, opt_extent) {
      var intersection = opt_extent ? opt_extent : createEmpty();
      if (intersects(extent1, extent2)) {
        if (extent1[0] > extent2[0]) {
          intersection[0] = extent1[0];
        } else {
          intersection[0] = extent2[0];
        }
        if (extent1[1] > extent2[1]) {
          intersection[1] = extent1[1];
        } else {
          intersection[1] = extent2[1];
        }
        if (extent1[2] < extent2[2]) {
          intersection[2] = extent1[2];
        } else {
          intersection[2] = extent2[2];
        }
        if (extent1[3] < extent2[3]) {
          intersection[3] = extent1[3];
        } else {
          intersection[3] = extent2[3];
        }
      } else {
        createOrUpdateEmpty(intersection);
      }
      return intersection;
    }


    /**
     * Get the top left coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/coordinate~Coordinate} Top left coordinate.
     * @api
     */
    function getTopLeft(extent) {
      return [extent[0], extent[3]];
    }


    /**
     * Get the top right coordinate of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {module:ol/coordinate~Coordinate} Top right coordinate.
     * @api
     */
    function getTopRight(extent) {
      return [extent[2], extent[3]];
    }


    /**
     * Get the width of an extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {number} Width.
     * @api
     */
    function getWidth(extent) {
      return extent[2] - extent[0];
    }


    /**
     * Determine if one extent intersects another.
     * @param {module:ol/extent~Extent} extent1 Extent 1.
     * @param {module:ol/extent~Extent} extent2 Extent.
     * @return {boolean} The two extents intersect.
     * @api
     */
    function intersects(extent1, extent2) {
      return extent1[0] <= extent2[2] &&
          extent1[2] >= extent2[0] &&
          extent1[1] <= extent2[3] &&
          extent1[3] >= extent2[1];
    }


    /**
     * Determine if an extent is empty.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} Is empty.
     * @api
     */
    function isEmpty$1(extent) {
      return extent[2] < extent[0] || extent[3] < extent[1];
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    function returnOrUpdate(extent, opt_extent) {
      if (opt_extent) {
        opt_extent[0] = extent[0];
        opt_extent[1] = extent[1];
        opt_extent[2] = extent[2];
        opt_extent[3] = extent[3];
        return opt_extent;
      } else {
        return extent;
      }
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} value Value.
     */
    function scaleFromCenter(extent, value) {
      var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
      var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
      extent[0] -= deltaX;
      extent[2] += deltaX;
      extent[1] -= deltaY;
      extent[3] += deltaY;
    }


    /**
     * Determine if the segment between two coordinates intersects (crosses,
     * touches, or is contained by) the provided extent.
     * @param {module:ol/extent~Extent} extent The extent.
     * @param {module:ol/coordinate~Coordinate} start Segment start coordinate.
     * @param {module:ol/coordinate~Coordinate} end Segment end coordinate.
     * @return {boolean} The segment intersects the extent.
     */
    function intersectsSegment(extent, start, end) {
      var intersects = false;
      var startRel = coordinateRelationship(extent, start);
      var endRel = coordinateRelationship(extent, end);
      if (startRel === Relationship.INTERSECTING ||
          endRel === Relationship.INTERSECTING) {
        intersects = true;
      } else {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var startX = start[0];
        var startY = start[1];
        var endX = end[0];
        var endY = end[1];
        var slope = (endY - startY) / (endX - startX);
        var x, y;
        if (!!(endRel & Relationship.ABOVE) &&
            !(startRel & Relationship.ABOVE)) {
          // potentially intersects top
          x = endX - ((endY - maxY) / slope);
          intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & Relationship.RIGHT) &&
            !(startRel & Relationship.RIGHT)) {
          // potentially intersects right
          y = endY - ((endX - maxX) * slope);
          intersects = y >= minY && y <= maxY;
        }
        if (!intersects && !!(endRel & Relationship.BELOW) &&
            !(startRel & Relationship.BELOW)) {
          // potentially intersects bottom
          x = endX - ((endY - minY) / slope);
          intersects = x >= minX && x <= maxX;
        }
        if (!intersects && !!(endRel & Relationship.LEFT) &&
            !(startRel & Relationship.LEFT)) {
          // potentially intersects left
          y = endY - ((endX - minX) * slope);
          intersects = y >= minY && y <= maxY;
        }

      }
      return intersects;
    }


    /**
     * Apply a transform function to the extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {module:ol/proj~TransformFunction} transformFn Transform function.
     * Called with `[minX, minY, maxX, maxY]` extent coordinates.
     * @param {module:ol/extent~Extent=} opt_extent Destination extent.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    function applyTransform(extent, transformFn, opt_extent) {
      var coordinates = [
        extent[0], extent[1],
        extent[0], extent[3],
        extent[2], extent[1],
        extent[2], extent[3]
      ];
      transformFn(coordinates, coordinates, 2);
      var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
      var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
      return _boundingExtentXYs(xs, ys, opt_extent);
    }

    /**
     * @module ol/geom/GeometryType
     */

    /**
     * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
     * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
     * `'GeometryCollection'`, `'Circle'`.
     * @enum {string}
     */
    var GeometryType = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle'
    };

    /**
     * @module ol/geom/GeometryLayout
     */

    /**
     * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
     * or measure ('M') coordinate is available. Supported values are `'XY'`,
     * `'XYZ'`, `'XYM'`, `'XYZM'`.
     * @enum {string}
     */
    var GeometryLayout = {
      XY: 'XY',
      XYZ: 'XYZ',
      XYM: 'XYM',
      XYZM: 'XYZM'
    };

    /**
     * @module ol/geom/flat/transform
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {module:ol/transform~Transform} transform Transform.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Transformed coordinates.
     */
    function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
        var x = flatCoordinates[j];
        var y = flatCoordinates[j + 1];
        dest[i++] = transform[0] * x + transform[2] * y + transform[4];
        dest[i++] = transform[1] * x + transform[3] * y + transform[5];
      }
      if (opt_dest && dest.length != i) {
        dest.length = i;
      }
      return dest;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} angle Angle.
     * @param {Array.<number>} anchor Rotation anchor point.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Transformed coordinates.
     */
    function rotate$1(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + deltaX * cos - deltaY * sin;
        dest[i++] = anchorY + deltaX * sin + deltaY * cos;
        for (var k = j + 2; k < j + stride; ++k) {
          dest[i++] = flatCoordinates[k];
        }
      }
      if (opt_dest && dest.length != i) {
        dest.length = i;
      }
      return dest;
    }


    /**
     * Scale the coordinates.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} sx Scale factor in the x-direction.
     * @param {number} sy Scale factor in the y-direction.
     * @param {Array.<number>} anchor Scale anchor point.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Transformed coordinates.
     */
    function scale$1(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
        var deltaX = flatCoordinates[j] - anchorX;
        var deltaY = flatCoordinates[j + 1] - anchorY;
        dest[i++] = anchorX + sx * deltaX;
        dest[i++] = anchorY + sy * deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
          dest[i++] = flatCoordinates[k];
        }
      }
      if (opt_dest && dest.length != i) {
        dest.length = i;
      }
      return dest;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Transformed coordinates.
     */
    function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
        dest[i++] = flatCoordinates[j] + deltaX;
        dest[i++] = flatCoordinates[j + 1] + deltaY;
        for (var k = j + 2; k < j + stride; ++k) {
          dest[i++] = flatCoordinates[k];
        }
      }
      if (opt_dest && dest.length != i) {
        dest.length = i;
      }
      return dest;
    }

    /**
     * @license
     * Latitude/longitude spherical geodesy formulae taken from
     * http://www.movable-type.co.uk/scripts/latlong.html
     * Licensed under CC-BY-3.0.
     */


    /**
     * Object literal with options for the {@link getLength} or {@link getArea}
     * functions.
     * @typedef {Object} SphereMetricOptions
     * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857']
     * Projection of the  geometry.  By default, the geometry is assumed to be in
     * Web Mercator.
     * @property {number} [radius=6371008.8] Sphere radius.  By default, the radius of the
     * earth is used (Clarke 1866 Authalic Sphere).
     */


    /**
     * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
     * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
     * @type {number}
     */
    var DEFAULT_RADIUS = 6371008.8;


    /**
     * Get the great circle distance (in meters) between two geographic coordinates.
     * @param {Array} c1 Starting coordinate.
     * @param {Array} c2 Ending coordinate.
     * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
     *     mean radius using the WGS84 ellipsoid.
     * @return {number} The great circle distance between the points (in meters).
     * @api
     */
    function getDistance(c1, c2, opt_radius) {
      var radius = opt_radius || DEFAULT_RADIUS;
      var lat1 = toRadians(c1[1]);
      var lat2 = toRadians(c2[1]);
      var deltaLatBy2 = (lat2 - lat1) / 2;
      var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
          Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) *
          Math.cos(lat1) * Math.cos(lat2);
      return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    /**
     * @module ol/proj/Units
     */

    /**
     * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
     * `'us-ft'`.
     * @enum {string}
     */
    var Units = {
      DEGREES: 'degrees',
      FEET: 'ft',
      METERS: 'm',
      PIXELS: 'pixels',
      TILE_PIXELS: 'tile-pixels',
      USFEET: 'us-ft'
    };


    /**
     * Meters per unit lookup table.
     * @const
     * @type {Object.<module:ol/proj/Units, number>}
     * @api
     */
    var METERS_PER_UNIT = {};
    // use the radius of the Normal sphere
    METERS_PER_UNIT[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
    METERS_PER_UNIT[Units.FEET] = 0.3048;
    METERS_PER_UNIT[Units.METERS] = 1;
    METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

    /**
     * @module ol/proj/Projection
     */


    /**
     * @typedef {Object} Options
     * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
     * @property {module:ol/proj/Units|string} [units] Units. Required unless a
     * proj4 projection is defined for `code`.
     * @property {module:ol/extent~Extent} [extent] The validity extent for the SRS.
     * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
     * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
     * @property {number} [metersPerUnit] The meters per unit for the SRS.
     * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
     * lookup table.
     * @property {module:ol/extent~Extent} [worldExtent] The world extent for the SRS.
     * @property {function(number, module:ol/coordinate~Coordinate):number} [getPointResolution]
     * Function to determine resolution at a point. The function is called with a
     * `{number}` view resolution and an `{module:ol/coordinate~Coordinate}` as arguments, and returns
     * the `{number}` resolution at the passed coordinate. If this is `undefined`,
     * the default {@link module:ol/proj#getPointResolution} function will be used.
     */


    /**
     * @classdesc
     * Projection definition class. One of these is created for each projection
     * supported in the application and stored in the {@link module:ol/proj} namespace.
     * You can use these in applications, but this is not required, as API params
     * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
     * code will suffice.
     *
     * You can use {@link module:ol/proj~get} to retrieve the object for a particular
     * projection.
     *
     * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
     * with the following aliases:
     * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
     *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
     *     http://www.opengis.net/gml/srs/epsg.xml#4326,
     *     urn:x-ogc:def:crs:EPSG:4326
     * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
     *     urn:ogc:def:crs:EPSG:6.18:3:3857,
     *     http://www.opengis.net/gml/srs/epsg.xml#3857
     *
     * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
     * be added using `proj4.defs()`. After all required projection definitions are
     * added, call the {@link module:ol/proj/proj4~register} function.
     *
     * @api
     */
    var Projection = function Projection(options) {
      /**
       * @private
       * @type {string}
       */
      this.code_ = options.code;

      /**
       * Units of projected coordinates. When set to `TILE_PIXELS`, a
       * `this.extent_` and `this.worldExtent_` must be configured properly for each
       * tile.
       * @private
       * @type {module:ol/proj/Units}
       */
      this.units_ = /** @type {module:ol/proj/Units} */ (options.units);

      /**
       * Validity extent of the projection in projected coordinates. For projections
       * with `TILE_PIXELS` units, this is the extent of the tile in
       * tile pixel space.
       * @private
       * @type {module:ol/extent~Extent}
       */
      this.extent_ = options.extent !== undefined ? options.extent : null;

      /**
       * Extent of the world in EPSG:4326. For projections with
       * `TILE_PIXELS` units, this is the extent of the tile in
       * projected coordinate space.
       * @private
       * @type {module:ol/extent~Extent}
       */
      this.worldExtent_ = options.worldExtent !== undefined ?
        options.worldExtent : null;

      /**
       * @private
       * @type {string}
       */
      this.axisOrientation_ = options.axisOrientation !== undefined ?
        options.axisOrientation : 'enu';

      /**
       * @private
       * @type {boolean}
       */
      this.global_ = options.global !== undefined ? options.global : false;

      /**
       * @private
       * @type {boolean}
       */
      this.canWrapX_ = !!(this.global_ && this.extent_);

      /**
       * @private
       * @type {function(number, module:ol/coordinate~Coordinate):number|undefined}
       */
      this.getPointResolutionFunc_ = options.getPointResolution;

      /**
       * @private
       * @type {module:ol/tilegrid/TileGrid}
       */
      this.defaultTileGrid_ = null;

      /**
       * @private
       * @type {number|undefined}
       */
      this.metersPerUnit_ = options.metersPerUnit;
    };

    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    Projection.prototype.canWrapX = function canWrapX () {
      return this.canWrapX_;
    };

    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    Projection.prototype.getCode = function getCode () {
      return this.code_;
    };

    /**
     * Get the validity extent for this projection.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    Projection.prototype.getExtent = function getExtent () {
      return this.extent_;
    };

    /**
     * Get the units of this projection.
     * @return {module:ol/proj/Units} Units.
     * @api
     */
    Projection.prototype.getUnits = function getUnits () {
      return this.units_;
    };

    /**
     * Get the amount of meters per unit of this projection.If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    Projection.prototype.getMetersPerUnit = function getMetersPerUnit () {
      return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
    };

    /**
     * Get the world extent for this projection.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    Projection.prototype.getWorldExtent = function getWorldExtent () {
      return this.worldExtent_;
    };

    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *   or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *   "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    Projection.prototype.getAxisOrientation = function getAxisOrientation () {
      return this.axisOrientation_;
    };

    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    Projection.prototype.isGlobal = function isGlobal () {
      return this.global_;
    };

    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    Projection.prototype.setGlobal = function setGlobal (global) {
      this.global_ = global;
      this.canWrapX_ = !!(global && this.extent_);
    };

    /**
     * @return {module:ol/tilegrid/TileGrid} The default tile grid.
     */
    Projection.prototype.getDefaultTileGrid = function getDefaultTileGrid () {
      return this.defaultTileGrid_;
    };

    /**
     * @param {module:ol/tilegrid/TileGrid} tileGrid The default tile grid.
     */
    Projection.prototype.setDefaultTileGrid = function setDefaultTileGrid (tileGrid) {
      this.defaultTileGrid_ = tileGrid;
    };

    /**
     * Set the validity extent for this projection.
     * @param {module:ol/extent~Extent} extent Extent.
     * @api
     */
    Projection.prototype.setExtent = function setExtent (extent) {
      this.extent_ = extent;
      this.canWrapX_ = !!(this.global_ && extent);
    };

    /**
     * Set the world extent for this projection.
     * @param {module:ol/extent~Extent} worldExtent World extent
     *   [minlon, minlat, maxlon, maxlat].
     * @api
     */
    Projection.prototype.setWorldExtent = function setWorldExtent (worldExtent) {
      this.worldExtent_ = worldExtent;
    };

    /**
     * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
     * for this projection.
     * @param {function(number, module:ol/coordinate~Coordinate):number} func Function
     * @api
     */
    Projection.prototype.setGetPointResolution = function setGetPointResolution (func) {
      this.getPointResolutionFunc_ = func;
    };

    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, module:ol/coordinate~Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    Projection.prototype.getPointResolutionFunc = function getPointResolutionFunc () {
      return this.getPointResolutionFunc_;
    };

    /**
     * @module ol/proj/epsg3857
     */


    /**
     * Radius of WGS84 sphere
     *
     * @const
     * @type {number}
     */
    var RADIUS = 6378137;


    /**
     * @const
     * @type {number}
     */
    var HALF_SIZE = Math.PI * RADIUS;


    /**
     * @const
     * @type {module:ol/extent~Extent}
     */
    var EXTENT = [
      -HALF_SIZE, -HALF_SIZE,
      HALF_SIZE, HALF_SIZE
    ];


    /**
     * @const
     * @type {module:ol/extent~Extent}
     */
    var WORLD_EXTENT = [-180, -85, 180, 85];


    /**
     * @classdesc
     * Projection object for web/spherical Mercator (EPSG:3857).
     */
    var EPSG3857Projection = (function (Projection$$1) {
      function EPSG3857Projection(code) {
        Projection$$1.call(this, {
          code: code,
          units: Units.METERS,
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / cosh(point[1] / RADIUS);
          }
        });

      }

      if ( Projection$$1 ) EPSG3857Projection.__proto__ = Projection$$1;
      EPSG3857Projection.prototype = Object.create( Projection$$1 && Projection$$1.prototype );
      EPSG3857Projection.prototype.constructor = EPSG3857Projection;

      return EPSG3857Projection;
    }(Projection));


    /**
     * Projections equal to EPSG:3857.
     *
     * @const
     * @type {Array.<module:ol/proj/Projection>}
     */
    var PROJECTIONS = [
      new EPSG3857Projection('EPSG:3857'),
      new EPSG3857Projection('EPSG:102100'),
      new EPSG3857Projection('EPSG:102113'),
      new EPSG3857Projection('EPSG:900913'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
      new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857')
    ];


    /**
     * Transformation from EPSG:4326 to EPSG:3857.
     *
     * @param {Array.<number>} input Input array of coordinate values.
     * @param {Array.<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension (default is `2`).
     * @return {Array.<number>} Output array of coordinate values.
     */
    function fromEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
        if (dimension > 2) {
          // preserve values beyond second dimension
          output = input.slice();
        } else {
          output = new Array(length);
        }
      }
      var halfSize = HALF_SIZE;
      for (var i = 0; i < length; i += dimension) {
        output[i] = halfSize * input[i] / 180;
        var y = RADIUS *
            Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
        if (y > halfSize) {
          y = halfSize;
        } else if (y < -halfSize) {
          y = -halfSize;
        }
        output[i + 1] = y;
      }
      return output;
    }


    /**
     * Transformation from EPSG:3857 to EPSG:4326.
     *
     * @param {Array.<number>} input Input array of coordinate values.
     * @param {Array.<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension (default is `2`).
     * @return {Array.<number>} Output array of coordinate values.
     */
    function toEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
        if (dimension > 2) {
          // preserve values beyond second dimension
          output = input.slice();
        } else {
          output = new Array(length);
        }
      }
      for (var i = 0; i < length; i += dimension) {
        output[i] = 180 * input[i] / HALF_SIZE;
        output[i + 1] = 360 * Math.atan(
          Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
      }
      return output;
    }

    /**
     * @module ol/proj/epsg4326
     */


    /**
     * Semi-major radius of the WGS84 ellipsoid.
     *
     * @const
     * @type {number}
     */
    var RADIUS$1 = 6378137;


    /**
     * Extent of the EPSG:4326 projection which is the whole world.
     *
     * @const
     * @type {module:ol/extent~Extent}
     */
    var EXTENT$1 = [-180, -90, 180, 90];


    /**
     * @const
     * @type {number}
     */
    var METERS_PER_UNIT$1 = Math.PI * RADIUS$1 / 180;


    /**
     * @classdesc
     * Projection object for WGS84 geographic coordinates (EPSG:4326).
     *
     * Note that OpenLayers does not strictly comply with the EPSG definition.
     * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
     * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
     */
    var EPSG4326Projection = (function (Projection$$1) {
      function EPSG4326Projection(code, opt_axisOrientation) {
        Projection$$1.call(this, {
          code: code,
          units: Units.DEGREES,
          extent: EXTENT$1,
          axisOrientation: opt_axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT$1,
          worldExtent: EXTENT$1
        });

      }

      if ( Projection$$1 ) EPSG4326Projection.__proto__ = Projection$$1;
      EPSG4326Projection.prototype = Object.create( Projection$$1 && Projection$$1.prototype );
      EPSG4326Projection.prototype.constructor = EPSG4326Projection;

      return EPSG4326Projection;
    }(Projection));


    /**
     * Projections equal to EPSG:4326.
     *
     * @const
     * @type {Array.<module:ol/proj/Projection>}
     */
    var PROJECTIONS$1 = [
      new EPSG4326Projection('CRS:84'),
      new EPSG4326Projection('EPSG:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
      new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
      new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu')
    ];

    /**
     * @module ol/proj/projections
     */


    /**
     * @type {Object.<string, module:ol/proj/Projection>}
     */
    var cache = {};


    /**
     * Get a cached projection by code.
     * @param {string} code The code for the projection.
     * @return {module:ol/proj/Projection} The projection (if cached).
     */
    function get(code) {
      return cache[code] || null;
    }


    /**
     * Add a projection to the cache.
     * @param {string} code The projection code.
     * @param {module:ol/proj/Projection} projection The projection to cache.
     */
    function add$1(code, projection) {
      cache[code] = projection;
    }

    /**
     * @module ol/proj/transforms
     */


    /**
     * @private
     * @type {!Object.<string, Object.<string, module:ol/proj~TransformFunction>>}
     */
    var transforms = {};


    /**
     * Registers a conversion function to convert coordinates from the source
     * projection to the destination projection.
     *
     * @param {module:ol/proj/Projection} source Source.
     * @param {module:ol/proj/Projection} destination Destination.
     * @param {module:ol/proj~TransformFunction} transformFn Transform.
     */
    function add$2(source, destination, transformFn) {
      var sourceCode = source.getCode();
      var destinationCode = destination.getCode();
      if (!(sourceCode in transforms)) {
        transforms[sourceCode] = {};
      }
      transforms[sourceCode][destinationCode] = transformFn;
    }


    /**
     * Get a transform given a source code and a destination code.
     * @param {string} sourceCode The code for the source projection.
     * @param {string} destinationCode The code for the destination projection.
     * @return {module:ol/proj~TransformFunction|undefined} The transform function (if found).
     */
    function get$1(sourceCode, destinationCode) {
      var transform;
      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
        transform = transforms[sourceCode][destinationCode];
      }
      return transform;
    }

    /**
     * @module ol/proj
     */


    /**
     * @param {Array.<number>} input Input coordinate array.
     * @param {Array.<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output coordinate array (new array, same coordinate
     *     values).
     */
    function cloneTransform(input, opt_output, opt_dimension) {
      var output;
      if (opt_output !== undefined) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
          opt_output[i] = input[i];
        }
        output = opt_output;
      } else {
        output = input.slice();
      }
      return output;
    }


    /**
     * @param {Array.<number>} input Input coordinate array.
     * @param {Array.<number>=} opt_output Output array of coordinate values.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Input coordinate array (same array as input).
     */
    function identityTransform(input, opt_output, opt_dimension) {
      if (opt_output !== undefined && input !== opt_output) {
        for (var i = 0, ii = input.length; i < ii; ++i) {
          opt_output[i] = input[i];
        }
        input = opt_output;
      }
      return input;
    }


    /**
     * Add a Projection object to the list of supported projections that can be
     * looked up by their code.
     *
     * @param {module:ol/proj/Projection} projection Projection instance.
     * @api
     */
    function addProjection(projection) {
      add$1(projection.getCode(), projection);
      add$2(projection, projection, cloneTransform);
    }


    /**
     * @param {Array.<module:ol/proj/Projection>} projections Projections.
     */
    function addProjections(projections) {
      projections.forEach(addProjection);
    }


    /**
     * Fetches a Projection object for the code specified.
     *
     * @param {module:ol/proj~ProjectionLike} projectionLike Either a code string which is
     *     a combination of authority and identifier such as "EPSG:4326", or an
     *     existing projection object, or undefined.
     * @return {module:ol/proj/Projection} Projection object, or null if not in list.
     * @api
     */
    function get$2(projectionLike) {
      var projection = null;
      if (projectionLike instanceof Projection) {
        projection = projectionLike;
      } else if (typeof projectionLike === 'string') {
        var code = projectionLike;
        projection = get(code);
      }
      return projection;
    }


    /**
     * Get the resolution of the point in degrees or distance units.
     * For projections with degrees as the unit this will simply return the
     * provided resolution. For other projections the point resolution is
     * by default estimated by transforming the 'point' pixel to EPSG:4326,
     * measuring its width and height on the normal sphere,
     * and taking the average of the width and height.
     * A custom function can be provided for a specific projection, either
     * by setting the `getPointResolution` option in the
     * {@link module:ol/proj/Projection~Projection} constructor or by using
     * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
     * projection object.
     * @param {module:ol/proj~ProjectionLike} projection The projection.
     * @param {number} resolution Nominal resolution in projection units.
     * @param {module:ol/coordinate~Coordinate} point Point to find adjusted resolution at.
     * @param {module:ol/proj/Units=} opt_units Units to get the point resolution in.
     * Default is the projection's units.
     * @return {number} Point resolution.
     * @api
     */
    function getPointResolution(projection, resolution, point, opt_units) {
      projection = get$2(projection);
      var pointResolution;
      var getter = projection.getPointResolutionFunc();
      if (getter) {
        pointResolution = getter(resolution, point);
      } else {
        var units = projection.getUnits();
        if (units == Units.DEGREES && !opt_units || opt_units == Units.DEGREES) {
          pointResolution = resolution;
        } else {
          // Estimate point resolution by transforming the center pixel to EPSG:4326,
          // measuring its width and height on the normal sphere, and taking the
          // average of the width and height.
          var toEPSG4326$$1 = getTransformFromProjections(projection, get$2('EPSG:4326'));
          var vertices = [
            point[0] - resolution / 2, point[1],
            point[0] + resolution / 2, point[1],
            point[0], point[1] - resolution / 2,
            point[0], point[1] + resolution / 2
          ];
          vertices = toEPSG4326$$1(vertices, vertices, 2);
          var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
          var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
          pointResolution = (width + height) / 2;
          var metersPerUnit = opt_units ?
            METERS_PER_UNIT[opt_units] :
            projection.getMetersPerUnit();
          if (metersPerUnit !== undefined) {
            pointResolution /= metersPerUnit;
          }
        }
      }
      return pointResolution;
    }


    /**
     * Registers transformation functions that don't alter coordinates. Those allow
     * to transform between projections with equal meaning.
     *
     * @param {Array.<module:ol/proj/Projection>} projections Projections.
     * @api
     */
    function addEquivalentProjections(projections) {
      addProjections(projections);
      projections.forEach(function(source) {
        projections.forEach(function(destination) {
          if (source !== destination) {
            add$2(source, destination, cloneTransform);
          }
        });
      });
    }


    /**
     * Registers transformation functions to convert coordinates in any projection
     * in projection1 to any projection in projection2.
     *
     * @param {Array.<module:ol/proj/Projection>} projections1 Projections with equal
     *     meaning.
     * @param {Array.<module:ol/proj/Projection>} projections2 Projections with equal
     *     meaning.
     * @param {module:ol/proj~TransformFunction} forwardTransform Transformation from any
     *   projection in projection1 to any projection in projection2.
     * @param {module:ol/proj~TransformFunction} inverseTransform Transform from any projection
     *   in projection2 to any projection in projection1..
     */
    function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
      projections1.forEach(function(projection1) {
        projections2.forEach(function(projection2) {
          add$2(projection1, projection2, forwardTransform);
          add$2(projection2, projection1, inverseTransform);
        });
      });
    }


    /**
     * @param {module:ol/proj/Projection|string|undefined} projection Projection.
     * @param {string} defaultCode Default code.
     * @return {module:ol/proj/Projection} Projection.
     */
    function createProjection(projection, defaultCode) {
      if (!projection) {
        return get$2(defaultCode);
      } else if (typeof projection === 'string') {
        return get$2(projection);
      } else {
        return (
          /** @type {module:ol/proj/Projection} */ (projection)
        );
      }
    }


    /**
     * Transforms a coordinate from longitude/latitude to a different projection.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate as longitude and latitude, i.e.
     *     an array with longitude as 1st and latitude as 2nd element.
     * @param {module:ol/proj~ProjectionLike=} opt_projection Target projection. The
     *     default is Web Mercator, i.e. 'EPSG:3857'.
     * @return {module:ol/coordinate~Coordinate} Coordinate projected to the target projection.
     * @api
     */
    function fromLonLat(coordinate, opt_projection) {
      return transform(coordinate, 'EPSG:4326',
        opt_projection !== undefined ? opt_projection : 'EPSG:3857');
    }


    /**
     * Checks if two projections are the same, that is every coordinate in one
     * projection does represent the same geographic point as the same coordinate in
     * the other projection.
     *
     * @param {module:ol/proj/Projection} projection1 Projection 1.
     * @param {module:ol/proj/Projection} projection2 Projection 2.
     * @return {boolean} Equivalent.
     * @api
     */
    function equivalent(projection1, projection2) {
      if (projection1 === projection2) {
        return true;
      }
      var equalUnits = projection1.getUnits() === projection2.getUnits();
      if (projection1.getCode() === projection2.getCode()) {
        return equalUnits;
      } else {
        var transformFunc = getTransformFromProjections(projection1, projection2);
        return transformFunc === cloneTransform && equalUnits;
      }
    }


    /**
     * Searches in the list of transform functions for the function for converting
     * coordinates from the source projection to the destination projection.
     *
     * @param {module:ol/proj/Projection} sourceProjection Source Projection object.
     * @param {module:ol/proj/Projection} destinationProjection Destination Projection
     *     object.
     * @return {module:ol/proj~TransformFunction} Transform function.
     */
    function getTransformFromProjections(sourceProjection, destinationProjection) {
      var sourceCode = sourceProjection.getCode();
      var destinationCode = destinationProjection.getCode();
      var transformFunc = get$1(sourceCode, destinationCode);
      if (!transformFunc) {
        transformFunc = identityTransform;
      }
      return transformFunc;
    }


    /**
     * Given the projection-like objects, searches for a transformation
     * function to convert a coordinates array from the source projection to the
     * destination projection.
     *
     * @param {module:ol/proj~ProjectionLike} source Source.
     * @param {module:ol/proj~ProjectionLike} destination Destination.
     * @return {module:ol/proj~TransformFunction} Transform function.
     * @api
     */
    function getTransform(source, destination) {
      var sourceProjection = get$2(source);
      var destinationProjection = get$2(destination);
      return getTransformFromProjections(sourceProjection, destinationProjection);
    }


    /**
     * Transforms a coordinate from source projection to destination projection.
     * This returns a new coordinate (and does not modify the original).
     *
     * See {@link module:ol/proj~transformExtent} for extent transformation.
     * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
     * subclasses for geometry transforms.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {module:ol/proj~ProjectionLike} source Source projection-like.
     * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
     * @return {module:ol/coordinate~Coordinate} Coordinate.
     * @api
     */
    function transform(coordinate, source, destination) {
      var transformFunc = getTransform(source, destination);
      return transformFunc(coordinate, undefined, coordinate.length);
    }


    /**
     * Transforms an extent from source projection to destination projection.  This
     * returns a new extent (and does not modify the original).
     *
     * @param {module:ol/extent~Extent} extent The extent to transform.
     * @param {module:ol/proj~ProjectionLike} source Source projection-like.
     * @param {module:ol/proj~ProjectionLike} destination Destination projection-like.
     * @return {module:ol/extent~Extent} The transformed extent.
     * @api
     */
    function transformExtent(extent, source, destination) {
      var transformFunc = getTransform(source, destination);
      return applyTransform(extent, transformFunc);
    }

    /**
     * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
     * by when this module is executed and should only need to be called again after
     * `clearAllProjections()` is called (e.g. in tests).
     */
    function addCommon() {
      // Add transformations that don't alter coordinates to convert within set of
      // projections with equal meaning.
      addEquivalentProjections(PROJECTIONS);
      addEquivalentProjections(PROJECTIONS$1);
      // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
      // coordinates and back.
      addEquivalentTransforms(PROJECTIONS$1, PROJECTIONS, fromEPSG4326, toEPSG4326);
    }

    addCommon();

    /**
     * @module ol/transform
     */


    /**
     * An array representing an affine 2d transformation for use with
     * {@link module:ol/transform} functions. The array has 6 elements.
     * @typedef {!Array.<number>} Transform
     */


    /**
     * Collection of affine 2d transformation functions. The functions work on an
     * array of 6 elements. The element order is compatible with the [SVGMatrix
     * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
     * a subset (elements a to f) of a 3×3 matrix:
     * ```
     * [ a c e ]
     * [ b d f ]
     * [ 0 0 1 ]
     * ```
     */


    /**
     * @private
     * @type {module:ol/transform~Transform}
     */
    var tmp_ = new Array(6);


    /**
     * Create an identity transform.
     * @return {!module:ol/transform~Transform} Identity transform.
     */
    function create() {
      return [1, 0, 0, 1, 0, 0];
    }


    /**
     * Resets the given transform to an identity transform.
     * @param {!module:ol/transform~Transform} transform Transform.
     * @return {!module:ol/transform~Transform} Transform.
     */
    function reset(transform) {
      return set(transform, 1, 0, 0, 1, 0, 0);
    }


    /**
     * Multiply the underlying matrices of two transforms and return the result in
     * the first transform.
     * @param {!module:ol/transform~Transform} transform1 Transform parameters of matrix 1.
     * @param {!module:ol/transform~Transform} transform2 Transform parameters of matrix 2.
     * @return {!module:ol/transform~Transform} transform1 multiplied with transform2.
     */
    function multiply(transform1, transform2) {
      var a1 = transform1[0];
      var b1 = transform1[1];
      var c1 = transform1[2];
      var d1 = transform1[3];
      var e1 = transform1[4];
      var f1 = transform1[5];
      var a2 = transform2[0];
      var b2 = transform2[1];
      var c2 = transform2[2];
      var d2 = transform2[3];
      var e2 = transform2[4];
      var f2 = transform2[5];

      transform1[0] = a1 * a2 + c1 * b2;
      transform1[1] = b1 * a2 + d1 * b2;
      transform1[2] = a1 * c2 + c1 * d2;
      transform1[3] = b1 * c2 + d1 * d2;
      transform1[4] = a1 * e2 + c1 * f2 + e1;
      transform1[5] = b1 * e2 + d1 * f2 + f1;

      return transform1;
    }

    /**
     * Set the transform components a-f on a given transform.
     * @param {!module:ol/transform~Transform} transform Transform.
     * @param {number} a The a component of the transform.
     * @param {number} b The b component of the transform.
     * @param {number} c The c component of the transform.
     * @param {number} d The d component of the transform.
     * @param {number} e The e component of the transform.
     * @param {number} f The f component of the transform.
     * @return {!module:ol/transform~Transform} Matrix with transform applied.
     */
    function set(transform, a, b, c, d, e, f) {
      transform[0] = a;
      transform[1] = b;
      transform[2] = c;
      transform[3] = d;
      transform[4] = e;
      transform[5] = f;
      return transform;
    }


    /**
     * Set transform on one matrix from another matrix.
     * @param {!module:ol/transform~Transform} transform1 Matrix to set transform to.
     * @param {!module:ol/transform~Transform} transform2 Matrix to set transform from.
     * @return {!module:ol/transform~Transform} transform1 with transform from transform2 applied.
     */
    function setFromArray(transform1, transform2) {
      transform1[0] = transform2[0];
      transform1[1] = transform2[1];
      transform1[2] = transform2[2];
      transform1[3] = transform2[3];
      transform1[4] = transform2[4];
      transform1[5] = transform2[5];
      return transform1;
    }


    /**
     * Transforms the given coordinate with the given transform returning the
     * resulting, transformed coordinate. The coordinate will be modified in-place.
     *
     * @param {module:ol/transform~Transform} transform The transformation.
     * @param {module:ol/coordinate~Coordinate|module:ol/pixel~Pixel} coordinate The coordinate to transform.
     * @return {module:ol/coordinate~Coordinate|module:ol/pixel~Pixel} return coordinate so that operations can be
     *     chained together.
     */
    function apply(transform, coordinate) {
      var x = coordinate[0];
      var y = coordinate[1];
      coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
      coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
      return coordinate;
    }


    /**
     * Applies scale to a given transform.
     * @param {!module:ol/transform~Transform} transform Transform.
     * @param {number} x Scale factor x.
     * @param {number} y Scale factor y.
     * @return {!module:ol/transform~Transform} The scaled transform.
     */
    function scale$2(transform, x, y) {
      return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));
    }


    /**
     * Applies translation to the given transform.
     * @param {!module:ol/transform~Transform} transform Transform.
     * @param {number} dx Translation x.
     * @param {number} dy Translation y.
     * @return {!module:ol/transform~Transform} The translated transform.
     */
    function translate$1(transform, dx, dy) {
      return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));
    }


    /**
     * Creates a composite transform given an initial translation, scale, rotation, and
     * final translation (in that order only, not commutative).
     * @param {!module:ol/transform~Transform} transform The transform (will be modified in place).
     * @param {number} dx1 Initial translation x.
     * @param {number} dy1 Initial translation y.
     * @param {number} sx Scale factor x.
     * @param {number} sy Scale factor y.
     * @param {number} angle Rotation (in counter-clockwise radians).
     * @param {number} dx2 Final translation x.
     * @param {number} dy2 Final translation y.
     * @return {!module:ol/transform~Transform} The composite transform.
     */
    function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      transform[0] = sx * cos;
      transform[1] = sy * sin;
      transform[2] = -sx * sin;
      transform[3] = sy * cos;
      transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
      transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
      return transform;
    }


    /**
     * Invert the given transform.
     * @param {!module:ol/transform~Transform} transform Transform.
     * @return {!module:ol/transform~Transform} Inverse of the transform.
     */
    function invert(transform) {
      var det = determinant(transform);
      assert(det !== 0, 32); // Transformation matrix cannot be inverted

      var a = transform[0];
      var b = transform[1];
      var c = transform[2];
      var d = transform[3];
      var e = transform[4];
      var f = transform[5];

      transform[0] = d / det;
      transform[1] = -b / det;
      transform[2] = -c / det;
      transform[3] = a / det;
      transform[4] = (c * f - d * e) / det;
      transform[5] = -(a * f - b * e) / det;

      return transform;
    }


    /**
     * Returns the determinant of the given matrix.
     * @param {!module:ol/transform~Transform} mat Matrix.
     * @return {number} Determinant.
     */
    function determinant(mat) {
      return mat[0] * mat[3] - mat[1] * mat[2];
    }

    /**
     * @module ol/geom/Geometry
     */


    /**
     * @type {module:ol/transform~Transform}
     */
    var tmpTransform = create();


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for vector geometries.
     *
     * To get notified of changes to the geometry, register a listener for the
     * generic `change` event on your geometry instance.
     *
     * @abstract
     * @api
     */
    var Geometry = (function (BaseObject$$1) {
      function Geometry() {

        BaseObject$$1.call(this);

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.extent_ = createEmpty();

        /**
         * @private
         * @type {number}
         */
        this.extentRevision_ = -1;

        /**
         * @protected
         * @type {Object.<string, module:ol/geom/Geometry>}
         */
        this.simplifiedGeometryCache = {};

        /**
         * @protected
         * @type {number}
         */
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;

        /**
         * @protected
         * @type {number}
         */
        this.simplifiedGeometryRevision = 0;

      }

      if ( BaseObject$$1 ) Geometry.__proto__ = BaseObject$$1;
      Geometry.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Geometry.prototype.constructor = Geometry;

      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!module:ol/geom/Geometry} Clone.
       */
      Geometry.prototype.clone = function clone$$1 () {};

      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {module:ol/coordinate~Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {};

      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {module:ol/coordinate~Coordinate} point Point.
       * @param {module:ol/coordinate~Coordinate=} opt_closestPoint Closest point.
       * @return {module:ol/coordinate~Coordinate} Closest point.
       * @api
       */
      Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {
        var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      };

      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      };

      /**
       * @abstract
       * @param {module:ol/extent~Extent} extent Extent.
       * @protected
       * @return {module:ol/extent~Extent} extent Extent.
       */
      Geometry.prototype.computeExtent = function computeExtent (extent) {};

      /**
       * Get the extent of the geometry.
       * @param {module:ol/extent~Extent=} opt_extent Extent.
       * @return {module:ol/extent~Extent} extent Extent.
       * @api
       */
      Geometry.prototype.getExtent = function getExtent (opt_extent) {
        if (this.extentRevision_ != this.getRevision()) {
          this.extent_ = this.computeExtent(this.extent_);
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, opt_extent);
      };

      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {module:ol/coordinate~Coordinate} anchor The rotation center.
       * @api
       */
      Geometry.prototype.rotate = function rotate (angle, anchor) {};

      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
       *     sx).
       * @param {module:ol/coordinate~Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {};

      /**
       * Translate the geometry. This modifies the geometry coordinates in place.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      Geometry.prototype.translate = function translate$$1 (deltaX, deltaY) {};

      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the the {@link
       * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
       * Douglas Peucker} algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @function
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {module:ol/geom/Geometry} A new, simplified version of the original
       *     geometry.
       * @api
       */
      Geometry.prototype.simplify = function simplify (tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      };

      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {module:ol/geom/Geometry} Simplified geometry.
       */
      Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {};

      /**
       * Get the type of this geometry.
       * @abstract
       * @return {module:ol/geom/GeometryType} Geometry type.
       */
      Geometry.prototype.getType = function getType () {};

      /**
       * Apply a transform function to each coordinate of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {module:ol/proj~TransformFunction} transformFn Transform.
       */
      Geometry.prototype.applyTransform = function applyTransform$$1 (transformFn) {};

      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {module:ol/extent~Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {};

      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       */
      Geometry.prototype.translate = function translate$$1 (deltaX, deltaY) {};

      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {module:ol/geom/Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      Geometry.prototype.transform = function transform$$1 (source, destination) {
        source = get$2(source);
        var transformFn = source.getUnits() == Units.TILE_PIXELS ?
          function(inCoordinates, outCoordinates, stride) {
            var pixelExtent = source.getExtent();
            var projectedExtent = source.getWorldExtent();
            var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
            compose(tmpTransform,
              projectedExtent[0], projectedExtent[3],
              scale, -scale, 0,
              0, 0);
            transform2D(inCoordinates, 0, inCoordinates.length, stride,
              tmpTransform, outCoordinates);
            return getTransform(source, destination)(inCoordinates, outCoordinates, stride);
          } :
          getTransform(source, destination);
        this.applyTransform(transformFn);
        return this;
      };

      return Geometry;
    }(BaseObject));


    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    Geometry.prototype.containsXY = FALSE;

    /**
     * @module ol/geom/SimpleGeometry
     */

    /**
     * @classdesc
     * Abstract base class; only used for creating subclasses; do not instantiate
     * in apps, as cannot be rendered.
     *
     * @abstract
     * @api
     */
    var SimpleGeometry = (function (Geometry$$1) {
      function SimpleGeometry() {

        Geometry$$1.call(this);

        /**
         * @protected
         * @type {module:ol/geom/GeometryLayout}
         */
        this.layout = GeometryLayout.XY;

        /**
         * @protected
         * @type {number}
         */
        this.stride = 2;

        /**
         * @protected
         * @type {Array.<number>}
         */
        this.flatCoordinates = null;

      }

      if ( Geometry$$1 ) SimpleGeometry.__proto__ = Geometry$$1;
      SimpleGeometry.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );
      SimpleGeometry.prototype.constructor = SimpleGeometry;

      /**
       * @inheritDoc
       */
      SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {
        return createOrUpdateFromFlatCoordinates(this.flatCoordinates,
          0, this.flatCoordinates.length, this.stride, extent);
      };

      /**
       * @abstract
       * @return {Array} Coordinates.
       */
      SimpleGeometry.prototype.getCoordinates = function getCoordinates () {};

      /**
       * Return the first coordinate of the geometry.
       * @return {module:ol/coordinate~Coordinate} First coordinate.
       * @api
       */
      SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {
        return this.flatCoordinates.slice(0, this.stride);
      };

      /**
       * @return {Array.<number>} Flat coordinates.
       */
      SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {
        return this.flatCoordinates;
      };

      /**
       * Return the last coordinate of the geometry.
       * @return {module:ol/coordinate~Coordinate} Last point.
       * @api
       */
      SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      };

      /**
       * Return the {@link module:ol/geom/GeometryLayout~GeometryLayout layout} of the geometry.
       * @return {module:ol/geom/GeometryLayout} Layout.
       * @api
       */
      SimpleGeometry.prototype.getLayout = function getLayout () {
        return this.layout;
      };

      /**
       * @inheritDoc
       */
      SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {
        if (this.simplifiedGeometryRevision != this.getRevision()) {
          clear(this.simplifiedGeometryCache);
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        // If squaredTolerance is negative or if we know that simplification will not
        // have any effect then just return this.
        if (squaredTolerance < 0 ||
            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
             squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
          return this;
        }
        var key = squaredTolerance.toString();
        if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
          return this.simplifiedGeometryCache[key];
        } else {
          var simplifiedGeometry =
              this.getSimplifiedGeometryInternal(squaredTolerance);
          var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
          if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
            this.simplifiedGeometryCache[key] = simplifiedGeometry;
            return simplifiedGeometry;
          } else {
            // Simplification did not actually remove any coordinates.  We now know
            // that any calls to getSimplifiedGeometry with a squaredTolerance less
            // than or equal to the current squaredTolerance will also not have any
            // effect.  This allows us to short circuit simplification (saving CPU
            // cycles) and prevents the cache of simplified geometries from filling
            // up with useless identical copies of this geometry (saving memory).
            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
            return this;
          }
        }
      };

      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {module:ol/geom/SimpleGeometry} Simplified geometry.
       * @protected
       */
      SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        return this;
      };

      /**
       * @return {number} Stride.
       */
      SimpleGeometry.prototype.getStride = function getStride () {
        return this.stride;
      };

      /**
       * @param {module:ol/geom/GeometryLayout} layout Layout.
       * @param {Array.<number>} flatCoordinates Flat coordinates.
        */
      SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      };

      /**
       * @abstract
       * @param {!Array} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       */
      SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

      /**
       * @param {module:ol/geom/GeometryLayout|undefined} layout Layout.
       * @param {Array} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {
        var this$1 = this;

        /** @type {number} */
        var stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (var i = 0; i < nesting; ++i) {
            if (coordinates.length === 0) {
              this$1.layout = GeometryLayout.XY;
              this$1.stride = 2;
              return;
            } else {
              coordinates = /** @type {Array} */ (coordinates[0]);
            }
          }
          stride = coordinates.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      };

      /**
       * @inheritDoc
       * @api
       */
      SimpleGeometry.prototype.applyTransform = function applyTransform$$1 (transformFn) {
        if (this.flatCoordinates) {
          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
          this.changed();
        }
      };

      /**
       * @inheritDoc
       * @api
       */
      SimpleGeometry.prototype.rotate = function rotate$1$$1 (angle, anchor) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          var stride = this.getStride();
          rotate$1(
            flatCoordinates, 0, flatCoordinates.length,
            stride, angle, anchor, flatCoordinates);
          this.changed();
        }
      };

      /**
       * @inheritDoc
       * @api
       */
      SimpleGeometry.prototype.scale = function scale$1$$1 (sx, opt_sy, opt_anchor) {
        var sy = opt_sy;
        if (sy === undefined) {
          sy = sx;
        }
        var anchor = opt_anchor;
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          var stride = this.getStride();
          scale$1(
            flatCoordinates, 0, flatCoordinates.length,
            stride, sx, sy, anchor, flatCoordinates);
          this.changed();
        }
      };

      /**
       * @inheritDoc
       * @api
       */
      SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {
        var flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          var stride = this.getStride();
          translate(
            flatCoordinates, 0, flatCoordinates.length, stride,
            deltaX, deltaY, flatCoordinates);
          this.changed();
        }
      };

      return SimpleGeometry;
    }(Geometry));


    /**
     * @param {number} stride Stride.
     * @return {module:ol/geom/GeometryLayout} layout Layout.
     */
    function getLayoutForStride(stride) {
      var layout;
      if (stride == 2) {
        layout = GeometryLayout.XY;
      } else if (stride == 3) {
        layout = GeometryLayout.XYZ;
      } else if (stride == 4) {
        layout = GeometryLayout.XYZM;
      }
      return (
        /** @type {module:ol/geom/GeometryLayout} */ (layout)
      );
    }


    /**
     * @param {module:ol/geom/GeometryLayout} layout Layout.
     * @return {number} Stride.
     */
    function getStrideForLayout(layout) {
      var stride;
      if (layout == GeometryLayout.XY) {
        stride = 2;
      } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
        stride = 3;
      } else if (layout == GeometryLayout.XYZM) {
        stride = 4;
      }
      return /** @type {number} */ (stride);
    }


    /**
     * @inheritDoc
     */
    SimpleGeometry.prototype.containsXY = FALSE;


    /**
     * @param {module:ol/geom/SimpleGeometry} simpleGeometry Simple geometry.
     * @param {module:ol/transform~Transform} transform Transform.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Transformed flat coordinates.
     */
    function transformGeom2D(simpleGeometry, transform, opt_dest) {
      var flatCoordinates = simpleGeometry.getFlatCoordinates();
      if (!flatCoordinates) {
        return null;
      } else {
        var stride = simpleGeometry.getStride();
        return transform2D(
          flatCoordinates, 0, flatCoordinates.length, stride,
          transform, opt_dest);
      }
    }

    /**
     * @module ol/geom/flat/area
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRing(flatCoordinates, offset, end, stride) {
      var twiceArea = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        twiceArea += y1 * x2 - x1 * y2;
        x1 = x2;
        y1 = y2;
      }
      return twiceArea / 2;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRings(flatCoordinates, offset, ends, stride) {
      var area = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        area += linearRing(flatCoordinates, offset, end, stride);
        offset = end;
      }
      return area;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @return {number} Area.
     */
    function linearRingss(flatCoordinates, offset, endss, stride) {
      var area = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        area += linearRings(flatCoordinates, offset, ends, stride);
        offset = ends[ends.length - 1];
      }
      return area;
    }

    /**
     * @module ol/geom/flat/closest
     */


    /**
     * Returns the point on the 2D line segment flatCoordinates[offset1] to
     * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
     * dimensions are linearly interpolated.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset1 Offset 1.
     * @param {number} offset2 Offset 2.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array.<number>} closestPoint Closest point.
     */
    function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
      var x1 = flatCoordinates[offset1];
      var y1 = flatCoordinates[offset1 + 1];
      var dx = flatCoordinates[offset2] - x1;
      var dy = flatCoordinates[offset2 + 1] - y1;
      var offset;
      if (dx === 0 && dy === 0) {
        offset = offset1;
      } else {
        var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
        if (t > 1) {
          offset = offset2;
        } else if (t > 0) {
          for (var i = 0; i < stride; ++i) {
            closestPoint[i] = lerp(flatCoordinates[offset1 + i],
              flatCoordinates[offset2 + i], t);
          }
          closestPoint.length = stride;
          return;
        } else {
          offset = offset1;
        }
      }
      for (var i$1 = 0; i$1 < stride; ++i$1) {
        closestPoint[i$1] = flatCoordinates[offset + i$1];
      }
      closestPoint.length = stride;
    }


    /**
     * Return the squared of the largest distance between any pair of consecutive
     * coordinates.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      for (offset += stride; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        var squaredDelta = squaredDistance(x1, y1, x2, y2);
        if (squaredDelta > max) {
          max = squaredDelta;
        }
        x1 = x2;
        y1 = y2;
      }
      return max;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        max = maxSquaredDelta(
          flatCoordinates, offset, end, stride, max);
        offset = end;
      }
      return max;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} max Max squared delta.
     * @return {number} Max squared delta.
     */
    function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        max = arrayMaxSquaredDelta(
          flatCoordinates, offset, ends, stride, max);
        offset = ends[ends.length - 1];
      }
      return max;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array.<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array.<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestPoint(flatCoordinates, offset, end,
      stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
      opt_tmpPoint) {
      if (offset == end) {
        return minSquaredDistance;
      }
      var i, squaredDistance$$1;
      if (maxDelta === 0) {
        // All points are identical, so just test the first point.
        squaredDistance$$1 = squaredDistance(
          x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
        if (squaredDistance$$1 < minSquaredDistance) {
          for (i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[offset + i];
          }
          closestPoint.length = stride;
          return squaredDistance$$1;
        } else {
          return minSquaredDistance;
        }
      }
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      var index = offset + stride;
      while (index < end) {
        assignClosest(
          flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
        squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance$$1 < minSquaredDistance) {
          minSquaredDistance = squaredDistance$$1;
          for (i = 0; i < stride; ++i) {
            closestPoint[i] = tmpPoint[i];
          }
          closestPoint.length = stride;
          index += stride;
        } else {
          // Skip ahead multiple points, because we know that all the skipped
          // points cannot be any closer than the closest point we have found so
          // far.  We know this because we know how close the current point is, how
          // close the closest point we have found so far is, and the maximum
          // distance between consecutive points.  For example, if we're currently
          // at distance 10, the best we've found so far is 3, and that the maximum
          // distance between consecutive points is 2, then we'll need to skip at
          // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
          // finding a closer point.  We use Math.max(..., 1) to ensure that we
          // always advance at least one point, to avoid an infinite loop.
          index += stride * Math.max(
            ((Math.sqrt(squaredDistance$$1) -
                Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);
        }
      }
      if (isRing) {
        // Check the closing segment.
        assignClosest(
          flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
        squaredDistance$$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
        if (squaredDistance$$1 < minSquaredDistance) {
          minSquaredDistance = squaredDistance$$1;
          for (i = 0; i < stride; ++i) {
            closestPoint[i] = tmpPoint[i];
          }
          closestPoint.length = stride;
        }
      }
      return minSquaredDistance;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array.<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array.<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestArrayPoint(flatCoordinates, offset, ends,
      stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
      opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        minSquaredDistance = assignClosestPoint(
          flatCoordinates, offset, end, stride,
          maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = end;
      }
      return minSquaredDistance;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} maxDelta Max delta.
     * @param {boolean} isRing Is ring.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {Array.<number>} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @param {Array.<number>=} opt_tmpPoint Temporary point object.
     * @return {number} Minimum squared distance.
     */
    function assignClosestMultiArrayPoint(flatCoordinates, offset,
      endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,
      opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        minSquaredDistance = assignClosestArrayPoint(
          flatCoordinates, offset, ends, stride,
          maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
        offset = ends[ends.length - 1];
      }
      return minSquaredDistance;
    }

    /**
     * @module ol/geom/flat/deflate
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} stride Stride.
     * @return {number} offset Offset.
     */
    function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
      for (var i = 0, ii = coordinate.length; i < ii; ++i) {
        flatCoordinates[offset++] = coordinate[i];
      }
      return offset;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
     * @param {number} stride Stride.
     * @return {number} offset Offset.
     */
    function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        var coordinate = coordinates[i];
        for (var j = 0; j < stride; ++j) {
          flatCoordinates[offset++] = coordinate[j];
        }
      }
      return offset;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<module:ol/coordinate~Coordinate>>} coordinatess Coordinatess.
     * @param {number} stride Stride.
     * @param {Array.<number>=} opt_ends Ends.
     * @return {Array.<number>} Ends.
     */
    function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
      var ends = opt_ends ? opt_ends : [];
      var i = 0;
      for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
        var end = deflateCoordinates(
          flatCoordinates, offset, coordinatess[j], stride);
        ends[i++] = end;
        offset = end;
      }
      ends.length = i;
      return ends;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinatesss Coordinatesss.
     * @param {number} stride Stride.
     * @param {Array.<Array.<number>>=} opt_endss Endss.
     * @return {Array.<Array.<number>>} Endss.
     */
    function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
      var endss = opt_endss ? opt_endss : [];
      var i = 0;
      for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
        var ends = deflateCoordinatesArray(
          flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
        endss[i++] = ends;
        offset = ends[ends.length - 1];
      }
      endss.length = i;
      return endss;
    }

    /**
     * @module ol/geom/flat/inflate
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {Array.<module:ol/coordinate~Coordinate>=} opt_coordinates Coordinates.
     * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
     */
    function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
      var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
        coordinates[i++] = flatCoordinates.slice(j, j + stride);
      }
      coordinates.length = i;
      return coordinates;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array.<Array.<module:ol/coordinate~Coordinate>>=} opt_coordinatess Coordinatess.
     * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinatess.
     */
    function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
      var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
      var i = 0;
      for (var j = 0, jj = ends.length; j < jj; ++j) {
        var end = ends[j];
        coordinatess[i++] = inflateCoordinates(
          flatCoordinates, offset, end, stride, coordinatess[i]);
        offset = end;
      }
      coordinatess.length = i;
      return coordinatess;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>=} opt_coordinatesss
     *     Coordinatesss.
     * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinatesss.
     */
    function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
      var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
      var i = 0;
      for (var j = 0, jj = endss.length; j < jj; ++j) {
        var ends = endss[j];
        coordinatesss[i++] = inflateCoordinatesArray(
          flatCoordinates, offset, ends, stride, coordinatesss[i]);
        offset = ends[ends.length - 1];
      }
      coordinatesss.length = i;
      return coordinatesss;
    }

    /**
     * @module ol/geom/flat/simplify
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @return {number} Simplified offset.
     */
    function douglasPeucker(flatCoordinates, offset, end,
      stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      var n = (end - offset) / stride;
      if (n < 3) {
        for (; offset < end; offset += stride) {
          simplifiedFlatCoordinates[simplifiedOffset++] =
              flatCoordinates[offset];
          simplifiedFlatCoordinates[simplifiedOffset++] =
              flatCoordinates[offset + 1];
        }
        return simplifiedOffset;
      }
      /** @type {Array.<number>} */
      var markers = new Array(n);
      markers[0] = 1;
      markers[n - 1] = 1;
      /** @type {Array.<number>} */
      var stack = [offset, end - stride];
      var index = 0;
      while (stack.length > 0) {
        var last = stack.pop();
        var first = stack.pop();
        var maxSquaredDistance = 0;
        var x1 = flatCoordinates[first];
        var y1 = flatCoordinates[first + 1];
        var x2 = flatCoordinates[last];
        var y2 = flatCoordinates[last + 1];
        for (var i = first + stride; i < last; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];
          var squaredDistance$$1 = squaredSegmentDistance(
            x, y, x1, y1, x2, y2);
          if (squaredDistance$$1 > maxSquaredDistance) {
            index = i;
            maxSquaredDistance = squaredDistance$$1;
          }
        }
        if (maxSquaredDistance > squaredTolerance) {
          markers[(index - offset) / stride] = 1;
          if (first + stride < index) {
            stack.push(first, index);
          }
          if (index + stride < last) {
            stack.push(index, last);
          }
        }
      }
      for (var i$1 = 0; i$1 < n; ++i$1) {
        if (markers[i$1]) {
          simplifiedFlatCoordinates[simplifiedOffset++] =
              flatCoordinates[offset + i$1 * stride];
          simplifiedFlatCoordinates[simplifiedOffset++] =
              flatCoordinates[offset + i$1 * stride + 1];
        }
      }
      return simplifiedOffset;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array.<number>} simplifiedEnds Simplified ends.
     * @return {number} Simplified offset.
     */
    function douglasPeuckerArray(flatCoordinates, offset,
      ends, stride, squaredTolerance, simplifiedFlatCoordinates,
      simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        simplifiedOffset = douglasPeucker(
          flatCoordinates, offset, end, stride, squaredTolerance,
          simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
      }
      return simplifiedOffset;
    }


    /**
     * @param {number} value Value.
     * @param {number} tolerance Tolerance.
     * @return {number} Rounded value.
     */
    function snap(value, tolerance) {
      return tolerance * Math.round(value / tolerance);
    }


    /**
     * Simplifies a line string using an algorithm designed by Tim Schaub.
     * Coordinates are snapped to the nearest value in a virtual grid and
     * consecutive duplicate coordinates are discarded.  This effectively preserves
     * topology as the simplification of any subsection of a line string is
     * independent of the rest of the line string.  This means that, for examples,
     * the common edge between two polygons will be simplified to the same line
     * string independently in both polygons.  This implementation uses a single
     * pass over the coordinates and eliminates intermediate collinear points.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @return {number} Simplified offset.
     */
    function quantize(flatCoordinates, offset, end, stride,
      tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      // do nothing if the line is empty
      if (offset == end) {
        return simplifiedOffset;
      }
      // snap the first coordinate (P1)
      var x1 = snap(flatCoordinates[offset], tolerance);
      var y1 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;
      // add the first coordinate to the output
      simplifiedFlatCoordinates[simplifiedOffset++] = x1;
      simplifiedFlatCoordinates[simplifiedOffset++] = y1;
      // find the next coordinate that does not snap to the same value as the first
      // coordinate (P2)
      var x2, y2;
      do {
        x2 = snap(flatCoordinates[offset], tolerance);
        y2 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        if (offset == end) {
          // all coordinates snap to the same value, the line collapses to a point
          // push the last snapped value anyway to ensure that the output contains
          // at least two points
          // FIXME should we really return at least two points anyway?
          simplifiedFlatCoordinates[simplifiedOffset++] = x2;
          simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          return simplifiedOffset;
        }
      } while (x2 == x1 && y2 == y1);
      while (offset < end) {
        // snap the next coordinate (P3)
        var x3 = snap(flatCoordinates[offset], tolerance);
        var y3 = snap(flatCoordinates[offset + 1], tolerance);
        offset += stride;
        // skip P3 if it is equal to P2
        if (x3 == x2 && y3 == y2) {
          continue;
        }
        // calculate the delta between P1 and P2
        var dx1 = x2 - x1;
        var dy1 = y2 - y1;
        // calculate the delta between P3 and P1
        var dx2 = x3 - x1;
        var dy2 = y3 - y1;
        // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
        // P1 in the same direction then P2 is on the straight line between P1 and
        // P3
        if ((dx1 * dy2 == dy1 * dx2) &&
            ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
            ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
          // discard P2 and set P2 = P3
          x2 = x3;
          y2 = y3;
          continue;
        }
        // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
        // between P3 and P1 or on the opposite half of the line to P2.  add P2,
        // and continue with P1 = P2 and P2 = P3
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        x1 = x2;
        y1 = y2;
        x2 = x3;
        y2 = y3;
      }
      // add the last point (P2)
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array.<number>} simplifiedEnds Simplified ends.
     * @return {number} Simplified offset.
     */
    function quantizeArray(
      flatCoordinates, offset, ends, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        simplifiedOffset = quantize(
          flatCoordinates, offset, end, stride,
          tolerance,
          simplifiedFlatCoordinates, simplifiedOffset);
        simplifiedEnds.push(simplifiedOffset);
        offset = end;
      }
      return simplifiedOffset;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} tolerance Tolerance.
     * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
     *     coordinates.
     * @param {number} simplifiedOffset Simplified offset.
     * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
     * @return {number} Simplified offset.
     */
    function quantizeMultiArray(
      flatCoordinates, offset, endss, stride,
      tolerance,
      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        var simplifiedEnds = [];
        simplifiedOffset = quantizeArray(
          flatCoordinates, offset, ends, stride,
          tolerance,
          simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
        simplifiedEndss.push(simplifiedEnds);
        offset = ends[ends.length - 1];
      }
      return simplifiedOffset;
    }

    /**
     * @module ol/geom/LinearRing
     */

    /**
     * @classdesc
     * Linear ring geometry. Only used as part of polygon; cannot be rendered
     * on its own.
     *
     * @api
     */
    var LinearRing = (function (SimpleGeometry$$1) {
      function LinearRing(coordinates, opt_layout) {

        SimpleGeometry$$1.call(this);

        /**
         * @private
         * @type {number}
         */
        this.maxDelta_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDeltaRevision_ = -1;

        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
          this.setFlatCoordinates(opt_layout, coordinates);
        } else {
          this.setCoordinates(coordinates, opt_layout);
        }

      }

      if ( SimpleGeometry$$1 ) LinearRing.__proto__ = SimpleGeometry$$1;
      LinearRing.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      LinearRing.prototype.constructor = LinearRing;

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/LinearRing} Clone.
       * @override
       * @api
       */
      LinearRing.prototype.clone = function clone$$1 () {
        return new LinearRing(this.flatCoordinates.slice(), this.layout);
      };

      /**
       * @inheritDoc
       */
      LinearRing.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(maxSquaredDelta(
            this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };

      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      LinearRing.prototype.getArea = function getArea$$1 () {
        return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };

      /**
       * Return the coordinates of the linear ring.
       * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
       * @override
       * @api
       */
      LinearRing.prototype.getCoordinates = function getCoordinates () {
        return inflateCoordinates(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };

      /**
       * @inheritDoc
       */
      LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
      };

      /**
       * @inheritDoc
       * @api
       */
      LinearRing.prototype.getType = function getType () {
        return GeometryType.LINEAR_RING;
      };

      /**
       * @inheritDoc
       */
      LinearRing.prototype.intersectsExtent = function intersectsExtent (extent) {};

      /**
       * Set the coordinates of the linear ring.
       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      LinearRing.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      };

      return LinearRing;
    }(SimpleGeometry));

    /**
     * @module ol/geom/Point
     */

    /**
     * @classdesc
     * Point geometry.
     *
     * @api
     */
    var Point = (function (SimpleGeometry$$1) {
      function Point(coordinates, opt_layout) {
        SimpleGeometry$$1.call(this);
        this.setCoordinates(coordinates, opt_layout);
      }

      if ( SimpleGeometry$$1 ) Point.__proto__ = SimpleGeometry$$1;
      Point.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      Point.prototype.constructor = Point;

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/Point} Clone.
       * @override
       * @api
       */
      Point.prototype.clone = function clone$$1 () {
        var point = new Point(this.flatCoordinates.slice(), this.layout);
        return point;
      };

      /**
       * @inheritDoc
       */
      Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var squaredDistance$$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
        if (squaredDistance$$1 < minSquaredDistance) {
          var stride = this.stride;
          for (var i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
          closestPoint.length = stride;
          return squaredDistance$$1;
        } else {
          return minSquaredDistance;
        }
      };

      /**
       * Return the coordinate of the point.
       * @return {module:ol/coordinate~Coordinate} Coordinates.
       * @override
       * @api
       */
      Point.prototype.getCoordinates = function getCoordinates () {
        return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
      };

      /**
       * @inheritDoc
       */
      Point.prototype.computeExtent = function computeExtent (extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      };

      /**
       * @inheritDoc
       * @api
       */
      Point.prototype.getType = function getType () {
        return GeometryType.POINT;
      };

      /**
       * @inheritDoc
       * @api
       */
      Point.prototype.intersectsExtent = function intersectsExtent (extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      };

      /**
       * @inheritDoc
       * @api
       */
      Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      };

      return Point;
    }(SimpleGeometry));

    /**
     * @module ol/geom/flat/contains
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} Contains extent.
     */
    function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
      var outside = forEachCorner(extent,
        /**
         * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
         * @return {boolean} Contains (x, y).
         */
        function(coordinate) {
          return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
        });
      return !outside;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
      // http://geomalgorithms.com/a03-_inclusion.html
      // Copyright 2000 softSurfer, 2012 Dan Sunday
      // This code may be freely used and modified for any purpose
      // providing that this copyright notice is included with it.
      // SoftSurfer makes no warranty for this code, and cannot be held
      // liable for any real or imagined damage resulting from its use.
      // Users of this code must verify correctness for their application.
      var wn = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        if (y1 <= y) {
          if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {
            wn++;
          }
        } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {
          wn--;
        }
        x1 = x2;
        y1 = y2;
      }
      return wn !== 0;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
      if (ends.length === 0) {
        return false;
      }
      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
        return false;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
        if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
          return false;
        }
      }
      return true;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
      if (endss.length === 0) {
        return false;
      }
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
          return true;
        }
        offset = ends[ends.length - 1];
      }
      return false;
    }

    /**
     * @module ol/geom/flat/interiorpoint
     */


    /**
     * Calculates a point that is likely to lie in the interior of the linear rings.
     * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array.<number>} flatCenters Flat centers.
     * @param {number} flatCentersOffset Flat center offset.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Destination point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     */
    function getInteriorPointOfArray(flatCoordinates, offset,
      ends, stride, flatCenters, flatCentersOffset, opt_dest) {
      var i, ii, x, x1, x2, y1, y2;
      var y = flatCenters[flatCentersOffset + 1];
      /** @type {Array.<number>} */
      var intersections = [];
      // Calculate intersections with the horizontal line
      for (var r = 0, rr = ends.length; r < rr; ++r) {
        var end = ends[r];
        x1 = flatCoordinates[end - stride];
        y1 = flatCoordinates[end - stride + 1];
        for (i = offset; i < end; i += stride) {
          x2 = flatCoordinates[i];
          y2 = flatCoordinates[i + 1];
          if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
            x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
            intersections.push(x);
          }
          x1 = x2;
          y1 = y2;
        }
      }
      // Find the longest segment of the horizontal line that has its center point
      // inside the linear ring.
      var pointX = NaN;
      var maxSegmentLength = -Infinity;
      intersections.sort(numberSafeCompareFunction);
      x1 = intersections[0];
      for (i = 1, ii = intersections.length; i < ii; ++i) {
        x2 = intersections[i];
        var segmentLength = Math.abs(x2 - x1);
        if (segmentLength > maxSegmentLength) {
          x = (x1 + x2) / 2;
          if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
            pointX = x;
            maxSegmentLength = segmentLength;
          }
        }
        x1 = x2;
      }
      if (isNaN(pointX)) {
        // There is no horizontal line that has its center point inside the linear
        // ring.  Use the center of the the linear ring's extent.
        pointX = flatCenters[flatCentersOffset];
      }
      if (opt_dest) {
        opt_dest.push(pointX, y, maxSegmentLength);
        return opt_dest;
      } else {
        return [pointX, y, maxSegmentLength];
      }
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {Array.<number>} flatCenters Flat centers.
     * @return {Array.<number>} Interior points as XYM coordinates, where M is the
     * length of the horizontal intersection that the point belongs to.
     */
    function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
      var interiorPoints = [];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        interiorPoints = getInteriorPointOfArray(flatCoordinates,
          offset, ends, stride, flatCenters, 2 * i, interiorPoints);
        offset = ends[ends.length - 1];
      }
      return interiorPoints;
    }

    /**
     * @module ol/geom/flat/segments
     */


    /**
     * This function calls `callback` for each segment of the flat coordinates
     * array. If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function
     *     called for each segment.
     * @param {S=} opt_this The object to be used as the value of 'this'
     *     within callback.
     * @return {T|boolean} Value.
     * @template T,S
     */
    function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {
      var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var point2 = [];
      var ret;
      for (; (offset + stride) < end; offset += stride) {
        point2[0] = flatCoordinates[offset + stride];
        point2[1] = flatCoordinates[offset + stride + 1];
        ret = callback.call(opt_this, point1, point2);
        if (ret) {
          return ret;
        }
        point1[0] = point2[0];
        point1[1] = point2[1];
      }
      return false;
    }

    /**
     * @module ol/geom/flat/intersectsextent
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
      var coordinatesExtent = extendFlatCoordinates(
        createEmpty(), flatCoordinates, offset, end, stride);
      if (!intersects(extent, coordinatesExtent)) {
        return false;
      }
      if (containsExtent(extent, coordinatesExtent)) {
        return true;
      }
      if (coordinatesExtent[0] >= extent[0] &&
          coordinatesExtent[2] <= extent[2]) {
        return true;
      }
      if (coordinatesExtent[1] >= extent[1] &&
          coordinatesExtent[3] <= extent[3]) {
        return true;
      }
      return forEach(flatCoordinates, offset, end, stride,
        /**
         * @param {module:ol/coordinate~Coordinate} point1 Start point.
         * @param {module:ol/coordinate~Coordinate} point2 End point.
         * @return {boolean} `true` if the segment and the extent intersect,
         *     `false` otherwise.
         */
        function(point1, point2) {
          return intersectsSegment(extent, point1, point2);
        });
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        if (intersectsLineString(
          flatCoordinates, offset, ends[i], stride, extent)) {
          return true;
        }
        offset = ends[i];
      }
      return false;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
      if (intersectsLineString(
        flatCoordinates, offset, end, stride, extent)) {
        return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
        return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
        return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
        return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
        return true;
      }
      return false;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
      if (!intersectsLinearRing(
        flatCoordinates, offset, ends[0], stride, extent)) {
        return false;
      }
      if (ends.length === 1) {
        return true;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
        if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
          return false;
        }
      }
      return true;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {boolean} True if the geometry and the extent intersect.
     */
    function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        if (intersectsLinearRingArray(
          flatCoordinates, offset, ends, stride, extent)) {
          return true;
        }
        offset = ends[ends.length - 1];
      }
      return false;
    }

    /**
     * @module ol/geom/flat/reverse
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     */
    function coordinates(flatCoordinates, offset, end, stride) {
      while (offset < end - stride) {
        for (var i = 0; i < stride; ++i) {
          var tmp = flatCoordinates[offset + i];
          flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
          flatCoordinates[end - stride + i] = tmp;
        }
        offset += stride;
        end -= stride;
      }
    }

    /**
     * @module ol/geom/flat/orient
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {boolean} Is clockwise.
     */
    function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
      // http://tinyurl.com/clockwise-method
      // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
      var edge = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        edge += (x2 - x1) * (y2 + y1);
        x1 = x2;
        y1 = y2;
      }
      return edge > 0;
    }


    /**
     * Determines if linear rings are oriented.  By default, left-hand orientation
     * is tested (first ring must be clockwise, remaining rings counter-clockwise).
     * To test for right-hand orientation, use the `opt_right` argument.
     *
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Test for right-hand orientation
     *     (counter-clockwise exterior ring and clockwise interior rings).
     * @return {boolean} Rings are correctly oriented.
     */
    function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(
          flatCoordinates, offset, end, stride);
        if (i === 0) {
          if ((right && isClockwise) || (!right && !isClockwise)) {
            return false;
          }
        } else {
          if ((right && !isClockwise) || (!right && isClockwise)) {
            return false;
          }
        }
        offset = end;
      }
      return true;
    }


    /**
     * Determines if linear rings are oriented.  By default, left-hand orientation
     * is tested (first ring must be clockwise, remaining rings counter-clockwise).
     * To test for right-hand orientation, use the `opt_right` argument.
     *
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Array of array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Test for right-hand orientation
     *     (counter-clockwise exterior ring and clockwise interior rings).
     * @return {boolean} Rings are correctly oriented.
     */
    function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        if (!linearRingIsOriented(
          flatCoordinates, offset, endss[i], stride, opt_right)) {
          return false;
        }
      }
      return true;
    }


    /**
     * Orient coordinates in a flat array of linear rings.  By default, rings
     * are oriented following the left-hand rule (clockwise for exterior and
     * counter-clockwise for interior rings).  To orient according to the
     * right-hand rule, use the `opt_right` argument.
     *
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Follow the right-hand rule for orientation.
     * @return {number} End.
     */
    function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        var isClockwise = linearRingIsClockwise(
          flatCoordinates, offset, end, stride);
        var reverse = i === 0 ?
          (right && isClockwise) || (!right && !isClockwise) :
          (right && !isClockwise) || (!right && isClockwise);
        if (reverse) {
          coordinates(flatCoordinates, offset, end, stride);
        }
        offset = end;
      }
      return offset;
    }


    /**
     * Orient coordinates in a flat array of linear rings.  By default, rings
     * are oriented following the left-hand rule (clockwise for exterior and
     * counter-clockwise for interior rings).  To orient according to the
     * right-hand rule, use the `opt_right` argument.
     *
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Array of array of end indexes.
     * @param {number} stride Stride.
     * @param {boolean=} opt_right Follow the right-hand rule for orientation.
     * @return {number} End.
     */
    function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        offset = orientLinearRings(
          flatCoordinates, offset, endss[i], stride, opt_right);
      }
      return offset;
    }

    /**
     * @module ol/geom/Polygon
     */

    /**
     * @classdesc
     * Polygon geometry.
     *
     * @api
     */
    var Polygon = (function (SimpleGeometry$$1) {
      function Polygon(coordinates, opt_layout, opt_ends) {

        SimpleGeometry$$1.call(this);

        /**
         * @type {Array.<number>}
         * @private
         */
        this.ends_ = [];

        /**
         * @private
         * @type {number}
         */
        this.flatInteriorPointRevision_ = -1;

        /**
         * @private
         * @type {module:ol/coordinate~Coordinate}
         */
        this.flatInteriorPoint_ = null;

        /**
         * @private
         * @type {number}
         */
        this.maxDelta_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDeltaRevision_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.orientedRevision_ = -1;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.orientedFlatCoordinates_ = null;

        if (opt_layout !== undefined && opt_ends) {
          this.setFlatCoordinates(opt_layout, coordinates);
          this.ends_ = opt_ends;
        } else {
          this.setCoordinates(coordinates, opt_layout);
        }

      }

      if ( SimpleGeometry$$1 ) Polygon.__proto__ = SimpleGeometry$$1;
      Polygon.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      Polygon.prototype.constructor = Polygon;

      /**
       * Append the passed linear ring to this polygon.
       * @param {module:ol/geom/LinearRing} linearRing Linear ring.
       * @api
       */
      Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing$$1) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing$$1.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, linearRing$$1.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      };

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/Polygon} Clone.
       * @override
       * @api
       */
      Polygon.prototype.clone = function clone$$1 () {
        return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };

      /**
       * @inheritDoc
       */
      Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(
            this.flatCoordinates, 0, this.ends_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates, 0, this.ends_, this.stride,
          this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };

      /**
       * @inheritDoc
       */
      Polygon.prototype.containsXY = function containsXY$$1 (x, y) {
        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
      };

      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      Polygon.prototype.getArea = function getArea$$1 () {
        return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      };

      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.
       * @override
       * @api
       */
      Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(
            flatCoordinates, 0, this.ends_, this.stride, opt_right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }

        return inflateCoordinatesArray(
          flatCoordinates, 0, this.ends_, this.stride);
      };

      /**
       * @return {Array.<number>} Ends.
       */
      Polygon.prototype.getEnds = function getEnds () {
        return this.ends_;
      };

      /**
       * @return {Array.<number>} Interior point.
       */
      Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          var flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,
            flatCenter, 0);
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return this.flatInteriorPoint_;
      };

      /**
       * Return an interior point of the polygon.
       * @return {module:ol/geom/Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      Polygon.prototype.getInteriorPoint = function getInteriorPoint () {
        return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
      };

      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      Polygon.prototype.getLinearRingCount = function getLinearRingCount () {
        return this.ends_.length;
      };

      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {module:ol/geom/LinearRing} Linear ring.
       * @api
       */
      Polygon.prototype.getLinearRing = function getLinearRing (index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LinearRing(this.flatCoordinates.slice(
          index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };

      /**
       * Return the linear rings of the polygon.
       * @return {Array.<module:ol/geom/LinearRing>} Linear rings.
       * @api
       */
      Polygon.prototype.getLinearRings = function getLinearRings () {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var linearRings$$1 = [];
        var offset$$1 = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var linearRing$$1 = new LinearRing(flatCoordinates.slice(offset$$1, end), layout);
          linearRings$$1.push(linearRing$$1);
          offset$$1 = end;
        }
        return linearRings$$1;
      };

      /**
       * @return {Array.<number>} Oriented flat coordinates.
       */
      Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
        if (this.orientedRevision_ != this.getRevision()) {
          var flatCoordinates = this.flatCoordinates;
          if (linearRingIsOriented(
            flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length =
                orientLinearRings(
                  this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
          }
          this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
      };

      /**
       * @inheritDoc
       */
      Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates, 0, this.ends_, this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };

      /**
       * @inheritDoc
       * @api
       */
      Polygon.prototype.getType = function getType () {
        return GeometryType.POLYGON;
      };

      /**
       * @inheritDoc
       * @api
       */
      Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
      };

      /**
       * Set the coordinates of the polygon.
       * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        var ends = deflateCoordinatesArray(
          this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      };

      return Polygon;
    }(SimpleGeometry));


    /**
     * Create a polygon from an extent. The layout used is `XY`.
     * @param {module:ol/extent~Extent} extent The extent.
     * @return {module:ol/geom/Polygon} The polygon.
     * @api
     */
    function fromExtent(extent) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var flatCoordinates =
          [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
      return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);
    }


    /**
     * Create a regular polygon from a circle.
     * @param {module:ol/geom/Circle} circle Circle geometry.
     * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
     * @param {number=} opt_angle Start angle for the first vertex of the polygon in
     *     radians. Default is 0.
     * @return {module:ol/geom/Polygon} Polygon geometry.
     * @api
     */
    function fromCircle(circle, opt_sides, opt_angle) {
      var sides = opt_sides ? opt_sides : 32;
      var stride = circle.getStride();
      var layout = circle.getLayout();
      var center = circle.getCenter();
      var arrayLength = stride * (sides + 1);
      var flatCoordinates = new Array(arrayLength);
      for (var i = 0; i < arrayLength; i += stride) {
        flatCoordinates[i] = 0;
        flatCoordinates[i + 1] = 0;
        for (var j = 2; j < stride; j++) {
          flatCoordinates[i + j] = center[j];
        }
      }
      var ends = [flatCoordinates.length];
      var polygon = new Polygon(flatCoordinates, layout, ends);
      makeRegular(polygon, center, circle.getRadius(), opt_angle);
      return polygon;
    }


    /**
     * Modify the coordinates of a polygon to make it a regular polygon.
     * @param {module:ol/geom/Polygon} polygon Polygon geometry.
     * @param {module:ol/coordinate~Coordinate} center Center of the regular polygon.
     * @param {number} radius Radius of the regular polygon.
     * @param {number=} opt_angle Start angle for the first vertex of the polygon in
     *     radians. Default is 0.
     */
    function makeRegular(polygon, center, radius, opt_angle) {
      var flatCoordinates = polygon.getFlatCoordinates();
      var stride = polygon.getStride();
      var sides = flatCoordinates.length / stride - 1;
      var startAngle = opt_angle ? opt_angle : 0;
      for (var i = 0; i <= sides; ++i) {
        var offset$$1 = i * stride;
        var angle = startAngle + (modulo(i, sides) * 2 * Math.PI / sides);
        flatCoordinates[offset$$1] = center[0] + (radius * Math.cos(angle));
        flatCoordinates[offset$$1 + 1] = center[1] + (radius * Math.sin(angle));
      }
      polygon.changed();
    }

    /**
     * @module ol/View
     */


    /**
     * An animation configuration
     *
     * @typedef {Object} Animation
     * @property {module:ol/coordinate~Coordinate} [sourceCenter]
     * @property {module:ol/coordinate~Coordinate} [targetCenter]
     * @property {number} [sourceResolution]
     * @property {number} [targetResolution]
     * @property {number} [sourceRotation]
     * @property {number} [targetRotation]
     * @property {module:ol/coordinate~Coordinate} [anchor]
     * @property {number} start
     * @property {number} duration
     * @property {boolean} complete
     * @property {function(number):number} easing
     * @property {function(boolean)} callback
     */


    /**
     * @typedef {Object} Constraints
     * @property {module:ol/centerconstraint~Type} center
     * @property {module:ol/resolutionconstraint~Type} resolution
     * @property {module:ol/rotationconstraint~Type} rotation
     */


    /**
     * @typedef {Object} FitOptions
     * @property {module:ol/size~Size} [size] The size in pixels of the box to fit
     * the extent into. Default is the current size of the first map in the DOM that
     * uses this view, or `[100, 100]` if no such map is found.
     * @property {!Array.<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
     * cleared inside the view. Values in the array are top, right, bottom and left
     * padding.
     * @property {boolean} [constrainResolution=true] Constrain the resolution.
     * @property {boolean} [nearest=false] If `constrainResolution` is `true`, get
     * the nearest extent instead of the closest that actually fits the view.
     * @property {number} [minResolution=0] Minimum resolution that we zoom to.
     * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
     * `minResolution` is given, this property is ignored.
     * @property {number} [duration] The duration of the animation in milliseconds.
     * By default, there is no animation to the target extent.
     * @property {function(number):number} [easing] The easing function used during
     * the animation (defaults to {@link module:ol/easing~inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     * @property {function(boolean)} [callback] Function called when the view is in
     * its final position. The callback will be called with `true` if the animation
     * series completed on its own or `false` if it was cancelled.
     */


    /**
     * @typedef {Object} ViewOptions
     * @property {module:ol/coordinate~Coordinate} [center] The initial center for
     * the view. The coordinate system for the center is specified with the
     * `projection` option. Layer sources will not be fetched if this is not set,
     * but the center can be set later with {@link #setCenter}.
     * @property {boolean|number} [constrainRotation=true] Rotation constraint.
     * `false` means no constraint. `true` means no constraint, but snap to zero
     * near zero. A number constrains the rotation to that number of values. For
     * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
     * @property {boolean} [enableRotation=true] Enable rotation.
     * If `false`, a rotation constraint that always sets the rotation to zero is
     * used. The `constrainRotation` option has no effect if `enableRotation` is
     * `false`.
     * @property {module:ol/extent~Extent} [extent] The extent that constrains the
     * center, in other words, center cannot be set outside this extent.
     * @property {number} [maxResolution] The maximum resolution used to determine
     * the resolution constraint. It is used together with `minResolution` (or
     * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
     * that the projection's validity extent fits in a 256x256 px tile. If the
     * projection is Spherical Mercator (the default) then `maxResolution` defaults
     * to `40075016.68557849 / 256 = 156543.03392804097`.
     * @property {number} [minResolution] The minimum resolution used to determine
     * the resolution constraint.  It is used together with `maxResolution` (or
     * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
     * zoom levels (with a factor of 2). If the projection is Spherical Mercator
     * (the default) then `minResolution` defaults to
     * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
     * @property {number} [maxZoom=28] The maximum zoom level used to determine the
     * resolution constraint. It is used together with `minZoom` (or
     * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
     * provided, it is given precedence over `maxZoom`.
     * @property {number} [minZoom=0] The minimum zoom level used to determine the
     * resolution constraint. It is used together with `maxZoom` (or
     * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
     * provided, it is given precedence over `minZoom`.
     * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] The
     * projection. The default is Spherical Mercator.
     * @property {number} [resolution] The initial resolution for the view. The
     * units are `projection` units per pixel (e.g. meters per pixel). An
     * alternative to setting this is to set `zoom`. Layer sources will not be
     * fetched if neither this nor `zoom` are defined, but they can be set later
     * with {@link #setZoom} or {@link #setResolution}.
     * @property {Array.<number>} [resolutions] Resolutions to determine the
     * resolution constraint. If set the `maxResolution`, `minResolution`,
     * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
     * @property {number} [rotation=0] The initial rotation for the view in radians
     * (positive rotation clockwise, 0 means North).
     * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
     * level used to calculate the initial resolution for the view. The initial
     * resolution is determined using the {@link #constrainResolution} method.
     * @property {number} [zoomFactor=2] The zoom factor used to determine the
     * resolution constraint.
     */


    /**
     * @typedef {Object} AnimationOptions
     * @property {module:ol/coordinate~Coordinate|undefined} center The center of the view at the end of
     * the animation.
     * @property {number|undefined} zoom The zoom level of the view at the end of the
     * animation. This takes precedence over `resolution`.
     * @property {number|undefined} resolution The resolution of the view at the end
     * of the animation.  If `zoom` is also provided, this option will be ignored.
     * @property {number|undefined} rotation The rotation of the view at the end of
     * the animation.
     * @property {module:ol/coordinate~Coordinate|undefined} anchor Optional anchor to remained fixed
     * during a rotation or resolution animation.
     * @property {number} [duration=1000] The duration of the animation in milliseconds.
     * @property {function(number):number} [easing] The easing function used
     * during the animation (defaults to {@link module:ol/easing~inAndOut}).
     * The function will be called for each frame with a number representing a
     * fraction of the animation's duration.  The function should return a number
     * between 0 and 1 representing the progress toward the destination state.
     */


    /**
     * @typedef {Object} State
     * @property {module:ol/coordinate~Coordinate} center
     * @property {module:ol/proj/Projection} projection
     * @property {number} resolution
     * @property {number} rotation
     * @property {number} zoom
     */


    /**
     * Default min zoom level for the map view.
     * @type {number}
     */
    var DEFAULT_MIN_ZOOM = 0;


    /**
     * @classdesc
     * A View object represents a simple 2D view of the map.
     *
     * This is the object to act upon to change the center, resolution,
     * and rotation of the map.
     *
     * ### The view states
     *
     * An View is determined by three states: `center`, `resolution`,
     * and `rotation`. Each state has a corresponding getter and setter, e.g.
     * `getCenter` and `setCenter` for the `center` state.
     *
     * An View has a `projection`. The projection determines the
     * coordinate system of the center, and its units determine the units of the
     * resolution (projection units per pixel). The default projection is
     * Spherical Mercator (EPSG:3857).
     *
     * ### The constraints
     *
     * `setCenter`, `setResolution` and `setRotation` can be used to change the
     * states of the view. Any value can be passed to the setters. And the value
     * that is passed to a setter will effectively be the value set in the view,
     * and returned by the corresponding getter.
     *
     * But a View object also has a *resolution constraint*, a
     * *rotation constraint* and a *center constraint*.
     *
     * As said above, no constraints are applied when the setters are used to set
     * new states for the view. Applying constraints is done explicitly through
     * the use of the `constrain*` functions (`constrainResolution` and
     * `constrainRotation` and `constrainCenter`).
     *
     * The main users of the constraints are the interactions and the
     * controls. For example, double-clicking on the map changes the view to
     * the "next" resolution. And releasing the fingers after pinch-zooming
     * snaps to the closest resolution (with an animation).
     *
     * The *resolution constraint* snaps to specific resolutions. It is
     * determined by the following options: `resolutions`, `maxResolution`,
     * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
     * options are ignored. See documentation for each option for more
     * information.
     *
     * The *rotation constraint* snaps to specific angles. It is determined
     * by the following options: `enableRotation` and `constrainRotation`.
     * By default the rotation value is snapped to zero when approaching the
     * horizontal.
     *
     * The *center constraint* is determined by the `extent` option. By
     * default the center is not constrained at all.
     *
      * @api
     */
    var View = (function (BaseObject$$1) {
      function View(opt_options) {
        BaseObject$$1.call(this);

        var options = assign({}, opt_options);

        /**
         * @private
         * @type {Array.<number>}
         */
        this.hints_ = [0, 0];

        /**
         * @private
         * @type {Array.<Array.<module:ol/View~Animation>>}
         */
        this.animations_ = [];

        /**
         * @private
         * @type {number|undefined}
         */
        this.updateAnimationKey_;

        this.updateAnimations_ = this.updateAnimations_.bind(this);

        /**
         * @private
         * @const
         * @type {module:ol/proj/Projection}
         */
        this.projection_ = createProjection(options.projection, 'EPSG:3857');

        this.applyOptions_(options);
      }

      if ( BaseObject$$1 ) View.__proto__ = BaseObject$$1;
      View.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      View.prototype.constructor = View;

      /**
       * Set up the view with the given options.
       * @param {module:ol/View~ViewOptions} options View options.
       */
      View.prototype.applyOptions_ = function applyOptions_ (options) {

        /**
         * @type {Object.<string, *>}
         */
        var properties = {};
        properties[ViewProperty.CENTER] = options.center !== undefined ?
          options.center : null;

        var resolutionConstraintInfo = createResolutionConstraint(options);

        /**
         * @private
         * @type {number}
         */
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;

        /**
         * @private
         * @type {number}
         */
        this.minResolution_ = resolutionConstraintInfo.minResolution;

        /**
         * @private
         * @type {number}
         */
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

        /**
         * @private
         * @type {Array.<number>|undefined}
         */
        this.resolutions_ = options.resolutions;

        /**
         * @private
         * @type {number}
         */
        this.minZoom_ = resolutionConstraintInfo.minZoom;

        var centerConstraint = createCenterConstraint(options);
        var resolutionConstraint = resolutionConstraintInfo.constraint;
        var rotationConstraint = createRotationConstraint(options);

        /**
         * @private
         * @type {module:ol/View~Constraints}
         */
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };

        if (options.resolution !== undefined) {
          properties[ViewProperty.RESOLUTION] = options.resolution;
        } else if (options.zoom !== undefined) {
          properties[ViewProperty.RESOLUTION] = this.constrainResolution(
            this.maxResolution_, options.zoom - this.minZoom_);

          if (this.resolutions_) { // in case map zoom is out of min/max zoom range
            properties[ViewProperty.RESOLUTION] = clamp(
              Number(this.getResolution() || properties[ViewProperty.RESOLUTION]),
              this.minResolution_, this.maxResolution_);
          }
        }
        properties[ViewProperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;
        this.setProperties(properties);

        /**
         * @private
         * @type {module:ol/View~ViewOptions}
         */
        this.options_ = options;

      };

      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {module:ol/View~ViewOptions} newOptions New options to be applied.
       * @return {module:ol/View~ViewOptions} New options updated with the current view state.
       */
      View.prototype.getUpdatedOptions_ = function getUpdatedOptions_ (newOptions) {
        var options = assign({}, this.options_);

        // preserve resolution (or zoom)
        if (options.resolution !== undefined) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }

        // preserve center
        options.center = this.getCenter();

        // preserve rotation
        options.rotation = this.getRotation();

        return assign({}, options, newOptions);
      };

      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(module:ol/View~AnimationOptions|function(boolean))} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      View.prototype.animate = function animate (var_args) {
        var arguments$1 = arguments;
        var this$1 = this;

        var animationCount = arguments.length;
        var callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        if (!this.isDef()) {
          // if view properties are not yet set, shortcut to the final state
          var state = arguments[animationCount - 1];
          if (state.center) {
            this.setCenter(state.center);
          }
          if (state.zoom !== undefined) {
            this.setZoom(state.zoom);
          }
          if (state.rotation !== undefined) {
            this.setRotation(state.rotation);
          }
          if (callback) {
            setTimeout(function() {
              callback(true);
            }, 0);
          }
          return;
        }
        var start = Date.now();
        var center = this.getCenter().slice();
        var resolution = this.getResolution();
        var rotation = this.getRotation();
        var series = [];
        for (var i = 0; i < animationCount; ++i) {
          var options = /** @type {module:ol/View~AnimationOptions} */ (arguments$1[i]);

          var animation = /** @type {module:ol/View~Animation} */ ({
            start: start,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== undefined ? options.duration : 1000,
            easing: options.easing || inAndOut
          });

          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center;
            center = animation.targetCenter;
          }

          if (options.zoom !== undefined) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this$1.constrainResolution(
              this$1.maxResolution_, options.zoom - this$1.minZoom_, 0);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }

          if (options.rotation !== undefined) {
            animation.sourceRotation = rotation;
            var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }

          animation.callback = callback;

          // check if animation is a no-op
          if (isNoopAnimation(animation)) {
            animation.complete = true;
            // we still push it onto the series for callback handling
          } else {
            start += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint.ANIMATING, 1);
        this.updateAnimations_();
      };

      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      View.prototype.getAnimating = function getAnimating () {
        return this.hints_[ViewHint.ANIMATING] > 0;
      };

      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      View.prototype.getInteracting = function getInteracting () {
        return this.hints_[ViewHint.INTERACTING] > 0;
      };

      /**
       * Cancel any ongoing animations.
       * @api
       */
      View.prototype.cancelAnimations = function cancelAnimations () {
        var this$1 = this;

        this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
        for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
          var series = this$1.animations_[i];
          if (series[0].callback) {
            series[0].callback(false);
          }
        }
        this.animations_.length = 0;
      };

      /**
       * Update all animations.
       */
      View.prototype.updateAnimations_ = function updateAnimations_ () {
        var this$1 = this;

        if (this.updateAnimationKey_ !== undefined) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = undefined;
        }
        if (!this.getAnimating()) {
          return;
        }
        var now = Date.now();
        var more = false;
        for (var i = this.animations_.length - 1; i >= 0; --i) {
          var series = this$1.animations_[i];
          var seriesComplete = true;
          for (var j = 0, jj = series.length; j < jj; ++j) {
            var animation = series[j];
            if (animation.complete) {
              continue;
            }
            var elapsed = now - animation.start;
            var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            var progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              var x0 = animation.sourceCenter[0];
              var y0 = animation.sourceCenter[1];
              var x1 = animation.targetCenter[0];
              var y1 = animation.targetCenter[1];
              var x = x0 + progress * (x1 - x0);
              var y = y0 + progress * (y1 - y0);
              this$1.set(ViewProperty.CENTER, [x, y]);
            }
            if (animation.sourceResolution && animation.targetResolution) {
              var resolution = progress === 1 ?
                animation.targetResolution :
                animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                this$1.set(ViewProperty.CENTER,
                  this$1.calculateCenterZoom(resolution, animation.anchor));
              }
              this$1.set(ViewProperty.RESOLUTION, resolution);
            }
            if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
              var rotation = progress === 1 ?
                modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI :
                animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                this$1.set(ViewProperty.CENTER,
                  this$1.calculateCenterRotate(rotation, animation.anchor));
              }
              this$1.set(ViewProperty.ROTATION, rotation);
            }
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this$1.animations_[i] = null;
            this$1.setHint(ViewHint.ANIMATING, -1);
            var callback = series[0].callback;
            if (callback) {
              setTimeout(function() {
                callback(true);
              }, 0);
            }
          }
        }
        // prune completed series
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === undefined) {
          this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
        }
      };

      /**
       * @param {number} rotation Target rotation.
       * @param {module:ol/coordinate~Coordinate} anchor Rotation anchor.
       * @return {module:ol/coordinate~Coordinate|undefined} Center for rotation and anchor.
       */
      View.prototype.calculateCenterRotate = function calculateCenterRotate (rotation, anchor) {
        var center;
        var currentCenter = this.getCenter();
        if (currentCenter !== undefined) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate(center, rotation - this.getRotation());
          add(center, anchor);
        }
        return center;
      };

      /**
       * @param {number} resolution Target resolution.
       * @param {module:ol/coordinate~Coordinate} anchor Zoom anchor.
       * @return {module:ol/coordinate~Coordinate|undefined} Center for resolution and anchor.
       */
      View.prototype.calculateCenterZoom = function calculateCenterZoom (resolution, anchor) {
        var center;
        var currentCenter = this.getCenter();
        var currentResolution = this.getResolution();
        if (currentCenter !== undefined && currentResolution !== undefined) {
          var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }
        return center;
      };

      /**
       * @private
       * @return {module:ol/size~Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      View.prototype.getSizeFromViewport_ = function getSizeFromViewport_ () {
        var size = [100, 100];
        var selector = '.ol-viewport[data-view="' + getUid(this) + '"]';
        var element = document.querySelector(selector);
        if (element) {
          var metrics = getComputedStyle(element);
          size[0] = parseInt(metrics.width, 10);
          size[1] = parseInt(metrics.height, 10);
        }
        return size;
      };

      /**
       * Get the constrained center of this view.
       * @param {module:ol/coordinate~Coordinate|undefined} center Center.
       * @return {module:ol/coordinate~Coordinate|undefined} Constrained center.
       * @api
       */
      View.prototype.constrainCenter = function constrainCenter (center) {
        return this.constraints_.center(center);
      };

      /**
       * Get the constrained resolution of this view.
       * @param {number|undefined} resolution Resolution.
       * @param {number=} opt_delta Delta. Default is `0`.
       * @param {number=} opt_direction Direction. Default is `0`.
       * @return {number|undefined} Constrained resolution.
       * @api
       */
      View.prototype.constrainResolution = function constrainResolution (resolution, opt_delta, opt_direction) {
        var delta = opt_delta || 0;
        var direction = opt_direction || 0;
        return this.constraints_.resolution(resolution, delta, direction);
      };

      /**
       * Get the constrained rotation of this view.
       * @param {number|undefined} rotation Rotation.
       * @param {number=} opt_delta Delta. Default is `0`.
       * @return {number|undefined} Constrained rotation.
       * @api
       */
      View.prototype.constrainRotation = function constrainRotation (rotation, opt_delta) {
        var delta = opt_delta || 0;
        return this.constraints_.rotation(rotation, delta);
      };

      /**
       * Get the view center.
       * @return {module:ol/coordinate~Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      View.prototype.getCenter = function getCenter$$1 () {
        return (
          /** @type {module:ol/coordinate~Coordinate|undefined} */ (this.get(ViewProperty.CENTER))
        );
      };

      /**
       * @return {module:ol/View~Constraints} Constraints.
       */
      View.prototype.getConstraints = function getConstraints () {
        return this.constraints_;
      };

      /**
       * @param {Array.<number>=} opt_hints Destination array.
       * @return {Array.<number>} Hint.
       */
      View.prototype.getHints = function getHints (opt_hints) {
        if (opt_hints !== undefined) {
          opt_hints[0] = this.hints_[0];
          opt_hints[1] = this.hints_[1];
          return opt_hints;
        } else {
          return this.hints_.slice();
        }
      };

      /**
       * Calculate the extent for the current view state and the passed size.
       * The size is the pixel dimensions of the box into which the calculated extent
       * should fit. In most cases you want to get the extent of the entire map,
       * that is `map.getSize()`.
       * @param {module:ol/size~Size=} opt_size Box pixel size. If not provided, the size of the
       * first map that uses this view will be used.
       * @return {module:ol/extent~Extent} Extent.
       * @api
       */
      View.prototype.calculateExtent = function calculateExtent (opt_size) {
        var size = opt_size || this.getSizeFromViewport_();
        var center = /** @type {!module:ol/coordinate~Coordinate} */ (this.getCenter());
        assert(center, 1); // The view center is not defined
        var resolution = /** @type {!number} */ (this.getResolution());
        assert(resolution !== undefined, 2); // The view resolution is not defined
        var rotation = /** @type {!number} */ (this.getRotation());
        assert(rotation !== undefined, 3); // The view rotation is not defined

        return getForViewAndSize(center, resolution, rotation, size);
      };

      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      View.prototype.getMaxResolution = function getMaxResolution () {
        return this.maxResolution_;
      };

      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      View.prototype.getMinResolution = function getMinResolution () {
        return this.minResolution_;
      };

      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      View.prototype.getMaxZoom = function getMaxZoom () {
        return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
      };

      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      View.prototype.setMaxZoom = function setMaxZoom (zoom) {
        this.applyOptions_(this.getUpdatedOptions_({maxZoom: zoom}));
      };

      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      View.prototype.getMinZoom = function getMinZoom () {
        return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
      };

      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      View.prototype.setMinZoom = function setMinZoom (zoom) {
        this.applyOptions_(this.getUpdatedOptions_({minZoom: zoom}));
      };

      /**
       * Get the view projection.
       * @return {module:ol/proj/Projection} The projection of the view.
       * @api
       */
      View.prototype.getProjection = function getProjection () {
        return this.projection_;
      };

      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.getResolution = function getResolution () {
        return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
      };

      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array.<number>|undefined} The resolutions of the view.
       * @api
       */
      View.prototype.getResolutions = function getResolutions () {
        return this.resolutions_;
      };

      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {module:ol/extent~Extent} extent Extent.
       * @param {module:ol/size~Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      View.prototype.getResolutionForExtent = function getResolutionForExtent (extent, opt_size) {
        var size = opt_size || this.getSizeFromViewport_();
        var xResolution = getWidth(extent) / size[0];
        var yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      };

      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Resolution for value function.
       */
      View.prototype.getResolutionForValueFunction = function getResolutionForValueFunction (opt_power) {
        var power = opt_power || 2;
        var maxResolution = this.maxResolution_;
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            var resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          });
      };

      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.getRotation = function getRotation () {
        return /** @type {number} */ (this.get(ViewProperty.ROTATION));
      };

      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Value for resolution function.
       */
      View.prototype.getValueForResolutionFunction = function getValueForResolutionFunction (opt_power) {
        var power = opt_power || 2;
        var maxResolution = this.maxResolution_;
        var minResolution = this.minResolution_;
        var max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            var value = (Math.log(maxResolution / resolution) / Math.log(power)) / max;
            return value;
          });
      };

      /**
       * @return {module:ol/View~State} View state.
       */
      View.prototype.getState = function getState () {
        var center = /** @type {module:ol/coordinate~Coordinate} */ (this.getCenter());
        var projection = this.getProjection();
        var resolution = /** @type {number} */ (this.getResolution());
        var rotation = this.getRotation();
        return (
          /** @type {module:ol/View~State} */ ({
            center: center.slice(),
            projection: projection !== undefined ? projection : null,
            resolution: resolution,
            rotation: rotation,
            zoom: this.getZoom()
          })
        );
      };

      /**
       * Get the current zoom level.  If you configured your view with a resolutions
       * array (this is rare), this method may return non-integer zoom levels (so
       * the zoom level is not safe to use as an index into a resolutions array).
       * @return {number|undefined} Zoom.
       * @api
       */
      View.prototype.getZoom = function getZoom () {
        var zoom;
        var resolution = this.getResolution();
        if (resolution !== undefined) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      };

      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      View.prototype.getZoomForResolution = function getZoomForResolution (resolution) {
        var offset = this.minZoom_ || 0;
        var max, zoomFactor;
        if (this.resolutions_) {
          var nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      };

      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      View.prototype.getResolutionForZoom = function getResolutionForZoom (zoom) {
        return /** @type {number} */ (this.constrainResolution(
          this.maxResolution_, zoom - this.minZoom_, 0));
      };

      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {module:ol/geom/SimpleGeometry|module:ol/extent~Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {module:ol/View~FitOptions=} opt_options Options.
       * @api
       */
      View.prototype.fit = function fit (geometryOrExtent, opt_options) {
        var options = opt_options || {};
        var size = options.size;
        if (!size) {
          size = this.getSizeFromViewport_();
        }
        /** @type {module:ol/geom/SimpleGeometry} */
        var geometry;
        if (!(geometryOrExtent instanceof SimpleGeometry)) {
          assert(Array.isArray(geometryOrExtent),
            24); // Invalid extent or geometry provided as `geometry`
          assert(!isEmpty$1(geometryOrExtent),
            25); // Cannot fit empty extent provided as `geometry`
          geometry = fromExtent(geometryOrExtent);
        } else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
          geometryOrExtent = geometryOrExtent.getExtent();
          geometry = fromExtent(geometryOrExtent);
          geometry.rotate(this.getRotation(), getCenter(geometryOrExtent));
        } else {
          geometry = geometryOrExtent;
        }

        var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
        var constrainResolution = options.constrainResolution !== undefined ?
          options.constrainResolution : true;
        var nearest = options.nearest !== undefined ? options.nearest : false;
        var minResolution;
        if (options.minResolution !== undefined) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== undefined) {
          minResolution = this.constrainResolution(
            this.maxResolution_, options.maxZoom - this.minZoom_, 0);
        } else {
          minResolution = 0;
        }
        var coords = geometry.getFlatCoordinates();

        // calculate rotated extent
        var rotation = this.getRotation();
        var cosAngle = Math.cos(-rotation);
        var sinAngle = Math.sin(-rotation);
        var minRotX = +Infinity;
        var minRotY = +Infinity;
        var maxRotX = -Infinity;
        var maxRotY = -Infinity;
        var stride = geometry.getStride();
        for (var i = 0, ii = coords.length; i < ii; i += stride) {
          var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }

        // calculate resolution
        var resolution = this.getResolutionForExtent(
          [minRotX, minRotY, maxRotX, maxRotY],
          [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
        resolution = isNaN(resolution) ? minResolution :
          Math.max(resolution, minResolution);
        if (constrainResolution) {
          var constrainedResolution = this.constrainResolution(resolution, 0, 0);
          if (!nearest && constrainedResolution < resolution) {
            constrainedResolution = this.constrainResolution(
              constrainedResolution, -1, 0);
          }
          resolution = constrainedResolution;
        }

        // calculate center
        sinAngle = -sinAngle; // go back to original rotation
        var centerRotX = (minRotX + maxRotX) / 2;
        var centerRotY = (minRotY + maxRotY) / 2;
        centerRotX += (padding[1] - padding[3]) / 2 * resolution;
        centerRotY += (padding[0] - padding[2]) / 2 * resolution;
        var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
        var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
        var center = [centerX, centerY];
        var callback = options.callback ? options.callback : UNDEFINED;

        if (options.duration !== undefined) {
          this.animate({
            resolution: resolution,
            center: center,
            duration: options.duration,
            easing: options.easing
          }, callback);
        } else {
          this.setResolution(resolution);
          this.setCenter(center);
          setTimeout(callback.bind(undefined, true), 0);
        }
      };

      /**
       * Center on coordinate and view position.
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {module:ol/size~Size} size Box pixel size.
       * @param {module:ol/pixel~Pixel} position Position on the view to center on.
       * @api
       */
      View.prototype.centerOn = function centerOn (coordinate, size, position) {
        // calculate rotated position
        var rotation = this.getRotation();
        var cosAngle = Math.cos(-rotation);
        var sinAngle = Math.sin(-rotation);
        var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
        var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
        var resolution = this.getResolution();
        rotX += (size[0] / 2 - position[0]) * resolution;
        rotY += (position[1] - size[1] / 2) * resolution;

        // go back to original angle
        sinAngle = -sinAngle; // go back to original rotation
        var centerX = rotX * cosAngle - rotY * sinAngle;
        var centerY = rotY * cosAngle + rotX * sinAngle;

        this.setCenter([centerX, centerY]);
      };

      /**
       * @return {boolean} Is defined.
       */
      View.prototype.isDef = function isDef () {
        return !!this.getCenter() && this.getResolution() !== undefined;
      };

      /**
       * Rotate the view around a given coordinate.
       * @param {number} rotation New rotation value for the view.
       * @param {module:ol/coordinate~Coordinate=} opt_anchor The rotation center.
       * @api
       */
      View.prototype.rotate = function rotate$$1 (rotation, opt_anchor) {
        if (opt_anchor !== undefined) {
          var center = this.calculateCenterRotate(rotation, opt_anchor);
          this.setCenter(center);
        }
        this.setRotation(rotation);
      };

      /**
       * Set the center of the current view.
       * @param {module:ol/coordinate~Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      View.prototype.setCenter = function setCenter (center) {
        this.set(ViewProperty.CENTER, center);
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
      };

      /**
       * @param {module:ol/ViewHint} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      View.prototype.setHint = function setHint (hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      };

      /**
       * Set the resolution for this view.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.setResolution = function setResolution (resolution) {
        this.set(ViewProperty.RESOLUTION, resolution);
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
      };

      /**
       * Set the rotation for this view.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.setRotation = function setRotation (rotation) {
        this.set(ViewProperty.ROTATION, rotation);
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
      };

      /**
       * Zoom to a specific zoom level.
       * @param {number} zoom Zoom level.
       * @api
       */
      View.prototype.setZoom = function setZoom (zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      };

      return View;
    }(BaseObject));


    /**
     * @param {module:ol/View~ViewOptions} options View options.
     * @return {module:ol/centerconstraint~Type} The constraint.
     */
    function createCenterConstraint(options) {
      if (options.extent !== undefined) {
        return createExtent(options.extent);
      } else {
        return none;
      }
    }


    /**
     * @param {module:ol/View~ViewOptions} options View options.
     * @return {{constraint: module:ol/resolutionconstraint~Type, maxResolution: number,
     *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
     */
    function createResolutionConstraint(options) {
      var resolutionConstraint;
      var maxResolution;
      var minResolution;

      // TODO: move these to be ol constants
      // see https://github.com/openlayers/openlayers/issues/2076
      var defaultMaxZoom = 28;
      var defaultZoomFactor = 2;

      var minZoom = options.minZoom !== undefined ?
        options.minZoom : DEFAULT_MIN_ZOOM;

      var maxZoom = options.maxZoom !== undefined ?
        options.maxZoom : defaultMaxZoom;

      var zoomFactor = options.zoomFactor !== undefined ?
        options.zoomFactor : defaultZoomFactor;

      if (options.resolutions !== undefined) {
        var resolutions = options.resolutions;
        maxResolution = resolutions[minZoom];
        minResolution = resolutions[maxZoom] !== undefined ?
          resolutions[maxZoom] : resolutions[resolutions.length - 1];
        resolutionConstraint = createSnapToResolutions(
          resolutions);
      } else {
        // calculate the default min and max resolution
        var projection = createProjection(options.projection, 'EPSG:3857');
        var extent = projection.getExtent();
        var size = !extent ?
          // use an extent that can fit the whole world if need be
          360 * METERS_PER_UNIT[Units.DEGREES] /
                projection.getMetersPerUnit() :
          Math.max(getWidth(extent), getHeight(extent));

        var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(
          defaultZoomFactor, DEFAULT_MIN_ZOOM);

        var defaultMinResolution = defaultMaxResolution / Math.pow(
          defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);

        // user provided maxResolution takes precedence
        maxResolution = options.maxResolution;
        if (maxResolution !== undefined) {
          minZoom = 0;
        } else {
          maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
        }

        // user provided minResolution takes precedence
        minResolution = options.minResolution;
        if (minResolution === undefined) {
          if (options.maxZoom !== undefined) {
            if (options.maxResolution !== undefined) {
              minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
            } else {
              minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
            }
          } else {
            minResolution = defaultMinResolution;
          }
        }

        // given discrete zoom levels, minResolution may be different than provided
        maxZoom = minZoom + Math.floor(
          Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
        minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

        resolutionConstraint = createSnapToPower(
          zoomFactor, maxResolution, maxZoom - minZoom);
      }
      return {constraint: resolutionConstraint, maxResolution: maxResolution,
        minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor};
    }


    /**
     * @param {module:ol/View~ViewOptions} options View options.
     * @return {module:ol/rotationconstraint~Type} Rotation constraint.
     */
    function createRotationConstraint(options) {
      var enableRotation = options.enableRotation !== undefined ?
        options.enableRotation : true;
      if (enableRotation) {
        var constrainRotation = options.constrainRotation;
        if (constrainRotation === undefined || constrainRotation === true) {
          return createSnapToZero();
        } else if (constrainRotation === false) {
          return none$1;
        } else if (typeof constrainRotation === 'number') {
          return createSnapToN(constrainRotation);
        } else {
          return none$1;
        }
      } else {
        return disable;
      }
    }


    /**
     * Determine if an animation involves no view change.
     * @param {module:ol/View~Animation} animation The animation.
     * @return {boolean} The animation involves no view change.
     */
    function isNoopAnimation(animation) {
      if (animation.sourceCenter && animation.targetCenter) {
        if (!equals$1(animation.sourceCenter, animation.targetCenter)) {
          return false;
        }
      }
      if (animation.sourceResolution !== animation.targetResolution) {
        return false;
      }
      if (animation.sourceRotation !== animation.targetRotation) {
        return false;
      }
      return true;
    }

    /**
     * @module ol/dom
     */


    /**
     * Create an html canvas element and returns its 2d context.
     * @param {number=} opt_width Canvas width.
     * @param {number=} opt_height Canvas height.
     * @return {CanvasRenderingContext2D} The context.
     */
    function createCanvasContext2D(opt_width, opt_height) {
      var canvas = /** @type {HTMLCanvasElement} */ (document.createElement('CANVAS'));
      if (opt_width) {
        canvas.width = opt_width;
      }
      if (opt_height) {
        canvas.height = opt_height;
      }
      return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
    }

    /**
     * @param {Node} newNode Node to replace old node
     * @param {Node} oldNode The node to be replaced
     */
    function replaceNode(newNode, oldNode) {
      var parent = oldNode.parentNode;
      if (parent) {
        parent.replaceChild(newNode, oldNode);
      }
    }

    /**
     * @param {Node} node The node to remove.
     * @returns {Node} The node that was removed or null.
     */
    function removeNode(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
    }

    /**
     * @param {Node} node The node to remove the children from.
     */
    function removeChildren(node) {
      while (node.lastChild) {
        node.removeChild(node.lastChild);
      }
    }

    /**
     * @module ol/layer/Group
     */


    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {(Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>)} [layers] Child layers.
     */


    /**
     * @enum {string}
     * @private
     */
    var Property$1 = {
      LAYERS: 'layers'
    };


    /**
     * @classdesc
     * A {@link module:ol/Collection~Collection} of layers that are handled together.
     *
     * A generic `change` event is triggered when the group/Collection changes.
     *
     * @api
     */
    var LayerGroup = (function (BaseLayer$$1) {
      function LayerGroup(opt_options) {

        var options = opt_options || {};
        var baseOptions = /** @type {module:ol/layer/Group~Options} */ (assign({}, options));
        delete baseOptions.layers;

        var layers = options.layers;

        BaseLayer$$1.call(this, baseOptions);

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.layersListenerKeys_ = [];

        /**
         * @private
         * @type {Object.<string, Array.<module:ol/events~EventsKey>>}
         */
        this.listenerKeys_ = {};

        listen(this,
          getChangeEventType(Property$1.LAYERS),
          this.handleLayersChanged_, this);

        if (layers) {
          if (Array.isArray(layers)) {
            layers = new Collection(layers.slice(), {unique: true});
          } else {
            assert(layers instanceof Collection,
              43); // Expected `layers` to be an array or a `Collection`
            layers = layers;
          }
        } else {
          layers = new Collection(undefined, {unique: true});
        }

        this.setLayers(layers);

      }

      if ( BaseLayer$$1 ) LayerGroup.__proto__ = BaseLayer$$1;
      LayerGroup.prototype = Object.create( BaseLayer$$1 && BaseLayer$$1.prototype );
      LayerGroup.prototype.constructor = LayerGroup;

      /**
       * @private
       */
      LayerGroup.prototype.handleLayerChange_ = function handleLayerChange_ () {
        this.changed();
      };

      /**
       * @param {module:ol/events/Event} event Event.
       * @private
       */
      LayerGroup.prototype.handleLayersChanged_ = function handleLayersChanged_ () {
        var this$1 = this;

        this.layersListenerKeys_.forEach(unlistenByKey);
        this.layersListenerKeys_.length = 0;

        var layers = this.getLayers();
        this.layersListenerKeys_.push(
          listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),
          listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this)
        );

        for (var id in this$1.listenerKeys_) {
          this$1.listenerKeys_[id].forEach(unlistenByKey);
        }
        clear(this.listenerKeys_);

        var layersArray = layers.getArray();
        for (var i = 0, ii = layersArray.length; i < ii; i++) {
          var layer = layersArray[i];
          this$1.listenerKeys_[getUid(layer).toString()] = [
            listen(layer, ObjectEventType.PROPERTYCHANGE, this$1.handleLayerChange_, this$1),
            listen(layer, EventType.CHANGE, this$1.handleLayerChange_, this$1)
          ];
        }

        this.changed();
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersAdd_ = function handleLayersAdd_ (collectionEvent) {
        var layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);
        var key = getUid(layer).toString();
        this.listenerKeys_[key] = [
          listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
          listen(layer, EventType.CHANGE, this.handleLayerChange_, this)
        ];
        this.changed();
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersRemove_ = function handleLayersRemove_ (collectionEvent) {
        var layer = /** @type {module:ol/layer/Base} */ (collectionEvent.element);
        var key = getUid(layer).toString();
        this.listenerKeys_[key].forEach(unlistenByKey);
        delete this.listenerKeys_[key];
        this.changed();
      };

      /**
       * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!module:ol/Collection.<module:ol/layer/Base>} Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.getLayers = function getLayers () {
        return (
          /** @type {!module:ol/Collection.<module:ol/layer/Base>} */ (this.get(Property$1.LAYERS))
        );
      };

      /**
       * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!module:ol/Collection.<module:ol/layer/Base>} layers Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.setLayers = function setLayers (layers) {
        this.set(Property$1.LAYERS, layers);
      };

      /**
       * @inheritDoc
       */
      LayerGroup.prototype.getLayersArray = function getLayersArray (opt_array) {
        var array = opt_array !== undefined ? opt_array : [];
        this.getLayers().forEach(function(layer) {
          layer.getLayersArray(array);
        });
        return array;
      };

      /**
       * @inheritDoc
       */
      LayerGroup.prototype.getLayerStatesArray = function getLayerStatesArray (opt_states) {
        var states = opt_states !== undefined ? opt_states : [];

        var pos = states.length;

        this.getLayers().forEach(function(layer) {
          layer.getLayerStatesArray(states);
        });

        var ownLayerState = this.getLayerState();
        for (var i = pos, ii = states.length; i < ii; i++) {
          var layerState = states[i];
          layerState.opacity *= ownLayerState.opacity;
          layerState.visible = layerState.visible && ownLayerState.visible;
          layerState.maxResolution = Math.min(
            layerState.maxResolution, ownLayerState.maxResolution);
          layerState.minResolution = Math.max(
            layerState.minResolution, ownLayerState.minResolution);
          if (ownLayerState.extent !== undefined) {
            if (layerState.extent !== undefined) {
              layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
            } else {
              layerState.extent = ownLayerState.extent;
            }
          }
        }

        return states;
      };

      /**
       * @inheritDoc
       */
      LayerGroup.prototype.getSourceState = function getSourceState () {
        return SourceState.READY;
      };

      return LayerGroup;
    }(BaseLayer));

    /**
     * @module ol/size
     */


    /**
     * Determines if a size has a positive area.
     * @param {module:ol/size~Size} size The size to test.
     * @return {boolean} The size has a positive area.
     */
    function hasArea(size) {
      return size[0] > 0 && size[1] > 0;
    }


    /**
     * Returns a size scaled by a ratio. The result will be an array of integers.
     * @param {module:ol/size~Size} size Size.
     * @param {number} ratio Ratio.
     * @param {module:ol/size~Size=} opt_size Optional reusable size array.
     * @return {module:ol/size~Size} The scaled size.
     */
    function scale$3(size, ratio, opt_size) {
      if (opt_size === undefined) {
        opt_size = [0, 0];
      }
      opt_size[0] = (size[0] * ratio + 0.5) | 0;
      opt_size[1] = (size[1] * ratio + 0.5) | 0;
      return opt_size;
    }


    /**
     * Returns an `module:ol/size~Size` array for the passed in number (meaning: square) or
     * `module:ol/size~Size` array.
     * (meaning: non-square),
     * @param {number|module:ol/size~Size} size Width and height.
     * @param {module:ol/size~Size=} opt_size Optional reusable size array.
     * @return {module:ol/size~Size} Size.
     * @api
     */
    function toSize(size, opt_size) {
      if (Array.isArray(size)) {
        return size;
      } else {
        if (opt_size === undefined) {
          opt_size = [size, size];
        } else {
          opt_size[0] = opt_size[1] = /** @type {number} */ (size);
        }
        return opt_size;
      }
    }

    /**
     * @module ol/PluggableMap
     */


    /**
     * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
     * be used in applications.
     * @typedef {Object} FrameState
     * @property {number} pixelRatio The pixel ratio of the frame.
     * @property {number} time The time when rendering of the frame was requested.
     * @property {module:ol/View~State} viewState The state of the current view.
     * @property {boolean} animate
     * @property {module:ol/transform~Transform} coordinateToPixelTransform
     * @property {null|module:ol/extent~Extent} extent
     * @property {module:ol/coordinate~Coordinate} focus
     * @property {number} index
     * @property {Object.<number, module:ol/layer/Layer~State>} layerStates
     * @property {Array.<module:ol/layer/Layer~State>} layerStatesArray
     * @property {module:ol/transform~Transform} pixelToCoordinateTransform
     * @property {Array.<module:ol/PluggableMap~PostRenderFunction>} postRenderFunctions
     * @property {module:ol/size~Size} size
     * @property {!Object.<string, boolean>} skippedFeatureUids
     * @property {module:ol/TileQueue} tileQueue
     * @property {Object.<string, Object.<string, module:ol/TileRange>>} usedTiles
     * @property {Array.<number>} viewHints
     * @property {!Object.<string, Object.<string, boolean>>} wantedTiles
     */


    /**
     * @typedef {function(module:ol/PluggableMap, ?module:ol/PluggableMap~FrameState): boolean} PostRenderFunction
     */


    /**
     * @typedef {Object} AtPixelOptions
     * @property {((function(module:ol/layer/Layer): boolean)|undefined)} layerFilter Layer filter
     * function. The filter function will receive one argument, the
     * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
     * Only layers which are visible and for which this function returns `true`
     * will be tested for features. By default, all visible layers will be tested.
     * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
     * inside the radius around the given position will be checked for features. This only
     * works for the canvas renderer and not for WebGL.
     */


    /**
     * @typedef {Object} MapOptionsInternal
     * @property {module:ol/Collection.<module:ol/control/Control>} [controls]
     * @property {module:ol/Collection.<module:ol/interaction/Interaction>} [interactions]
     * @property {HTMLElement|Document} keyboardEventTarget
     * @property {module:ol/Collection.<module:ol/Overlay>} overlays
     * @property {Object.<string, *>} values
     */


    /**
     * Object literal with config options for the map.
     * @typedef {Object} MapOptions
     * @property {module:ol/Collection.<module:ol/control/Control>|Array.<module:ol/control/Control>} [controls]
     * Controls initially added to the map. If not specified,
     * {@link module:ol/control/util~defaults} is used.
     * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
     * physical pixels and device-independent pixels (dips) on the device.
     * @property {module:ol/Collection.<module:ol/interaction/Interaction>|Array.<module:ol/interaction/Interaction>} [interactions]
     * Interactions that are initially added to the map. If not specified,
     * {@link module:ol/interaction~defaults} is used.
     * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
     * listen to keyboard events on. This determines when the `KeyboardPan` and
     * `KeyboardZoom` interactions trigger. For example, if this option is set to
     * `document` the keyboard interactions will always trigger. If this option is
     * not specified, the element the library listens to keyboard events on is the
     * map target (i.e. the user-provided div for the map). If this is not
     * `document`, the target element needs to be focused for key events to be
     * emitted, requiring that the target element has a `tabindex` attribute.
     * @property {Array.<module:ol/layer/Base>|module:ol/Collection.<module:ol/layer/Base>} [layers]
     * Layers. If this is not defined, a map with no layers will be rendered. Note
     * that layers are rendered in the order supplied, so if you want, for example,
     * a vector layer to appear on top of a tile layer, it must come after the tile
     * layer.
     * @property {number} [maxTilesLoading=16] Maximum number tiles to load
     * simultaneously.
     * @property {boolean} [loadTilesWhileAnimating=false] When set to `true`, tiles
     * will be loaded during animations. This may improve the user experience, but
     * can also make animations stutter on devices with slow memory.
     * @property {boolean} [loadTilesWhileInteracting=false] When set to `true`,
     * tiles will be loaded while interacting with the map. This may improve the
     * user experience, but can also make map panning and zooming choppy on devices
     * with slow memory.
     * @property {number} [moveTolerance=1] The minimum distance in pixels the
     * cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     * @property {module:ol/Collection.<module:ol/Overlay>|Array.<module:ol/Overlay>} [overlays]
     * Overlays initially added to the map. By default, no overlays are added.
     * @property {HTMLElement|string} [target] The container for the map, either the
     * element itself or the `id` of the element. If not specified at construction
     * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
     * rendered.
     * @property {module:ol/View} [view] The map's view.  No layer sources will be
     * fetched unless this is specified at construction time or through
     * {@link module:ol/Map~Map#setView}.
     */


    /**
     * @fires module:ol/MapBrowserEvent~MapBrowserEvent
     * @fires module:ol/MapEvent~MapEvent
     * @fires module:ol/render/Event~RenderEvent#postcompose
     * @fires module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    var PluggableMap = (function (BaseObject$$1) {
      function PluggableMap(options) {
        var this$1 = this;


        BaseObject$$1.call(this);

        var optionsInternal = createOptionsInternal(options);

        /**
         * @type {number}
         * @private
         */
        this.maxTilesLoading_ = options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;

        /**
         * @type {boolean}
         * @private
         */
        this.loadTilesWhileAnimating_ =
            options.loadTilesWhileAnimating !== undefined ?
              options.loadTilesWhileAnimating : false;

        /**
         * @type {boolean}
         * @private
         */
        this.loadTilesWhileInteracting_ =
            options.loadTilesWhileInteracting !== undefined ?
              options.loadTilesWhileInteracting : false;

        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = options.pixelRatio !== undefined ?
          options.pixelRatio : DEVICE_PIXEL_RATIO;

        /**
         * @private
         * @type {number|undefined}
         */
        this.animationDelayKey_;

        /**
         * @private
         */
        this.animationDelay_ = function() {
          this.animationDelayKey_ = undefined;
          this.renderFrame_.call(this, Date.now());
        }.bind(this);

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.coordinateToPixelTransform_ = create();

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.pixelToCoordinateTransform_ = create();

        /**
         * @private
         * @type {number}
         */
        this.frameIndex_ = 0;

        /**
         * @private
         * @type {?module:ol/PluggableMap~FrameState}
         */
        this.frameState_ = null;

        /**
         * The extent at the previous 'moveend' event.
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.previousExtent_ = null;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.viewPropertyListenerKey_ = null;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.viewChangeListenerKey_ = null;

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.layerGroupPropertyListenerKeys_ = null;

        /**
         * @private
         * @type {!HTMLElement}
         */
        this.viewport_ = document.createElement('DIV');
        this.viewport_.className = 'ol-viewport' + (TOUCH ? ' ol-touch' : '');
        this.viewport_.style.position = 'relative';
        this.viewport_.style.overflow = 'hidden';
        this.viewport_.style.width = '100%';
        this.viewport_.style.height = '100%';
        // prevent page zoom on IE >= 10 browsers
        this.viewport_.style.msTouchAction = 'none';
        this.viewport_.style.touchAction = 'none';

        /**
         * @private
         * @type {!HTMLElement}
         */
        this.overlayContainer_ = document.createElement('DIV');
        this.overlayContainer_.className = 'ol-overlaycontainer';
        this.viewport_.appendChild(this.overlayContainer_);

        /**
         * @private
         * @type {!HTMLElement}
         */
        this.overlayContainerStopEvent_ = document.createElement('DIV');
        this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
        var overlayEvents = [
          EventType.CLICK,
          EventType.DBLCLICK,
          EventType.MOUSEDOWN,
          EventType.TOUCHSTART,
          EventType.MSPOINTERDOWN,
          MapBrowserEventType.POINTERDOWN,
          EventType.MOUSEWHEEL,
          EventType.WHEEL
        ];
        for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
          listen(this$1.overlayContainerStopEvent_, overlayEvents[i], stopPropagation);
        }
        this.viewport_.appendChild(this.overlayContainerStopEvent_);

        /**
         * @private
         * @type {module:ol/MapBrowserEventHandler}
         */
        this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, options.moveTolerance);
        for (var key in MapBrowserEventType) {
          listen(this$1.mapBrowserEventHandler_, MapBrowserEventType[key],
            this$1.handleMapBrowserEvent, this$1);
        }

        /**
         * @private
         * @type {HTMLElement|Document}
         */
        this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.keyHandlerKeys_ = null;

        listen(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);
        listen(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);
        listen(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);

        /**
         * @type {module:ol/Collection.<module:ol/control/Control>}
         * @protected
         */
        this.controls = optionsInternal.controls || new Collection();

        /**
         * @type {module:ol/Collection.<module:ol/interaction/Interaction>}
         * @protected
         */
        this.interactions = optionsInternal.interactions || new Collection();

        /**
         * @type {module:ol/Collection.<module:ol/Overlay>}
         * @private
         */
        this.overlays_ = optionsInternal.overlays;

        /**
         * A lookup of overlays by id.
         * @private
         * @type {Object.<string, module:ol/Overlay>}
         */
        this.overlayIdIndex_ = {};

        /**
         * @type {module:ol/renderer/Map}
         * @private
         */
        this.renderer_ = this.createRenderer();

        /**
         * @type {function(Event)|undefined}
         * @private
         */
        this.handleResize_;

        /**
         * @private
         * @type {module:ol/coordinate~Coordinate}
         */
        this.focus_ = null;

        /**
         * @private
         * @type {!Array.<module:ol/PluggableMap~PostRenderFunction>}
         */
        this.postRenderFunctions_ = [];

        /**
         * @private
         * @type {module:ol/TileQueue}
         */
        this.tileQueue_ = new TileQueue(
          this.getTilePriority.bind(this),
          this.handleTileChange_.bind(this));

        /**
         * Uids of features to skip at rendering time.
         * @type {Object.<string, boolean>}
         * @private
         */
        this.skippedFeatureUids_ = {};

        listen(
          this, getChangeEventType(MapProperty.LAYERGROUP),
          this.handleLayerGroupChanged_, this);
        listen(this, getChangeEventType(MapProperty.VIEW),
          this.handleViewChanged_, this);
        listen(this, getChangeEventType(MapProperty.SIZE),
          this.handleSizeChanged_, this);
        listen(this, getChangeEventType(MapProperty.TARGET),
          this.handleTargetChanged_, this);

        // setProperties will trigger the rendering of the map if the map
        // is "defined" already.
        this.setProperties(optionsInternal.values);

        this.controls.forEach(
          /**
           * @param {module:ol/control/Control} control Control.
           * @this {module:ol/PluggableMap}
           */
          (function(control) {
            control.setMap(this);
          }).bind(this));

        listen(this.controls, CollectionEventType.ADD,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            event.element.setMap(this);
          }, this);

        listen(this.controls, CollectionEventType.REMOVE,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            event.element.setMap(null);
          }, this);

        this.interactions.forEach(
          /**
           * @param {module:ol/interaction/Interaction} interaction Interaction.
           * @this {module:ol/PluggableMap}
           */
          (function(interaction) {
            interaction.setMap(this);
          }).bind(this));

        listen(this.interactions, CollectionEventType.ADD,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            event.element.setMap(this);
          }, this);

        listen(this.interactions, CollectionEventType.REMOVE,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            event.element.setMap(null);
          }, this);

        this.overlays_.forEach(this.addOverlayInternal_.bind(this));

        listen(this.overlays_, CollectionEventType.ADD,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            this.addOverlayInternal_(/** @type {module:ol/Overlay} */ (event.element));
          }, this);

        listen(this.overlays_, CollectionEventType.REMOVE,
          /**
           * @param {module:ol/Collection~CollectionEvent} event CollectionEvent.
           */
          function(event) {
            var overlay = /** @type {module:ol/Overlay} */ (event.element);
            var id = overlay.getId();
            if (id !== undefined) {
              delete this.overlayIdIndex_[id.toString()];
            }
            event.element.setMap(null);
          }, this);

      }

      if ( BaseObject$$1 ) PluggableMap.__proto__ = BaseObject$$1;
      PluggableMap.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      PluggableMap.prototype.constructor = PluggableMap;

      PluggableMap.prototype.createRenderer = function createRenderer () {
        throw new Error('Use a map type that has a createRenderer method');
      };

      /**
       * Add the given control to the map.
       * @param {module:ol/control/Control} control Control.
       * @api
       */
      PluggableMap.prototype.addControl = function addControl (control) {
        this.getControls().push(control);
      };

      /**
       * Add the given interaction to the map.
       * @param {module:ol/interaction/Interaction} interaction Interaction to add.
       * @api
       */
      PluggableMap.prototype.addInteraction = function addInteraction (interaction) {
        this.getInteractions().push(interaction);
      };

      /**
       * Adds the given layer to the top of this map. If you want to add a layer
       * elsewhere in the stack, use `getLayers()` and the methods available on
       * {@link module:ol/Collection~Collection}.
       * @param {module:ol/layer/Base} layer Layer.
       * @api
       */
      PluggableMap.prototype.addLayer = function addLayer (layer) {
        var layers = this.getLayerGroup().getLayers();
        layers.push(layer);
      };

      /**
       * Add the given overlay to the map.
       * @param {module:ol/Overlay} overlay Overlay.
       * @api
       */
      PluggableMap.prototype.addOverlay = function addOverlay (overlay) {
        this.getOverlays().push(overlay);
      };

      /**
       * This deals with map's overlay collection changes.
       * @param {module:ol/Overlay} overlay Overlay.
       * @private
       */
      PluggableMap.prototype.addOverlayInternal_ = function addOverlayInternal_ (overlay) {
        var id = overlay.getId();
        if (id !== undefined) {
          this.overlayIdIndex_[id.toString()] = overlay;
        }
        overlay.setMap(this);
      };

      /**
       *
       * @inheritDoc
       */
      PluggableMap.prototype.disposeInternal = function disposeInternal () {
        this.mapBrowserEventHandler_.dispose();
        unlisten(this.viewport_, EventType.CONTEXTMENU, this.handleBrowserEvent, this);
        unlisten(this.viewport_, EventType.WHEEL, this.handleBrowserEvent, this);
        unlisten(this.viewport_, EventType.MOUSEWHEEL, this.handleBrowserEvent, this);
        if (this.handleResize_ !== undefined) {
          removeEventListener(EventType.RESIZE, this.handleResize_, false);
          this.handleResize_ = undefined;
        }
        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
          this.animationDelayKey_ = undefined;
        }
        this.setTarget(null);
        BaseObject$$1.prototype.disposeInternal.call(this);
      };

      /**
       * Detect features that intersect a pixel on the viewport, and execute a
       * callback with each intersecting feature. Layers included in the detection can
       * be configured through the `layerFilter` option in `opt_options`.
       * @param {module:ol/pixel~Pixel} pixel Pixel.
       * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),
       *     module:ol/layer/Layer): T} callback Feature callback. The callback will be
       *     called with two arguments. The first argument is one
       *     {@link module:ol/Feature feature} or
       *     {@link module:ol/render/Feature render feature} at the pixel, the second is
       *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
       *     unmanaged layers. To stop detection, callback functions can return a
       *     truthy value.
       * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachFeatureAtPixel = function forEachFeatureAtPixel (pixel, callback, opt_options) {
        if (!this.frameState_) {
          return;
        }
        var coordinate = this.getCoordinateFromPixel(pixel);
        opt_options = opt_options !== undefined ? opt_options : {};
        var hitTolerance = opt_options.hitTolerance !== undefined ?
          opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
        var layerFilter = opt_options.layerFilter !== undefined ?
          opt_options.layerFilter : TRUE;
        return this.renderer_.forEachFeatureAtCoordinate(
          coordinate, this.frameState_, hitTolerance, callback, null,
          layerFilter, null);
      };

      /**
       * Get all features that intersect a pixel on the viewport.
       * @param {module:ol/pixel~Pixel} pixel Pixel.
       * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
       * @return {Array.<module:ol/Feature|module:ol/render/Feature>} The detected features or
       * `null` if none were found.
       * @api
       */
      PluggableMap.prototype.getFeaturesAtPixel = function getFeaturesAtPixel (pixel, opt_options) {
        var features = null;
        this.forEachFeatureAtPixel(pixel, function(feature) {
          if (!features) {
            features = [];
          }
          features.push(feature);
        }, opt_options);
        return features;
      };

      /**
       * Detect layers that have a color value at a pixel on the viewport, and
       * execute a callback with each matching layer. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       * @param {module:ol/pixel~Pixel} pixel Pixel.
       * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback
       *     Layer callback. This callback will receive two arguments: first is the
       *     {@link module:ol/layer/Layer layer}, second argument is an array representing
       *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
       *     that do not currently support this argument. To stop detection, callback
       *     functions can return a truthy value.
       * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Configuration options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, callback, opt_options) {
        if (!this.frameState_) {
          return;
        }
        var options = opt_options || {};
        var hitTolerance = options.hitTolerance !== undefined ?
          opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
        var layerFilter = options.layerFilter || TRUE;
        return this.renderer_.forEachLayerAtPixel(
          pixel, this.frameState_, hitTolerance, callback, null, layerFilter, null);
      };

      /**
       * Detect if features intersect a pixel on the viewport. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       * @param {module:ol/pixel~Pixel} pixel Pixel.
       * @param {module:ol/PluggableMap~AtPixelOptions=} opt_options Optional options.
       * @return {boolean} Is there a feature at the given pixel?
       * @template U
       * @api
       */
      PluggableMap.prototype.hasFeatureAtPixel = function hasFeatureAtPixel (pixel, opt_options) {
        if (!this.frameState_) {
          return false;
        }
        var coordinate = this.getCoordinateFromPixel(pixel);
        opt_options = opt_options !== undefined ? opt_options : {};
        var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
        var hitTolerance = opt_options.hitTolerance !== undefined ?
          opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
        return this.renderer_.hasFeatureAtCoordinate(
          coordinate, this.frameState_, hitTolerance, layerFilter, null);
      };

      /**
       * Returns the coordinate in view projection for a browser event.
       * @param {Event} event Event.
       * @return {module:ol/coordinate~Coordinate} Coordinate.
       * @api
       */
      PluggableMap.prototype.getEventCoordinate = function getEventCoordinate (event) {
        return this.getCoordinateFromPixel(this.getEventPixel(event));
      };

      /**
       * Returns the map pixel position for a browser event relative to the viewport.
       * @param {Event} event Event.
       * @return {module:ol/pixel~Pixel} Pixel.
       * @api
       */
      PluggableMap.prototype.getEventPixel = function getEventPixel (event) {
        var viewportPosition = this.viewport_.getBoundingClientRect();
        var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
        return [
          eventPosition.clientX - viewportPosition.left,
          eventPosition.clientY - viewportPosition.top
        ];
      };

      /**
       * Get the target in which this map is rendered.
       * Note that this returns what is entered as an option or in setTarget:
       * if that was an element, it returns an element; if a string, it returns that.
       * @return {HTMLElement|string|undefined} The Element or id of the Element that the
       *     map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.getTarget = function getTarget () {
        return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));
      };

      /**
       * Get the DOM element into which this map is rendered. In contrast to
       * `getTarget` this method always return an `Element`, or `null` if the
       * map has no target.
       * @return {HTMLElement} The element that the map is rendered in.
       * @api
       */
      PluggableMap.prototype.getTargetElement = function getTargetElement () {
        var target = this.getTarget();
        if (target !== undefined) {
          return typeof target === 'string' ? document.getElementById(target) : target;
        } else {
          return null;
        }
      };

      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * map view projection.
       * @param {module:ol/pixel~Pixel} pixel Pixel position in the map viewport.
       * @return {module:ol/coordinate~Coordinate} The coordinate for the pixel position.
       * @api
       */
      PluggableMap.prototype.getCoordinateFromPixel = function getCoordinateFromPixel (pixel) {
        var frameState = this.frameState_;
        if (!frameState) {
          return null;
        } else {
          return apply(frameState.pixelToCoordinateTransform, pixel.slice());
        }
      };

      /**
       * Get the map controls. Modifying this collection changes the controls
       * associated with the map.
       * @return {module:ol/Collection.<module:ol/control/Control>} Controls.
       * @api
       */
      PluggableMap.prototype.getControls = function getControls () {
        return this.controls;
      };

      /**
       * Get the map overlays. Modifying this collection changes the overlays
       * associated with the map.
       * @return {module:ol/Collection.<module:ol/Overlay>} Overlays.
       * @api
       */
      PluggableMap.prototype.getOverlays = function getOverlays () {
        return this.overlays_;
      };

      /**
       * Get an overlay by its identifier (the value returned by overlay.getId()).
       * Note that the index treats string and numeric identifiers as the same. So
       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
       * @param {string|number} id Overlay identifier.
       * @return {module:ol/Overlay} Overlay.
       * @api
       */
      PluggableMap.prototype.getOverlayById = function getOverlayById (id) {
        var overlay = this.overlayIdIndex_[id.toString()];
        return overlay !== undefined ? overlay : null;
      };

      /**
       * Get the map interactions. Modifying this collection changes the interactions
       * associated with the map.
       *
       * Interactions are used for e.g. pan, zoom and rotate.
       * @return {module:ol/Collection.<module:ol/interaction/Interaction>} Interactions.
       * @api
       */
      PluggableMap.prototype.getInteractions = function getInteractions () {
        return this.interactions;
      };

      /**
       * Get the layergroup associated with this map.
       * @return {module:ol/layer/Group} A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getLayerGroup = function getLayerGroup () {
        return (
          /** @type {module:ol/layer/Group} */ (this.get(MapProperty.LAYERGROUP))
        );
      };

      /**
       * Get the collection of layers associated with this map.
       * @return {!module:ol/Collection.<module:ol/layer/Base>} Layers.
       * @api
       */
      PluggableMap.prototype.getLayers = function getLayers () {
        var layers = this.getLayerGroup().getLayers();
        return layers;
      };

      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the map view
       * projection and returns the corresponding pixel.
       * @param {module:ol/coordinate~Coordinate} coordinate A map coordinate.
       * @return {module:ol/pixel~Pixel} A pixel position in the map viewport.
       * @api
       */
      PluggableMap.prototype.getPixelFromCoordinate = function getPixelFromCoordinate (coordinate) {
        var frameState = this.frameState_;
        if (!frameState) {
          return null;
        } else {
          return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
        }
      };

      /**
       * Get the map renderer.
       * @return {module:ol/renderer/Map} Renderer
       */
      PluggableMap.prototype.getRenderer = function getRenderer () {
        return this.renderer_;
      };

      /**
       * Get the size of this map.
       * @return {module:ol/size~Size|undefined} The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.getSize = function getSize$$1 () {
        return (
          /** @type {module:ol/size~Size|undefined} */ (this.get(MapProperty.SIZE))
        );
      };

      /**
       * Get the view associated with this map. A view manages properties such as
       * center and resolution.
       * @return {module:ol/View} The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getView = function getView () {
        return (
          /** @type {module:ol/View} */ (this.get(MapProperty.VIEW))
        );
      };

      /**
       * Get the element that serves as the map viewport.
       * @return {HTMLElement} Viewport.
       * @api
       */
      PluggableMap.prototype.getViewport = function getViewport () {
        return this.viewport_;
      };

      /**
       * Get the element that serves as the container for overlays.  Elements added to
       * this container will let mousedown and touchstart events through to the map,
       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
       * events.
       * @return {!HTMLElement} The map's overlay container.
       */
      PluggableMap.prototype.getOverlayContainer = function getOverlayContainer () {
        return this.overlayContainer_;
      };

      /**
       * Get the element that serves as a container for overlays that don't allow
       * event propagation. Elements added to this container won't let mousedown and
       * touchstart events through to the map, so clicks and gestures on an overlay
       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
       * @return {!HTMLElement} The map's overlay container that stops events.
       */
      PluggableMap.prototype.getOverlayContainerStopEvent = function getOverlayContainerStopEvent () {
        return this.overlayContainerStopEvent_;
      };

      /**
       * @param {module:ol/Tile} tile Tile.
       * @param {string} tileSourceKey Tile source key.
       * @param {module:ol/coordinate~Coordinate} tileCenter Tile center.
       * @param {number} tileResolution Tile resolution.
       * @return {number} Tile priority.
       */
      PluggableMap.prototype.getTilePriority = function getTilePriority (tile, tileSourceKey, tileCenter, tileResolution) {
        // Filter out tiles at higher zoom levels than the current zoom level, or that
        // are outside the visible extent.
        var frameState = this.frameState_;
        if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
          return DROP;
        }
        if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
          return DROP;
        }
        // Prioritize the highest zoom level tiles closest to the focus.
        // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
        // Within a zoom level, tiles are prioritized by the distance in pixels
        // between the center of the tile and the focus.  The factor of 65536 means
        // that the prioritization should behave as desired for tiles up to
        // 65536 * Math.log(2) = 45426 pixels from the focus.
        var deltaX = tileCenter[0] - frameState.focus[0];
        var deltaY = tileCenter[1] - frameState.focus[1];
        return 65536 * Math.log(tileResolution) +
            Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
      };

      /**
       * @param {Event} browserEvent Browser event.
       * @param {string=} opt_type Type.
       */
      PluggableMap.prototype.handleBrowserEvent = function handleBrowserEvent (browserEvent, opt_type) {
        var type = opt_type || browserEvent.type;
        var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
        this.handleMapBrowserEvent(mapBrowserEvent);
      };

      /**
       * @param {module:ol/MapBrowserEvent} mapBrowserEvent The event to handle.
       */
      PluggableMap.prototype.handleMapBrowserEvent = function handleMapBrowserEvent (mapBrowserEvent) {
        if (!this.frameState_) {
          // With no view defined, we cannot translate pixels into geographical
          // coordinates so interactions cannot be used.
          return;
        }
        this.focus_ = mapBrowserEvent.coordinate;
        mapBrowserEvent.frameState = this.frameState_;
        var interactionsArray = this.getInteractions().getArray();
        if (this.dispatchEvent(mapBrowserEvent) !== false) {
          for (var i = interactionsArray.length - 1; i >= 0; i--) {
            var interaction = interactionsArray[i];
            if (!interaction.getActive()) {
              continue;
            }
            var cont = interaction.handleEvent(mapBrowserEvent);
            if (!cont) {
              break;
            }
          }
        }
      };

      /**
       * @protected
       */
      PluggableMap.prototype.handlePostRender = function handlePostRender () {
        var this$1 = this;


        var frameState = this.frameState_;

        // Manage the tile queue
        // Image loads are expensive and a limited resource, so try to use them
        // efficiently:
        // * When the view is static we allow a large number of parallel tile loads
        //   to complete the frame as quickly as possible.
        // * When animating or interacting, image loads can cause janks, so we reduce
        //   the maximum number of loads per frame and limit the number of parallel
        //   tile loads to remain reactive to view changes and to reduce the chance of
        //   loading tiles that will quickly disappear from view.
        var tileQueue = this.tileQueue_;
        if (!tileQueue.isEmpty()) {
          var maxTotalLoading = this.maxTilesLoading_;
          var maxNewLoads = maxTotalLoading;
          if (frameState) {
            var hints = frameState.viewHints;
            if (hints[ViewHint.ANIMATING]) {
              maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
              maxNewLoads = 2;
            }
            if (hints[ViewHint.INTERACTING]) {
              maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
              maxNewLoads = 2;
            }
          }
          if (tileQueue.getTilesLoading() < maxTotalLoading) {
            tileQueue.reprioritize(); // FIXME only call if view has changed
            tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
          }
        }

        var postRenderFunctions = this.postRenderFunctions_;
        for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
          postRenderFunctions[i](this$1, frameState);
        }
        postRenderFunctions.length = 0;
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleSizeChanged_ = function handleSizeChanged_ () {
        this.render();
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleTargetChanged_ = function handleTargetChanged_ () {
        var this$1 = this;

        // target may be undefined, null, a string or an Element.
        // If it's a string we convert it to an Element before proceeding.
        // If it's not now an Element we remove the viewport from the DOM.
        // If it's an Element we append the viewport element to it.

        var targetElement;
        if (this.getTarget()) {
          targetElement = this.getTargetElement();
        }

        if (this.keyHandlerKeys_) {
          for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
            unlistenByKey(this$1.keyHandlerKeys_[i]);
          }
          this.keyHandlerKeys_ = null;
        }

        if (!targetElement) {
          this.renderer_.removeLayerRenderers();
          removeNode(this.viewport_);
          if (this.handleResize_ !== undefined) {
            removeEventListener(EventType.RESIZE, this.handleResize_, false);
            this.handleResize_ = undefined;
          }
        } else {
          targetElement.appendChild(this.viewport_);

          var keyboardEventTarget = !this.keyboardEventTarget_ ?
            targetElement : this.keyboardEventTarget_;
          this.keyHandlerKeys_ = [
            listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
            listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this)
          ];

          if (!this.handleResize_) {
            this.handleResize_ = this.updateSize.bind(this);
            addEventListener(EventType.RESIZE, this.handleResize_, false);
          }
        }

        this.updateSize();
        // updateSize calls setSize, so no need to call this.render
        // ourselves here.
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleTileChange_ = function handleTileChange_ () {
        this.render();
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleViewPropertyChanged_ = function handleViewPropertyChanged_ () {
        this.render();
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleViewChanged_ = function handleViewChanged_ () {
        if (this.viewPropertyListenerKey_) {
          unlistenByKey(this.viewPropertyListenerKey_);
          this.viewPropertyListenerKey_ = null;
        }
        if (this.viewChangeListenerKey_) {
          unlistenByKey(this.viewChangeListenerKey_);
          this.viewChangeListenerKey_ = null;
        }
        var view = this.getView();
        if (view) {
          this.viewport_.setAttribute('data-view', getUid(view));
          this.viewPropertyListenerKey_ = listen(
            view, ObjectEventType.PROPERTYCHANGE,
            this.handleViewPropertyChanged_, this);
          this.viewChangeListenerKey_ = listen(
            view, EventType.CHANGE,
            this.handleViewPropertyChanged_, this);
        }
        this.render();
      };

      /**
       * @private
       */
      PluggableMap.prototype.handleLayerGroupChanged_ = function handleLayerGroupChanged_ () {
        if (this.layerGroupPropertyListenerKeys_) {
          this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
          this.layerGroupPropertyListenerKeys_ = null;
        }
        var layerGroup = this.getLayerGroup();
        if (layerGroup) {
          this.layerGroupPropertyListenerKeys_ = [
            listen(
              layerGroup, ObjectEventType.PROPERTYCHANGE,
              this.render, this),
            listen(
              layerGroup, EventType.CHANGE,
              this.render, this)
          ];
        }
        this.render();
      };

      /**
       * @return {boolean} Is rendered.
       */
      PluggableMap.prototype.isRendered = function isRendered () {
        return !!this.frameState_;
      };

      /**
       * Requests an immediate render in a synchronous manner.
       * @api
       */
      PluggableMap.prototype.renderSync = function renderSync () {
        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
        }
        this.animationDelay_();
      };

      /**
       * Request a map rendering (at the next animation frame).
       * @api
       */
      PluggableMap.prototype.render = function render () {
        if (this.animationDelayKey_ === undefined) {
          this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
        }
      };

      /**
       * Remove the given control from the map.
       * @param {module:ol/control/Control} control Control.
       * @return {module:ol/control/Control|undefined} The removed control (or undefined
       *     if the control was not found).
       * @api
       */
      PluggableMap.prototype.removeControl = function removeControl (control) {
        return this.getControls().remove(control);
      };

      /**
       * Remove the given interaction from the map.
       * @param {module:ol/interaction/Interaction} interaction Interaction to remove.
       * @return {module:ol/interaction/Interaction|undefined} The removed interaction (or
       *     undefined if the interaction was not found).
       * @api
       */
      PluggableMap.prototype.removeInteraction = function removeInteraction (interaction) {
        return this.getInteractions().remove(interaction);
      };

      /**
       * Removes the given layer from the map.
       * @param {module:ol/layer/Base} layer Layer.
       * @return {module:ol/layer/Base|undefined} The removed layer (or undefined if the
       *     layer was not found).
       * @api
       */
      PluggableMap.prototype.removeLayer = function removeLayer (layer) {
        var layers = this.getLayerGroup().getLayers();
        return layers.remove(layer);
      };

      /**
       * Remove the given overlay from the map.
       * @param {module:ol/Overlay} overlay Overlay.
       * @return {module:ol/Overlay|undefined} The removed overlay (or undefined
       *     if the overlay was not found).
       * @api
       */
      PluggableMap.prototype.removeOverlay = function removeOverlay (overlay) {
        return this.getOverlays().remove(overlay);
      };

      /**
       * @param {number} time Time.
       * @private
       */
      PluggableMap.prototype.renderFrame_ = function renderFrame_ (time) {
        var viewState;

        var size = this.getSize();
        var view = this.getView();
        var extent = createEmpty();
        var previousFrameState = this.frameState_;
        /** @type {?module:ol/PluggableMap~FrameState} */
        var frameState = null;
        if (size !== undefined && hasArea(size) && view && view.isDef()) {
          var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
          var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
          var layerStates = {};
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
            layerStates[getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
          }
          viewState = view.getState();
          var focus = this.focus_;
          if (!focus) {
            focus = viewState.center;
            var pixelResolution = viewState.resolution / this.pixelRatio_;
            focus[0] = Math.round(focus[0] / pixelResolution) * pixelResolution;
            focus[1] = Math.round(focus[1] / pixelResolution) * pixelResolution;
          }
          frameState = /** @type {module:ol/PluggableMap~FrameState} */ ({
            animate: false,
            coordinateToPixelTransform: this.coordinateToPixelTransform_,
            extent: extent,
            focus: focus,
            index: this.frameIndex_++,
            layerStates: layerStates,
            layerStatesArray: layerStatesArray,
            pixelRatio: this.pixelRatio_,
            pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
            postRenderFunctions: [],
            size: size,
            skippedFeatureUids: this.skippedFeatureUids_,
            tileQueue: this.tileQueue_,
            time: time,
            usedTiles: {},
            viewState: viewState,
            viewHints: viewHints,
            wantedTiles: {}
          });
        }

        if (frameState) {
          frameState.extent = getForViewAndSize(viewState.center,
            viewState.resolution, viewState.rotation, frameState.size, extent);
        }

        this.frameState_ = frameState;
        this.renderer_.renderFrame(frameState);

        if (frameState) {
          if (frameState.animate) {
            this.render();
          }
          Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

          if (previousFrameState) {
            var moveStart = !this.previousExtent_ ||
                        (!isEmpty$1(this.previousExtent_) &&
                        !equals$2(frameState.extent, this.previousExtent_));
            if (moveStart) {
              this.dispatchEvent(
                new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
              this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
            }
          }

          var idle = this.previousExtent_ &&
              !frameState.viewHints[ViewHint.ANIMATING] &&
              !frameState.viewHints[ViewHint.INTERACTING] &&
              !equals$2(frameState.extent, this.previousExtent_);

          if (idle) {
            this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
            clone(frameState.extent, this.previousExtent_);
          }
        }

        this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));

        setTimeout(this.handlePostRender.bind(this), 0);

      };

      /**
       * Sets the layergroup of this map.
       * @param {module:ol/layer/Group} layerGroup A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setLayerGroup = function setLayerGroup (layerGroup) {
        this.set(MapProperty.LAYERGROUP, layerGroup);
      };

      /**
       * Set the size of this map.
       * @param {module:ol/size~Size|undefined} size The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.setSize = function setSize (size) {
        this.set(MapProperty.SIZE, size);
      };

      /**
       * Set the target element to render this map into.
       * @param {HTMLElement|string|undefined} target The Element or id of the Element
       *     that the map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.setTarget = function setTarget (target) {
        this.set(MapProperty.TARGET, target);
      };

      /**
       * Set the view for this map.
       * @param {module:ol/View} view The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setView = function setView (view) {
        this.set(MapProperty.VIEW, view);
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       */
      PluggableMap.prototype.skipFeature = function skipFeature (feature) {
        var featureUid = getUid(feature).toString();
        this.skippedFeatureUids_[featureUid] = true;
        this.render();
      };

      /**
       * Force a recalculation of the map viewport size.  This should be called when
       * third-party code changes the size of the map viewport.
       * @api
       */
      PluggableMap.prototype.updateSize = function updateSize () {
        var targetElement = this.getTargetElement();

        if (!targetElement) {
          this.setSize(undefined);
        } else {
          var computedStyle = getComputedStyle(targetElement);
          this.setSize([
            targetElement.offsetWidth -
                parseFloat(computedStyle['borderLeftWidth']) -
                parseFloat(computedStyle['paddingLeft']) -
                parseFloat(computedStyle['paddingRight']) -
                parseFloat(computedStyle['borderRightWidth']),
            targetElement.offsetHeight -
                parseFloat(computedStyle['borderTopWidth']) -
                parseFloat(computedStyle['paddingTop']) -
                parseFloat(computedStyle['paddingBottom']) -
                parseFloat(computedStyle['borderBottomWidth'])
          ]);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       */
      PluggableMap.prototype.unskipFeature = function unskipFeature (feature) {
        var featureUid = getUid(feature).toString();
        delete this.skippedFeatureUids_[featureUid];
        this.render();
      };

      return PluggableMap;
    }(BaseObject));


    /**
     * @param {MapOptions} options Map options.
     * @return {module:ol/PluggableMap~MapOptionsInternal} Internal map options.
     */
    function createOptionsInternal(options) {

      /**
       * @type {HTMLElement|Document}
       */
      var keyboardEventTarget = null;
      if (options.keyboardEventTarget !== undefined) {
        keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ?
          document.getElementById(options.keyboardEventTarget) :
          options.keyboardEventTarget;
      }

      /**
       * @type {Object.<string, *>}
       */
      var values = {};

      var layerGroup = (options.layers instanceof LayerGroup) ?
        options.layers : new LayerGroup({layers: options.layers});
      values[MapProperty.LAYERGROUP] = layerGroup;

      values[MapProperty.TARGET] = options.target;

      values[MapProperty.VIEW] = options.view !== undefined ?
        options.view : new View();

      var controls;
      if (options.controls !== undefined) {
        if (Array.isArray(options.controls)) {
          controls = new Collection(options.controls.slice());
        } else {
          assert(options.controls instanceof Collection,
            47); // Expected `controls` to be an array or an `module:ol/Collection~Collection`
          controls = options.controls;
        }
      }

      var interactions;
      if (options.interactions !== undefined) {
        if (Array.isArray(options.interactions)) {
          interactions = new Collection(options.interactions.slice());
        } else {
          assert(options.interactions instanceof Collection,
            48); // Expected `interactions` to be an array or an `module:ol/Collection~Collection`
          interactions = options.interactions;
        }
      }

      var overlays;
      if (options.overlays !== undefined) {
        if (Array.isArray(options.overlays)) {
          overlays = new Collection(options.overlays.slice());
        } else {
          assert(options.overlays instanceof Collection,
            49); // Expected `overlays` to be an array or an `module:ol/Collection~Collection`
          overlays = options.overlays;
        }
      } else {
        overlays = new Collection();
      }

      return {
        controls: controls,
        interactions: interactions,
        keyboardEventTarget: keyboardEventTarget,
        overlays: overlays,
        values: values
      };

    }

    /**
     * @module ol/control/Control
     */


    /**
     * @typedef {Object} Options
     * @property {HTMLElement} [element] The element is the control's
     * container element. This only needs to be specified if you're developing
     * a custom control.
     * @property {function(module:ol/MapEvent)} [render] Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     * @property {HTMLElement|string} [target] Specify a target if you want
     * the control to be rendered outside of the map's viewport.
     */


    /**
     * @classdesc
     * A control is a visible widget with a DOM element in a fixed position on the
     * screen. They can involve user input (buttons), or be informational only;
     * the position is determined using CSS. By default these are placed in the
     * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
     * any outside DOM element.
     *
     * This is the base class for controls. You can use it for simple custom
     * controls by creating the element with listeners, creating an instance:
     * ```js
     * var myControl = new Control({element: myElement});
     * ```
     * and then adding this to the map.
     *
     * The main advantage of having this as a control rather than a simple separate
     * DOM element is that preventing propagation is handled for you. Controls
     * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
     *
     * You can also extend this base for your own control class. See
     * examples/custom-controls for an example of how to do this.
     *
     * @api
     */
    var Control = (function (BaseObject$$1) {
      function Control(options) {

        BaseObject$$1.call(this);

        /**
         * @protected
         * @type {HTMLElement}
         */
        this.element = options.element ? options.element : null;

        /**
         * @private
         * @type {HTMLElement}
         */
        this.target_ = null;

        /**
         * @private
         * @type {module:ol/PluggableMap}
         */
        this.map_ = null;

        /**
         * @protected
         * @type {!Array.<module:ol/events~EventsKey>}
         */
        this.listenerKeys = [];

        /**
         * @type {function(module:ol/MapEvent)}
         */
        this.render = options.render ? options.render : UNDEFINED;

        if (options.target) {
          this.setTarget(options.target);
        }

      }

      if ( BaseObject$$1 ) Control.__proto__ = BaseObject$$1;
      Control.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Control.prototype.constructor = Control;

      /**
       * @inheritDoc
       */
      Control.prototype.disposeInternal = function disposeInternal () {
        removeNode(this.element);
        BaseObject$$1.prototype.disposeInternal.call(this);
      };

      /**
       * Get the map associated with this control.
       * @return {module:ol/PluggableMap} Map.
       * @api
       */
      Control.prototype.getMap = function getMap () {
        return this.map_;
      };

      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {module:ol/PluggableMap} map Map.
       * @api
       */
      Control.prototype.setMap = function setMap (map) {
        var this$1 = this;

        if (this.map_) {
          removeNode(this.element);
        }
        for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this$1.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (this.map_) {
          var target = this.target_ ?
            this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);
          if (this.render !== UNDEFINED) {
            this.listenerKeys.push(listen(map,
              MapEventType.POSTRENDER, this.render, this));
          }
          map.render();
        }
      };

      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      Control.prototype.setTarget = function setTarget (target) {
        this.target_ = typeof target === 'string' ?
          document.getElementById(target) :
          target;
      };

      return Control;
    }(BaseObject));

    /**
     * @module ol/css
     */


    /**
     * The CSS class for hidden feature.
     *
     * @const
     * @type {string}
     */
    var CLASS_HIDDEN = 'ol-hidden';


    /**
     * The CSS class that we'll give the DOM elements to have them unselectable.
     *
     * @const
     * @type {string}
     */
    var CLASS_UNSELECTABLE = 'ol-unselectable';


    /**
     * The CSS class for controls.
     *
     * @const
     * @type {string}
     */
    var CLASS_CONTROL = 'ol-control';


    /**
     * The CSS class that we'll give the DOM elements that are collapsed, i.e.
     * to those elements which usually can be expanded.
     *
     * @const
     * @type {string}
     */
    var CLASS_COLLAPSED = 'ol-collapsed';


    /**
     * Get the list of font families from a font spec.  Note that this doesn't work
     * for font families that have commas in them.
     * @param {string} The CSS font property.
     * @return {Object.<string>} The font families (or null if the input spec is invalid).
     */
    var getFontFamilies = (function() {
      var style;
      var cache = {};
      return function(font) {
        if (!style) {
          style = document.createElement('div').style;
        }
        if (!(font in cache)) {
          style.font = font;
          var family = style.fontFamily;
          style.font = '';
          if (!family) {
            return null;
          }
          cache[font] = family.split(/,\s?/);
        }
        return cache[font];
      };
    })();

    /**
     * @module ol/control/Attribution
     */


    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-attribution'] CSS class name.
     * @property {HTMLElement|string} [target] Specify a target if you
     * want the control to be rendered outside of the map's
     * viewport.
     * @property {boolean} [collapsible=true] Specify if attributions can
     * be collapsed. If you use an OSM source, should be set to `false` — see
     * {@link https://www.openstreetmap.org/copyright OSM Copyright} —
     * @property {boolean} [collapsed=true] Specify if attributions should
     * be collapsed at startup.
     * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
     * @property {string} [label='i'] Text label to use for the
     * collapsed attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
     * for the expanded attributions button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {function(module:ol/MapEvent)} [render] Function called when
     * the control should be re-rendered. This is called in a `requestAnimationFrame`
     * callback.
     */


    /**
     * @classdesc
     * Control to show all the attributions associated with the layer sources
     * in the map. This control is one of the default controls included in maps.
     * By default it will show in the bottom right portion of the map, but this can
     * be changed by using a css selector for `.ol-attribution`.
     *
     * @api
     */
    var Attribution = (function (Control$$1) {
      function Attribution(opt_options) {

        var options = opt_options ? opt_options : {};

        Control$$1.call(this, {
          element: document.createElement('div'),
          render: options.render || render,
          target: options.target
        });

        /**
         * @private
         * @type {HTMLElement}
         */
        this.ulElement_ = document.createElement('UL');

        /**
         * @private
         * @type {boolean}
         */
        this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

        /**
         * @private
         * @type {boolean}
         */
        this.collapsible_ = options.collapsible !== undefined ?
          options.collapsible : true;

        if (!this.collapsible_) {
          this.collapsed_ = false;
        }

        var className = options.className !== undefined ? options.className : 'ol-attribution';

        var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

        var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

        if (typeof collapseLabel === 'string') {
          /**
           * @private
           * @type {HTMLElement}
           */
          this.collapseLabel_ = document.createElement('span');
          this.collapseLabel_.textContent = collapseLabel;
        } else {
          this.collapseLabel_ = collapseLabel;
        }

        var label = options.label !== undefined ? options.label : 'i';

        if (typeof label === 'string') {
          /**
           * @private
           * @type {HTMLElement}
           */
          this.label_ = document.createElement('span');
          this.label_.textContent = label;
        } else {
          this.label_ = label;
        }


        var activeLabel = (this.collapsible_ && !this.collapsed_) ?
          this.collapseLabel_ : this.label_;
        var button = document.createElement('button');
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(activeLabel);

        listen(button, EventType.CLICK, this.handleClick_, this);

        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL +
            (this.collapsed_ && this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
            (this.collapsible_ ? '' : ' ol-uncollapsible');
        var element = this.element;
        element.className = cssClasses;
        element.appendChild(this.ulElement_);
        element.appendChild(button);

        /**
         * A list of currently rendered resolutions.
         * @type {Array.<string>}
         * @private
         */
        this.renderedAttributions_ = [];

        /**
         * @private
         * @type {boolean}
         */
        this.renderedVisible_ = true;

      }

      if ( Control$$1 ) Attribution.__proto__ = Control$$1;
      Attribution.prototype = Object.create( Control$$1 && Control$$1.prototype );
      Attribution.prototype.constructor = Attribution;

      /**
       * Get a list of visible attributions.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @return {Array.<string>} Attributions.
       * @private
       */
      Attribution.prototype.getSourceAttributions_ = function getSourceAttributions_ (frameState) {
        /**
         * Used to determine if an attribution already exists.
         * @type {!Object.<string, boolean>}
         */
        var lookup = {};

        /**
         * A list of visible attributions.
         * @type {Array.<string>}
         */
        var visibleAttributions = [];

        var layerStatesArray = frameState.layerStatesArray;
        var resolution = frameState.viewState.resolution;
        for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
          var layerState = layerStatesArray[i];
          if (!visibleAtResolution(layerState, resolution)) {
            continue;
          }

          var source = layerState.layer.getSource();
          if (!source) {
            continue;
          }

          var attributionGetter = source.getAttributions();
          if (!attributionGetter) {
            continue;
          }

          var attributions = attributionGetter(frameState);
          if (!attributions) {
            continue;
          }

          if (Array.isArray(attributions)) {
            for (var j = 0, jj = attributions.length; j < jj; ++j) {
              if (!(attributions[j] in lookup)) {
                visibleAttributions.push(attributions[j]);
                lookup[attributions[j]] = true;
              }
            }
          } else {
            if (!(attributions in lookup)) {
              visibleAttributions.push(attributions);
              lookup[attributions] = true;
            }
          }
        }
        return visibleAttributions;
      };

      /**
       * @private
       * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.
       */
      Attribution.prototype.updateElement_ = function updateElement_ (frameState) {
        var this$1 = this;

        if (!frameState) {
          if (this.renderedVisible_) {
            this.element.style.display = 'none';
            this.renderedVisible_ = false;
          }
          return;
        }

        var attributions = this.getSourceAttributions_(frameState);

        var visible = attributions.length > 0;
        if (this.renderedVisible_ != visible) {
          this.element.style.display = visible ? '' : 'none';
          this.renderedVisible_ = visible;
        }

        if (equals(attributions, this.renderedAttributions_)) {
          return;
        }

        removeChildren(this.ulElement_);

        // append the attributions
        for (var i = 0, ii = attributions.length; i < ii; ++i) {
          var element = document.createElement('LI');
          element.innerHTML = attributions[i];
          this$1.ulElement_.appendChild(element);
        }

        this.renderedAttributions_ = attributions;
      };

      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Attribution.prototype.handleClick_ = function handleClick_ (event) {
        event.preventDefault();
        this.handleToggle_();
      };

      /**
       * @private
       */
      Attribution.prototype.handleToggle_ = function handleToggle_ () {
        this.element.classList.toggle(CLASS_COLLAPSED);
        if (this.collapsed_) {
          replaceNode(this.collapseLabel_, this.label_);
        } else {
          replaceNode(this.label_, this.collapseLabel_);
        }
        this.collapsed_ = !this.collapsed_;
      };

      /**
       * Return `true` if the attribution is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.getCollapsible = function getCollapsible () {
        return this.collapsible_;
      };

      /**
       * Set whether the attribution should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.setCollapsible = function setCollapsible (collapsible) {
        if (this.collapsible_ === collapsible) {
          return;
        }
        this.collapsible_ = collapsible;
        this.element.classList.toggle('ol-uncollapsible');
        if (!collapsible && this.collapsed_) {
          this.handleToggle_();
        }
      };

      /**
       * Collapse or expand the attribution according to the passed parameter. Will
       * not do anything if the attribution isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.setCollapsed = function setCollapsed (collapsed) {
        if (!this.collapsible_ || this.collapsed_ === collapsed) {
          return;
        }
        this.handleToggle_();
      };

      /**
       * Return `true` when the attribution is currently collapsed or `false`
       * otherwise.
       * @return {boolean} True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.getCollapsed = function getCollapsed () {
        return this.collapsed_;
      };

      return Attribution;
    }(Control));


    /**
     * Update the attribution element.
     * @param {module:ol/MapEvent} mapEvent Map event.
     * @this {module:ol/control/Attribution}
     * @api
     */
    function render(mapEvent) {
      this.updateElement_(mapEvent.frameState);
    }

    /**
     * @module ol/control/Rotate
     */


    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-rotate'] CSS class name.
     * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
     * @property {function(module:ol/MapEvent)} [render] Function called when the control should
     * be re-rendered. This is called in a `requestAnimationFrame` callback.
     * @property {function()} [resetNorth] Function called when the control is clicked.
     * This will override the default `resetNorth`.
     * @property {HTMLElement|string} [target] Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */


    /**
     * @classdesc
     * A button control to reset rotation to 0.
     * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
     * selector is added to the button when the rotation is 0.
     *
     * @api
     */
    var Rotate = (function (Control$$1) {
      function Rotate(opt_options) {

        var options = opt_options ? opt_options : {};

        Control$$1.call(this, {
          element: document.createElement('div'),
          render: options.render || render$1,
          target: options.target
        });

        var className = options.className !== undefined ? options.className : 'ol-rotate';

        var label = options.label !== undefined ? options.label : '\u21E7';

        /**
         * @type {HTMLElement}
         * @private
         */
        this.label_ = null;

        if (typeof label === 'string') {
          this.label_ = document.createElement('span');
          this.label_.className = 'ol-compass';
          this.label_.textContent = label;
        } else {
          this.label_ = label;
          this.label_.classList.add('ol-compass');
        }

        var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

        var button = document.createElement('button');
        button.className = className + '-reset';
        button.setAttribute('type', 'button');
        button.title = tipLabel;
        button.appendChild(this.label_);

        listen(button, EventType.CLICK, this.handleClick_, this);

        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
        var element = this.element;
        element.className = cssClasses;
        element.appendChild(button);

        this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

        /**
         * @type {number}
         * @private
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

        /**
         * @type {boolean}
         * @private
         */
        this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

        /**
         * @private
         * @type {number|undefined}
         */
        this.rotation_ = undefined;

        if (this.autoHide_) {
          this.element.classList.add(CLASS_HIDDEN);
        }

      }

      if ( Control$$1 ) Rotate.__proto__ = Control$$1;
      Rotate.prototype = Object.create( Control$$1 && Control$$1.prototype );
      Rotate.prototype.constructor = Rotate;

      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Rotate.prototype.handleClick_ = function handleClick_ (event) {
        event.preventDefault();
        if (this.callResetNorth_ !== undefined) {
          this.callResetNorth_();
        } else {
          this.resetNorth_();
        }
      };

      /**
       * @private
       */
      Rotate.prototype.resetNorth_ = function resetNorth_ () {
        var map = this.getMap();
        var view = map.getView();
        if (!view) {
          // the map does not have a view, so we can't act
          // upon it
          return;
        }
        if (view.getRotation() !== undefined) {
          if (this.duration_ > 0) {
            view.animate({
              rotation: 0,
              duration: this.duration_,
              easing: easeOut
            });
          } else {
            view.setRotation(0);
          }
        }
      };

      return Rotate;
    }(Control));


    /**
     * Update the rotate control element.
     * @param {module:ol/MapEvent} mapEvent Map event.
     * @this {module:ol/control/Rotate}
     * @api
     */
    function render$1(mapEvent) {
      var frameState = mapEvent.frameState;
      if (!frameState) {
        return;
      }
      var rotation = frameState.viewState.rotation;
      if (rotation != this.rotation_) {
        var transform = 'rotate(' + rotation + 'rad)';
        if (this.autoHide_) {
          var contains = this.element.classList.contains(CLASS_HIDDEN);
          if (!contains && rotation === 0) {
            this.element.classList.add(CLASS_HIDDEN);
          } else if (contains && rotation !== 0) {
            this.element.classList.remove(CLASS_HIDDEN);
          }
        }
        this.label_.style.msTransform = transform;
        this.label_.style.webkitTransform = transform;
        this.label_.style.transform = transform;
      }
      this.rotation_ = rotation;
    }

    /**
     * @module ol/control/Zoom
     */


    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {string} [className='ol-zoom'] CSS class name.
     * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
     * button. Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
     * Instead of text, also an element (e.g. a `span` element) can be used.
     * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
     * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
     * @property {number} [delta=1] The zoom delta applied on each click.
     * @property {HTMLElement|string} [target] Specify a target if you want the control to be
     * rendered outside of the map's viewport.
     */


    /**
     * @classdesc
     * A control with 2 buttons, one for zoom in and one for zoom out.
     * This control is one of the default controls of a map. To style this control
     * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
     *
     * @api
     */
    var Zoom = (function (Control$$1) {
      function Zoom(opt_options) {

        var options = opt_options ? opt_options : {};

        Control$$1.call(this, {
          element: document.createElement('div'),
          target: options.target
        });

        var className = options.className !== undefined ? options.className : 'ol-zoom';

        var delta = options.delta !== undefined ? options.delta : 1;

        var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
        var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

        var zoomInTipLabel = options.zoomInTipLabel !== undefined ?
          options.zoomInTipLabel : 'Zoom in';
        var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ?
          options.zoomOutTipLabel : 'Zoom out';

        var inElement = document.createElement('button');
        inElement.className = className + '-in';
        inElement.setAttribute('type', 'button');
        inElement.title = zoomInTipLabel;
        inElement.appendChild(
          typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel
        );

        listen(inElement, EventType.CLICK, this.handleClick_.bind(this, delta));

        var outElement = document.createElement('button');
        outElement.className = className + '-out';
        outElement.setAttribute('type', 'button');
        outElement.title = zoomOutTipLabel;
        outElement.appendChild(
          typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel
        );

        listen(outElement, EventType.CLICK, this.handleClick_.bind(this, -delta));

        var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
        var element = this.element;
        element.className = cssClasses;
        element.appendChild(inElement);
        element.appendChild(outElement);

        /**
         * @type {number}
         * @private
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

      }

      if ( Control$$1 ) Zoom.__proto__ = Control$$1;
      Zoom.prototype = Object.create( Control$$1 && Control$$1.prototype );
      Zoom.prototype.constructor = Zoom;

      /**
       * @param {number} delta Zoom delta.
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Zoom.prototype.handleClick_ = function handleClick_ (delta, event) {
        event.preventDefault();
        this.zoomByDelta_(delta);
      };

      /**
       * @param {number} delta Zoom delta.
       * @private
       */
      Zoom.prototype.zoomByDelta_ = function zoomByDelta_ (delta) {
        var map = this.getMap();
        var view = map.getView();
        if (!view) {
          // the map does not have a view, so we can't act
          // upon it
          return;
        }
        var currentResolution = view.getResolution();
        if (currentResolution) {
          var newResolution = view.constrainResolution(currentResolution, delta);
          if (this.duration_ > 0) {
            if (view.getAnimating()) {
              view.cancelAnimations();
            }
            view.animate({
              resolution: newResolution,
              duration: this.duration_,
              easing: easeOut
            });
          } else {
            view.setResolution(newResolution);
          }
        }
      };

      return Zoom;
    }(Control));

    /**
     * @module ol/control/util
     */


    /**
     * @typedef {Object} DefaultsOptions
     * @property {boolean} [attribution=true] Include
     * {@link module:ol/control/Attribution~Attribution}.
     * @property {module:ol/control/Attribution~Options} [attributionOptions]
     * Options for {@link module:ol/control/Attribution~Attribution}.
     * @property {boolean} [rotate=true] Include
     * {@link module:ol/control/Rotate~Rotate}.
     * @property {module:ol/control/Rotate~Options} [rotateOptions] Options
     * for {@link module:ol/control/Rotate~Rotate}.
     * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
     * @property {module:ol/control/Zoom~Options} [zoomOptions] Options for
     * {@link module:ol/control/Zoom~Zoom}.
     * @api
     */


    /**
     * Set of controls included in maps by default. Unless configured otherwise,
     * this returns a collection containing an instance of each of the following
     * controls:
     * * {@link module:ol/control/Zoom~Zoom}
     * * {@link module:ol/control/Rotate~Rotate}
     * * {@link module:ol/control/Attribution~Attribution}
     *
     * @param {module:ol/control/util~DefaultsOptions=} opt_options
     * Defaults options.
     * @return {module:ol/Collection.<module:ol/control/Control>}
     * Controls.
     * @function module:ol/control.defaults
     * @api
     */
    function defaults(opt_options) {

      var options = opt_options ? opt_options : {};

      var controls = new Collection();

      var zoomControl = options.zoom !== undefined ? options.zoom : true;
      if (zoomControl) {
        controls.push(new Zoom(options.zoomOptions));
      }

      var rotateControl = options.rotate !== undefined ? options.rotate : true;
      if (rotateControl) {
        controls.push(new Rotate(options.rotateOptions));
      }

      var attributionControl = options.attribution !== undefined ?
        options.attribution : true;
      if (attributionControl) {
        controls.push(new Attribution(options.attributionOptions));
      }

      return controls;
    }

    /**
     * @module ol/Kinetic
     */

    /**
     * @classdesc
     * Implementation of inertial deceleration for map movement.
     *
     * @api
     */
    var Kinetic = function Kinetic(decay, minVelocity, delay) {

      /**
       * @private
       * @type {number}
       */
      this.decay_ = decay;

      /**
       * @private
       * @type {number}
       */
      this.minVelocity_ = minVelocity;

      /**
       * @private
       * @type {number}
       */
      this.delay_ = delay;

      /**
       * @private
       * @type {Array.<number>}
       */
      this.points_ = [];

      /**
       * @private
       * @type {number}
       */
      this.angle_ = 0;

      /**
       * @private
       * @type {number}
       */
      this.initialVelocity_ = 0;
    };

    /**
     * FIXME empty description for jsdoc
     */
    Kinetic.prototype.begin = function begin () {
      this.points_.length = 0;
      this.angle_ = 0;
      this.initialVelocity_ = 0;
    };

    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    Kinetic.prototype.update = function update (x, y) {
      this.points_.push(x, y, Date.now());
    };

    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    Kinetic.prototype.end = function end () {
      if (this.points_.length < 6) {
        // at least 2 points are required (i.e. there must be at least 6 elements
        // in the array)
        return false;
      }
      var delay = Date.now() - this.delay_;
      var lastIndex = this.points_.length - 3;
      if (this.points_[lastIndex + 2] < delay) {
        // the last tracked point is too old, which means that the user stopped
        // panning before releasing the map
        return false;
      }

      // get the first point which still falls into the delay time
      var firstIndex = lastIndex - 3;
      while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
        firstIndex -= 3;
      }

      var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
      // we don't want a duration of 0 (divide by zero)
      // we also make sure the user panned for a duration of at least one frame
      // (1/60s) to compute sane displacement values
      if (duration < 1000 / 60) {
        return false;
      }

      var dx = this.points_[lastIndex] - this.points_[firstIndex];
      var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
      this.angle_ = Math.atan2(dy, dx);
      this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
      return this.initialVelocity_ > this.minVelocity_;
    };

    /**
     * @return {number} Total distance travelled (pixels).
     */
    Kinetic.prototype.getDistance = function getDistance () {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    };

    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    Kinetic.prototype.getAngle = function getAngle () {
      return this.angle_;
    };

    /**
     * @module ol/interaction/Property
     */

    /**
     * @enum {string}
     */
    var InteractionProperty = {
      ACTIVE: 'active'
    };

    /**
     * @module ol/interaction/Interaction
     */


    /**
     * Object literal with config options for interactions.
     * @typedef {Object} InteractionOptions
     * @property {function(module:ol/MapBrowserEvent):boolean} handleEvent
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. If the function returns a falsy value, propagation of
     * the event to other interactions in the map's interactions chain will be
     * prevented (this includes functions with no explicit return).
     */


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * User actions that change the state of the map. Some are similar to controls,
     * but are not associated with a DOM element.
     * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
     * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
     * by a keyboard event not a button element event.
     * Although interactions do not have a DOM element, some of them do render
     * vectors and so are visible on the screen.
     * @api
     */
    var Interaction = (function (BaseObject$$1) {
      function Interaction(options) {
        BaseObject$$1.call(this);

        /**
         * @private
         * @type {module:ol/PluggableMap}
         */
        this.map_ = null;

        this.setActive(true);

        /**
         * @type {function(module:ol/MapBrowserEvent):boolean}
         */
        this.handleEvent = options.handleEvent;

      }

      if ( BaseObject$$1 ) Interaction.__proto__ = BaseObject$$1;
      Interaction.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Interaction.prototype.constructor = Interaction;

      /**
       * Return whether the interaction is currently active.
       * @return {boolean} `true` if the interaction is active, `false` otherwise.
       * @observable
       * @api
       */
      Interaction.prototype.getActive = function getActive () {
        return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));
      };

      /**
       * Get the map associated with this interaction.
       * @return {module:ol/PluggableMap} Map.
       * @api
       */
      Interaction.prototype.getMap = function getMap () {
        return this.map_;
      };

      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      Interaction.prototype.setActive = function setActive (active) {
        this.set(InteractionProperty.ACTIVE, active);
      };

      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {module:ol/PluggableMap} map Map.
       */
      Interaction.prototype.setMap = function setMap (map) {
        this.map_ = map;
      };

      return Interaction;
    }(BaseObject));


    /**
     * @param {module:ol/View} view View.
     * @param {module:ol/coordinate~Coordinate} delta Delta.
     * @param {number=} opt_duration Duration.
     */
    function pan(view, delta, opt_duration) {
      var currentCenter = view.getCenter();
      if (currentCenter) {
        var center = view.constrainCenter(
          [currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
        if (opt_duration) {
          view.animate({
            duration: opt_duration,
            easing: linear,
            center: center
          });
        } else {
          view.setCenter(center);
        }
      }
    }


    /**
     * @param {module:ol/View} view View.
     * @param {number|undefined} rotation Rotation.
     * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
     * @param {number=} opt_duration Duration.
     */
    function rotate$3(view, rotation, opt_anchor, opt_duration) {
      rotation = view.constrainRotation(rotation, 0);
      rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
    }


    /**
     * @param {module:ol/View} view View.
     * @param {number|undefined} rotation Rotation.
     * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
     * @param {number=} opt_duration Duration.
     */
    function rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration) {
      if (rotation !== undefined) {
        var currentRotation = view.getRotation();
        var currentCenter = view.getCenter();
        if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
          view.animate({
            rotation: rotation,
            anchor: opt_anchor,
            duration: opt_duration,
            easing: easeOut
          });
        } else {
          view.rotate(rotation, opt_anchor);
        }
      }
    }


    /**
     * @param {module:ol/View} view View.
     * @param {number|undefined} resolution Resolution to go to.
     * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
     * @param {number=} opt_duration Duration.
     * @param {number=} opt_direction Zooming direction; > 0 indicates
     *     zooming out, in which case the constraints system will select
     *     the largest nearest resolution; < 0 indicates zooming in, in
     *     which case the constraints system will select the smallest
     *     nearest resolution; == 0 indicates that the zooming direction
     *     is unknown/not relevant, in which case the constraints system
     *     will select the nearest resolution. If not defined 0 is
     *     assumed.
     */
    function zoom(view, resolution, opt_anchor, opt_duration, opt_direction) {
      resolution = view.constrainResolution(resolution, 0, opt_direction);
      zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
    }


    /**
     * @param {module:ol/View} view View.
     * @param {number} delta Delta from previous zoom level.
     * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
     * @param {number=} opt_duration Duration.
     */
    function zoomByDelta(view, delta, opt_anchor, opt_duration) {
      var currentResolution = view.getResolution();
      var resolution = view.constrainResolution(currentResolution, delta, 0);

      if (resolution !== undefined) {
        var resolutions = view.getResolutions();
        resolution = clamp(
          resolution,
          view.getMinResolution() || resolutions[resolutions.length - 1],
          view.getMaxResolution() || resolutions[0]);
      }

      // If we have a constraint on center, we need to change the anchor so that the
      // new center is within the extent. We first calculate the new center, apply
      // the constraint to it, and then calculate back the anchor
      if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
        var currentCenter = view.getCenter();
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        center = view.constrainCenter(center);

        opt_anchor = [
          (resolution * currentCenter[0] - currentResolution * center[0]) /
              (resolution - currentResolution),
          (resolution * currentCenter[1] - currentResolution * center[1]) /
              (resolution - currentResolution)
        ];
      }

      zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
    }


    /**
     * @param {module:ol/View} view View.
     * @param {number|undefined} resolution Resolution to go to.
     * @param {module:ol/coordinate~Coordinate=} opt_anchor Anchor coordinate.
     * @param {number=} opt_duration Duration.
     */
    function zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration) {
      if (resolution) {
        var currentResolution = view.getResolution();
        var currentCenter = view.getCenter();
        if (currentResolution !== undefined && currentCenter &&
            resolution !== currentResolution && opt_duration) {
          view.animate({
            resolution: resolution,
            anchor: opt_anchor,
            duration: opt_duration,
            easing: easeOut
          });
        } else {
          if (opt_anchor) {
            var center = view.calculateCenterZoom(resolution, opt_anchor);
            view.setCenter(center);
          }
          view.setResolution(resolution);
        }
      }
    }

    /**
     * @module ol/interaction/DoubleClickZoom
     */


    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {number} [delta=1] The zoom delta applied on each double click.
     */


    /**
     * @classdesc
     * Allows the user to zoom by double-clicking on the map.
     * @api
     */
    var DoubleClickZoom = (function (Interaction$$1) {
      function DoubleClickZoom(opt_options) {
        Interaction$$1.call(this, {
          handleEvent: handleEvent
        });

        var options = opt_options ? opt_options : {};

        /**
         * @private
         * @type {number}
         */
        this.delta_ = options.delta ? options.delta : 1;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

      }

      if ( Interaction$$1 ) DoubleClickZoom.__proto__ = Interaction$$1;
      DoubleClickZoom.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      DoubleClickZoom.prototype.constructor = DoubleClickZoom;

      return DoubleClickZoom;
    }(Interaction));


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/DoubleClickZoom}
     */
    function handleEvent(mapBrowserEvent) {
      var stopEvent = false;
      var browserEvent = mapBrowserEvent.originalEvent;
      if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
        var map = mapBrowserEvent.map;
        var anchor = mapBrowserEvent.coordinate;
        var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
        var view = map.getView();
        zoomByDelta(view, delta, anchor, this.duration_);
        mapBrowserEvent.preventDefault();
        stopEvent = true;
      }
      return !stopEvent;
    }

    /**
     * @module ol/events/condition
     */


    /**
     * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
     * `{boolean}`. If the condition is met, true should be returned.
     *
     * @typedef {function(this: ?, module:ol/MapBrowserEvent): boolean} Condition
     */


    /**
     * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
     * additionally the shift-key is pressed).
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if only the alt key is pressed.
     * @api
     */
    var altKeyOnly = function(mapBrowserEvent) {
      var originalEvent = mapBrowserEvent.originalEvent;
      return (
        originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
    };


    /**
     * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
     * (e.g. when additionally the platform-modifier-key is pressed).
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if only the alt and shift keys are pressed.
     * @api
     */
    var altShiftKeysOnly = function(mapBrowserEvent) {
      var originalEvent = mapBrowserEvent.originalEvent;
      return (
        originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
    };


    /**
     * Return always true.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True.
     * @function
     * @api
     */
    var always = TRUE;


    /**
     * Return `true` if the event has an "action"-producing mouse button.
     *
     * By definition, this includes left-click on windows/linux, and left-click
     * without the ctrl key on Macs.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} The result.
     */
    var mouseActionButton = function(mapBrowserEvent) {
      var originalEvent = mapBrowserEvent.originalEvent;
      return originalEvent.button == 0 &&
          !(WEBKIT && MAC && originalEvent.ctrlKey);
    };


    /**
     * Return always false.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} False.
     * @function
     * @api
     */
    var never = FALSE;


    /**
     * Return `true` if the browser event is a `pointermove` event, `false`
     * otherwise.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if the browser event is a `pointermove` event.
     * @api
     */
    var pointerMove$1 = function(mapBrowserEvent) {
      return mapBrowserEvent.type == 'pointermove';
    };


    /**
     * Return `true` if the event is a map `singleclick` event, `false` otherwise.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if the event is a map `singleclick` event.
     * @api
     */
    var singleClick = function(mapBrowserEvent) {
      return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
    };


    /**
     * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
     * pressed.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True only if there no modifier keys are pressed.
     * @api
     */
    var noModifierKeys = function(mapBrowserEvent) {
      var originalEvent = mapBrowserEvent.originalEvent;
      return (
        !originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
    };


    /**
     * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
     * additionally the alt-key is pressed).
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if only the shift key is pressed.
     * @api
     */
    var shiftKeyOnly = function(mapBrowserEvent) {
      var originalEvent = mapBrowserEvent.originalEvent;
      return (
        !originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
    };


    /**
     * Return `true` if the target element is not editable, i.e. not a `<input>`-,
     * `<select>`- or `<textarea>`-element, `false` otherwise.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True only if the target element is not editable.
     * @api
     */
    var targetNotEditable = function(mapBrowserEvent) {
      var target = mapBrowserEvent.originalEvent.target;
      var tagName = target.tagName;
      return (
        tagName !== 'INPUT' &&
          tagName !== 'SELECT' &&
          tagName !== 'TEXTAREA');
    };


    /**
     * Return `true` if the event originates from a mouse device.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if the event originates from a mouse device.
     * @api
     */
    var mouseOnly = function(mapBrowserEvent) {
      assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
      // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
      return (
        /** @type {module:ol/MapBrowserEvent} */ (mapBrowserEvent).pointerEvent.pointerType == 'mouse'
      );
    };


    /**
     * Return `true` if the event originates from a primary pointer in
     * contact with the surface or if the left mouse button is pressed.
     * See http://www.w3.org/TR/pointerevents/#button-states.
     *
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} True if the event originates from a primary pointer.
     * @api
     */
    var primaryAction = function(mapBrowserEvent) {
      var pointerEvent = mapBrowserEvent.pointerEvent;
      return pointerEvent.isPrimary && pointerEvent.button === 0;
    };

    /**
     * @module ol/interaction/Pointer
     */


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/Pointer}
     */
    var handleDragEvent = UNDEFINED;


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Capture dragging.
     * @this {module:ol/interaction/Pointer}
     */
    var handleUpEvent = FALSE;


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Capture dragging.
     * @this {module:ol/interaction/Pointer}
     */
    var handleDownEvent = FALSE;


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/Pointer}
     */
    var handleMoveEvent = UNDEFINED;


    /**
     * @typedef {Object} Options
     * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleDownEvent]
     * Function handling "down" events. If the function returns `true` then a drag
     * sequence is started.
     * @property {(function(module:ol/MapBrowserPointerEvent))} [handleDragEvent]
     * Function handling "drag" events. This function is called on "move" events
     * during a drag sequence.
     * @property {(function(module:ol/MapBrowserEvent):boolean)} [handleEvent]
     * Method called by the map to notify the interaction that a browser event was
     * dispatched to the map. The function may return `false` to prevent the
     * propagation of the event to other interactions in the map's interactions
     * chain.
     * @property {(function(module:ol/MapBrowserPointerEvent))} [handleMoveEvent]
     * Function handling "move" events. This function is called on "move" events,
     * also during a drag sequence (so during a drag sequence both the
     * `handleDragEvent` function and this function are called).
     * @property {(function(module:ol/MapBrowserPointerEvent):boolean)} [handleUpEvent]
     *  Function handling "up" events. If the function returns `false` then the
     * current drag sequence is stopped.
     * @property {function(boolean):boolean} stopDown
     * Should the down event be propagated to other interactions, or should be
     * stopped?
     */


    /**
     * @classdesc
     * Base class that calls user-defined functions on `down`, `move` and `up`
     * events. This class also manages "drag sequences".
     *
     * When the `handleDownEvent` user function returns `true` a drag sequence is
     * started. During a drag sequence the `handleDragEvent` user function is
     * called on `move` events. The drag sequence ends when the `handleUpEvent`
     * user function is called and returns `false`.
     * @api
     */
    var PointerInteraction = (function (Interaction$$1) {
      function PointerInteraction(opt_options) {

        var options = opt_options ? opt_options : {};

        Interaction$$1.call(this, {
          handleEvent: options.handleEvent || handleEvent$1
        });

        /**
         * @type {function(module:ol/MapBrowserPointerEvent):boolean}
         * @private
         */
        this.handleDownEvent_ = options.handleDownEvent ?
          options.handleDownEvent : handleDownEvent;

        /**
         * @type {function(module:ol/MapBrowserPointerEvent)}
         * @private
         */
        this.handleDragEvent_ = options.handleDragEvent ?
          options.handleDragEvent : handleDragEvent;

        /**
         * @type {function(module:ol/MapBrowserPointerEvent)}
         * @private
         */
        this.handleMoveEvent_ = options.handleMoveEvent ?
          options.handleMoveEvent : handleMoveEvent;

        /**
         * @type {function(module:ol/MapBrowserPointerEvent):boolean}
         * @private
         */
        this.handleUpEvent_ = options.handleUpEvent ?
          options.handleUpEvent : handleUpEvent;

        /**
         * @type {boolean}
         * @protected
         */
        this.handlingDownUpSequence = false;

        /**
         * This function is used to determine if "down" events should be propagated
         * to other interactions or should be stopped.
         * @type {function(boolean):boolean}
         * @protected
         */
        this.stopDown = options.stopDown ? options.stopDown : stopDown;

        /**
         * @type {!Object.<string, module:ol/pointer/PointerEvent>}
         * @private
         */
        this.trackedPointers_ = {};

        /**
         * @type {Array.<module:ol/pointer/PointerEvent>}
         * @protected
         */
        this.targetPointers = [];

      }

      if ( Interaction$$1 ) PointerInteraction.__proto__ = Interaction$$1;
      PointerInteraction.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      PointerInteraction.prototype.constructor = PointerInteraction;

      /**
       * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
       * @private
       */
      PointerInteraction.prototype.updateTrackedPointers_ = function updateTrackedPointers_ (mapBrowserEvent) {
        if (isPointerDraggingEvent(mapBrowserEvent)) {
          var event = mapBrowserEvent.pointerEvent;

          var id = event.pointerId.toString();
          if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
            delete this.trackedPointers_[id];
          } else if (mapBrowserEvent.type ==
              MapBrowserEventType.POINTERDOWN) {
            this.trackedPointers_[id] = event;
          } else if (id in this.trackedPointers_) {
            // update only when there was a pointerdown event for this pointer
            this.trackedPointers_[id] = event;
          }
          this.targetPointers = getValues(this.trackedPointers_);
        }
      };

      return PointerInteraction;
    }(Interaction));


    /**
     * @param {Array.<module:ol/pointer/PointerEvent>} pointerEvents List of events.
     * @return {module:ol/pixel~Pixel} Centroid pixel.
     */
    function centroid(pointerEvents) {
      var length = pointerEvents.length;
      var clientX = 0;
      var clientY = 0;
      for (var i = 0; i < length; i++) {
        clientX += pointerEvents[i].clientX;
        clientY += pointerEvents[i].clientY;
      }
      return [clientX / length, clientY / length];
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Whether the event is a pointerdown, pointerdrag
     *     or pointerup event.
     */
    function isPointerDraggingEvent(mapBrowserEvent) {
      var type = mapBrowserEvent.type;
      return type === MapBrowserEventType.POINTERDOWN ||
        type === MapBrowserEventType.POINTERDRAG ||
        type === MapBrowserEventType.POINTERUP;
    }


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/Pointer}
     * @api
     */
    function handleEvent$1(mapBrowserEvent) {
      if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {
        return true;
      }

      var stopEvent = false;
      this.updateTrackedPointers_(mapBrowserEvent);
      if (this.handlingDownUpSequence) {
        if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
          this.handleDragEvent_(mapBrowserEvent);
        } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
          var handledUp = this.handleUpEvent_(mapBrowserEvent);
          this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
        }
      } else {
        if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
          var handled = this.handleDownEvent_(mapBrowserEvent);
          this.handlingDownUpSequence = handled;
          stopEvent = this.stopDown(handled);
        } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
          this.handleMoveEvent_(mapBrowserEvent);
        }
      }
      return !stopEvent;
    }

    /**
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    function stopDown(handled) {
      return handled;
    }

    /**
     * @module ol/interaction/DragPan
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~noModifierKeys}.
     * @property {module:ol/Kinetic} [kinetic] Kinetic inertia to apply to the pan.
     */


    /**
     * @classdesc
     * Allows the user to pan the map by dragging the map.
     * @api
     */
    var DragPan = (function (PointerInteraction$$1) {
      function DragPan(opt_options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$1,
          handleDragEvent: handleDragEvent$1,
          handleUpEvent: handleUpEvent$1,
          stopDown: FALSE
        });

        var options = opt_options ? opt_options : {};

        /**
         * @private
         * @type {module:ol/Kinetic|undefined}
         */
        this.kinetic_ = options.kinetic;

        /**
         * @type {module:ol/pixel~Pixel}
         */
        this.lastCentroid = null;

        /**
         * @type {number}
         */
        this.lastPointersCount_;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : noModifierKeys;

        /**
         * @private
         * @type {boolean}
         */
        this.noKinetic_ = false;

      }

      if ( PointerInteraction$$1 ) DragPan.__proto__ = PointerInteraction$$1;
      DragPan.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      DragPan.prototype.constructor = DragPan;

      return DragPan;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/DragPan}
     */
    function handleDragEvent$1(mapBrowserEvent) {
      var targetPointers = this.targetPointers;
      var centroid$$1 = centroid(targetPointers);
      if (targetPointers.length == this.lastPointersCount_) {
        if (this.kinetic_) {
          this.kinetic_.update(centroid$$1[0], centroid$$1[1]);
        }
        if (this.lastCentroid) {
          var deltaX = this.lastCentroid[0] - centroid$$1[0];
          var deltaY = centroid$$1[1] - this.lastCentroid[1];
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var center = [deltaX, deltaY];
          scale(center, view.getResolution());
          rotate(center, view.getRotation());
          add(center, view.getCenter());
          center = view.constrainCenter(center);
          view.setCenter(center);
        }
      } else if (this.kinetic_) {
        // reset so we don't overestimate the kinetic energy after
        // after one finger down, tiny drag, second finger down
        this.kinetic_.begin();
      }
      this.lastCentroid = centroid$$1;
      this.lastPointersCount_ = targetPointers.length;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/DragPan}
     */
    function handleUpEvent$1(mapBrowserEvent) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          var distance$$1 = this.kinetic_.getDistance();
          var angle = this.kinetic_.getAngle();
          var center = /** @type {!module:ol/coordinate~Coordinate} */ (view.getCenter());
          var centerpx = map.getPixelFromCoordinate(center);
          var dest = map.getCoordinateFromPixel([
            centerpx[0] - distance$$1 * Math.cos(angle),
            centerpx[1] - distance$$1 * Math.sin(angle)
          ]);
          view.animate({
            center: view.constrainCenter(dest),
            duration: 500,
            easing: easeOut
          });
        }
        view.setHint(ViewHint.INTERACTING, -1);
        return false;
      } else {
        if (this.kinetic_) {
          // reset so we don't overestimate the kinetic energy after
          // after one finger up, tiny drag, second finger up
          this.kinetic_.begin();
        }
        this.lastCentroid = null;
        return true;
      }
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/DragPan}
     */
    function handleDownEvent$1(mapBrowserEvent) {
      if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        this.lastCentroid = null;
        if (!this.handlingDownUpSequence) {
          view.setHint(ViewHint.INTERACTING, 1);
        }
        // stop any current animation
        if (view.getAnimating()) {
          view.setCenter(mapBrowserEvent.frameState.viewState.center);
        }
        if (this.kinetic_) {
          this.kinetic_.begin();
        }
        // No kinetic as soon as more than one pointer on the screen is
        // detected. This is to prevent nasty pans after pinch.
        this.noKinetic_ = this.targetPointers.length > 1;
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/interaction/DragRotate
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that takes an
     * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
     * @property {number} [duration=250] Animation duration in milliseconds.
     */


    /**
     * @classdesc
     * Allows the user to rotate the map by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when the alt and shift keys are held down.
     *
     * This interaction is only supported for mouse devices.
     * @api
     */
    var DragRotate = (function (PointerInteraction$$1) {
      function DragRotate(opt_options) {

        var options = opt_options ? opt_options : {};

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$2,
          handleDragEvent: handleDragEvent$2,
          handleUpEvent: handleUpEvent$2,
          stopDown: FALSE
        });

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : altShiftKeysOnly;

        /**
         * @private
         * @type {number|undefined}
         */
        this.lastAngle_ = undefined;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

      }

      if ( PointerInteraction$$1 ) DragRotate.__proto__ = PointerInteraction$$1;
      DragRotate.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      DragRotate.prototype.constructor = DragRotate;

      return DragRotate;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/DragRotate}
     */
    function handleDragEvent$2(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return;
      }

      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (view.getConstraints().rotation === disable) {
        return;
      }
      var size = map.getSize();
      var offset = mapBrowserEvent.pixel;
      var theta =
          Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
      if (this.lastAngle_ !== undefined) {
        var delta = theta - this.lastAngle_;
        var rotation = view.getRotation();
        rotateWithoutConstraints(view, rotation - delta);
      }
      this.lastAngle_ = theta;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/DragRotate}
     */
    function handleUpEvent$2(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return true;
      }

      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(ViewHint.INTERACTING, -1);
      var rotation = view.getRotation();
      rotate$3(view, rotation, undefined, this.duration_);
      return false;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/DragRotate}
     */
    function handleDownEvent$2(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return false;
      }

      if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
        var map = mapBrowserEvent.map;
        map.getView().setHint(ViewHint.INTERACTING, 1);
        this.lastAngle_ = undefined;
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/render/Box
     */

    var RenderBox = (function (Disposable$$1) {
      function RenderBox(className) {
        Disposable$$1.call(this);

        /**
         * @type {module:ol/geom/Polygon}
         * @private
         */
        this.geometry_ = null;

        /**
         * @type {HTMLDivElement}
         * @private
         */
        this.element_ = /** @type {HTMLDivElement} */ (document.createElement('div'));
        this.element_.style.position = 'absolute';
        this.element_.className = 'ol-box ' + className;

        /**
         * @private
         * @type {module:ol/PluggableMap}
         */
        this.map_ = null;

        /**
         * @private
         * @type {module:ol/pixel~Pixel}
         */
        this.startPixel_ = null;

        /**
         * @private
         * @type {module:ol/pixel~Pixel}
         */
        this.endPixel_ = null;

      }

      if ( Disposable$$1 ) RenderBox.__proto__ = Disposable$$1;
      RenderBox.prototype = Object.create( Disposable$$1 && Disposable$$1.prototype );
      RenderBox.prototype.constructor = RenderBox;

      /**
       * @inheritDoc
       */
      RenderBox.prototype.disposeInternal = function disposeInternal () {
        this.setMap(null);
      };

      /**
       * @private
       */
      RenderBox.prototype.render_ = function render_ () {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var px = 'px';
        var style = this.element_.style;
        style.left = Math.min(startPixel[0], endPixel[0]) + px;
        style.top = Math.min(startPixel[1], endPixel[1]) + px;
        style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
        style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
      };

      /**
       * @param {module:ol/PluggableMap} map Map.
       */
      RenderBox.prototype.setMap = function setMap (map) {
        if (this.map_) {
          this.map_.getOverlayContainer().removeChild(this.element_);
          var style = this.element_.style;
          style.left = style.top = style.width = style.height = 'inherit';
        }
        this.map_ = map;
        if (this.map_) {
          this.map_.getOverlayContainer().appendChild(this.element_);
        }
      };

      /**
       * @param {module:ol/pixel~Pixel} startPixel Start pixel.
       * @param {module:ol/pixel~Pixel} endPixel End pixel.
       */
      RenderBox.prototype.setPixels = function setPixels (startPixel, endPixel) {
        this.startPixel_ = startPixel;
        this.endPixel_ = endPixel;
        this.createOrUpdateGeometry();
        this.render_();
      };

      /**
       * Creates or updates the cached geometry.
       */
      RenderBox.prototype.createOrUpdateGeometry = function createOrUpdateGeometry () {
        var startPixel = this.startPixel_;
        var endPixel = this.endPixel_;
        var pixels = [
          startPixel,
          [startPixel[0], endPixel[1]],
          endPixel,
          [endPixel[0], startPixel[1]]
        ];
        var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
        // close the polygon
        coordinates[4] = coordinates[0].slice();
        if (!this.geometry_) {
          this.geometry_ = new Polygon([coordinates]);
        } else {
          this.geometry_.setCoordinates([coordinates]);
        }
      };

      /**
       * @return {module:ol/geom/Polygon} Geometry.
       */
      RenderBox.prototype.getGeometry = function getGeometry () {
        return this.geometry_;
      };

      return RenderBox;
    }(Disposable));

    /**
     * @module ol/interaction/DragBox
     */


    /**
     * A function that takes a {@link module:ol/MapBrowserEvent} and two
     * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
     * true should be returned.
     * @typedef {function(this: ?, module:ol/MapBrowserEvent, module:ol/pixel~Pixel, module:ol/pixel~Pixel):boolean} EndCondition
     */


    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
     * @property {module:ol/events/condition~Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
     * to indicate whether that event should be handled.
     * Default is {@link ol/events/condition~always}.
     * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
     * `boxEndCondition` function.
     * @property {module:ol/interaction/DragBox~EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
     * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
     * Default is `true` if the area of the box is bigger than the `minArea` option.
     * @property {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)} onBoxEnd Code to execute just
     * before `boxend` is fired.
     */


    /**
     * @enum {string}
     */
    var DragBoxEventType = {
      /**
       * Triggered upon drag box start.
       * @event module:ol/interaction/DragBox~DragBoxEvent#boxstart
       * @api
       */
      BOXSTART: 'boxstart',

      /**
       * Triggered on drag when box is active.
       * @event module:ol/interaction/DragBox~DragBoxEvent#boxdrag
       * @api
       */
      BOXDRAG: 'boxdrag',

      /**
       * Triggered upon drag box end.
       * @event module:ol/interaction/DragBox~DragBoxEvent#boxend
       * @api
       */
      BOXEND: 'boxend'
    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
     * this type.
     */
    var DragBoxEvent = (function (Event$$1) {
      function DragBoxEvent(type, coordinate, mapBrowserEvent) {
        Event$$1.call(this, type);

        /**
         * The coordinate of the drag event.
         * @const
         * @type {module:ol/coordinate~Coordinate}
         * @api
         */
        this.coordinate = coordinate;

        /**
         * @const
         * @type {module:ol/MapBrowserEvent}
         * @api
         */
        this.mapBrowserEvent = mapBrowserEvent;

      }

      if ( Event$$1 ) DragBoxEvent.__proto__ = Event$$1;
      DragBoxEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      DragBoxEvent.prototype.constructor = DragBoxEvent;

      return DragBoxEvent;
    }(Event));


    /**
     * @classdesc
     * Allows the user to draw a vector box by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when the shift or other key is held down. This is used, for example,
     * for zooming to a specific area of the map
     * (see {@link module:ol/interaction/DragZoom~DragZoom} and
     * {@link module:ol/interaction/DragRotateAndZoom}).
     *
     * This interaction is only supported for mouse devices.
     *
     * @fires module:ol/interaction/DragBox~DragBoxEvent
     * @api
     */
    var DragBox = (function (PointerInteraction$$1) {
      function DragBox(opt_options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$3,
          handleDragEvent: handleDragEvent$3,
          handleUpEvent: handleUpEvent$3
        });

        var options = opt_options ? opt_options : {};

        /**
        * @type {module:ol/render/Box}
        * @private
        */
        this.box_ = new RenderBox(options.className || 'ol-dragbox');

        /**
        * @type {number}
        * @private
        */
        this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

        /**
         * Function to execute just before `onboxend` is fired
         * @type {function(this:module:ol/interaction/DragBox, module:ol/MapBrowserEvent)}
         * @private
         */
        this.onBoxEnd_ = options.onBoxEnd ? options.onBoxEnd : UNDEFINED;

        /**
        * @type {module:ol/pixel~Pixel}
        * @private
        */
        this.startPixel_ = null;

        /**
        * @private
        * @type {module:ol/events/condition~Condition}
        */
        this.condition_ = options.condition ? options.condition : always;

        /**
        * @private
        * @type {module:ol/interaction/DragBox~EndCondition}
        */
        this.boxEndCondition_ = options.boxEndCondition ?
          options.boxEndCondition : defaultBoxEndCondition;
      }

      if ( PointerInteraction$$1 ) DragBox.__proto__ = PointerInteraction$$1;
      DragBox.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      DragBox.prototype.constructor = DragBox;

      /**
      * Returns geometry of last drawn box.
      * @return {module:ol/geom/Polygon} Geometry.
      * @api
      */
      DragBox.prototype.getGeometry = function getGeometry () {
        return this.box_.getGeometry();
      };

      return DragBox;
    }(PointerInteraction));


    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {module:ol/pixel~Pixel} startPixel The starting pixel of the box.
     * @param {module:ol/pixel~Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     * @this {module:ol/interaction/DragBox}
     */
    function defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
      var width = endPixel[0] - startPixel[0];
      var height = endPixel[1] - startPixel[1];
      return width * width + height * height >= this.minArea_;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/DragBox}
     */
    function handleDragEvent$3(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return;
      }

      this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

      this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate, mapBrowserEvent));
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/DragBox}
     */
    function handleUpEvent$3(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return true;
      }

      this.box_.setMap(null);

      if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
        this.onBoxEnd_(mapBrowserEvent);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND,
          mapBrowserEvent.coordinate, mapBrowserEvent));
      }
      return false;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/DragBox}
     */
    function handleDownEvent$3(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return false;
      }

      if (mouseActionButton(mapBrowserEvent) &&
          this.condition_(mapBrowserEvent)) {
        this.startPixel_ = mapBrowserEvent.pixel;
        this.box_.setMap(mapBrowserEvent.map);
        this.box_.setPixels(this.startPixel_, this.startPixel_);
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate, mapBrowserEvent));
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/interaction/DragZoom
     */


    /**
     * @typedef {Object} Options
     * @property {string} [className='ol-dragzoom'] CSS class name for styling the
     * box.
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~shiftKeyOnly}.
     * @property {number} [duration=200] Animation duration in milliseconds.
     * @property {boolean} [out=false] Use interaction for zooming out.
     */


    /**
     * @classdesc
     * Allows the user to zoom the map by clicking and dragging on the map,
     * normally combined with an {@link module:ol/events/condition} that limits
     * it to when a key, shift by default, is held down.
     *
     * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
     * your custom one configured with `className`.
     * @api
     */
    var DragZoom = (function (DragBox$$1) {
      function DragZoom(opt_options) {
        var options = opt_options ? opt_options : {};

        var condition = options.condition ? options.condition : shiftKeyOnly;

        DragBox$$1.call(this, {
          condition: condition,
          className: options.className || 'ol-dragzoom',
          onBoxEnd: onBoxEnd
        });

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 200;

        /**
         * @private
         * @type {boolean}
         */
        this.out_ = options.out !== undefined ? options.out : false;
      }

      if ( DragBox$$1 ) DragZoom.__proto__ = DragBox$$1;
      DragZoom.prototype = Object.create( DragBox$$1 && DragBox$$1.prototype );
      DragZoom.prototype.constructor = DragZoom;

      return DragZoom;
    }(DragBox));


    /**
     * @this {module:ol/interaction/DragZoom}
     */
    function onBoxEnd() {
      var map = this.getMap();
      var view = /** @type {!module:ol/View} */ (map.getView());
      var size = /** @type {!module:ol/size~Size} */ (map.getSize());
      var extent = this.getGeometry().getExtent();

      if (this.out_) {
        var mapExtent = view.calculateExtent(size);
        var boxPixelExtent = createOrUpdateFromCoordinates([
          map.getPixelFromCoordinate(getBottomLeft(extent)),
          map.getPixelFromCoordinate(getTopRight(extent))]);
        var factor = view.getResolutionForExtent(boxPixelExtent, size);

        scaleFromCenter(mapExtent, 1 / factor);
        extent = mapExtent;
      }

      var resolution = view.constrainResolution(
        view.getResolutionForExtent(extent, size));

      var center = getCenter(extent);
      center = view.constrainCenter(center);

      view.animate({
        resolution: resolution,
        center: center,
        duration: this.duration_,
        easing: easeOut
      });
    }

    /**
     * @module ol/events/KeyCode
     */

    /**
     * @enum {number}
     * @const
     */
    var KeyCode = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40
    };

    /**
     * @module ol/interaction/KeyboardPan
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~noModifierKeys} and
     * {@link module:ol/events/condition~targetNotEditable}.
     * @property {number} [duration=100] Animation duration in milliseconds.
     * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
     * press.
     */


    /**
     * @classdesc
     * Allows the user to pan the map using keyboard arrows.
     * Note that, although this interaction is by default included in maps,
     * the keys can only be used when browser focus is on the element to which
     * the keyboard events are attached. By default, this is the map div,
     * though you can change this with the `keyboardEventTarget` in
     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
     * element, focus will have to be on, and returned to, this element if the keys
     * are to function.
     * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
     * @api
     */
    var KeyboardPan = (function (Interaction$$1) {
      function KeyboardPan(opt_options) {

        Interaction$$1.call(this, {
          handleEvent: handleEvent$2
        });

        var options = opt_options || {};

        /**
         * @private
         * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */
        this.defaultCondition_ = function(mapBrowserEvent) {
          return noModifierKeys(mapBrowserEvent) &&
            targetNotEditable(mapBrowserEvent);
        };

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition !== undefined ?
          options.condition : this.defaultCondition_;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 100;

        /**
         * @private
         * @type {number}
         */
        this.pixelDelta_ = options.pixelDelta !== undefined ?
          options.pixelDelta : 128;

      }

      if ( Interaction$$1 ) KeyboardPan.__proto__ = Interaction$$1;
      KeyboardPan.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      KeyboardPan.prototype.constructor = KeyboardPan;

      return KeyboardPan;
    }(Interaction));


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/KeyboardPan}
     */
    function handleEvent$2(mapBrowserEvent) {
      var stopEvent = false;
      if (mapBrowserEvent.type == EventType.KEYDOWN) {
        var keyEvent = mapBrowserEvent.originalEvent;
        var keyCode = keyEvent.keyCode;
        if (this.condition_(mapBrowserEvent) &&
            (keyCode == KeyCode.DOWN ||
            keyCode == KeyCode.LEFT ||
            keyCode == KeyCode.RIGHT ||
            keyCode == KeyCode.UP)) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
          var deltaX = 0, deltaY = 0;
          if (keyCode == KeyCode.DOWN) {
            deltaY = -mapUnitsDelta;
          } else if (keyCode == KeyCode.LEFT) {
            deltaX = -mapUnitsDelta;
          } else if (keyCode == KeyCode.RIGHT) {
            deltaX = mapUnitsDelta;
          } else {
            deltaY = mapUnitsDelta;
          }
          var delta = [deltaX, deltaY];
          rotate(delta, view.getRotation());
          pan(view, delta, this.duration_);
          mapBrowserEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }

    /**
     * @module ol/interaction/KeyboardZoom
     */


    /**
     * @typedef {Object} Options
     * @property {number} [duration=100] Animation duration in milliseconds.
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~targetNotEditable}.
     * @property {number} [delta=1] The zoom level delta on each key press.
     */


    /**
     * @classdesc
     * Allows the user to zoom the map using keyboard + and -.
     * Note that, although this interaction is by default included in maps,
     * the keys can only be used when browser focus is on the element to which
     * the keyboard events are attached. By default, this is the map div,
     * though you can change this with the `keyboardEventTarget` in
     * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
     * element, focus will have to be on, and returned to, this element if the keys
     * are to function.
     * See also {@link moudle:ol/interaction/KeyboardPan~KeyboardPan}.
     * @api
     */
    var KeyboardZoom = (function (Interaction$$1) {
      function KeyboardZoom(opt_options) {

        Interaction$$1.call(this, {
          handleEvent: handleEvent$3
        });

        var options = opt_options ? opt_options : {};

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : targetNotEditable;

        /**
         * @private
         * @type {number}
         */
        this.delta_ = options.delta ? options.delta : 1;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 100;

      }

      if ( Interaction$$1 ) KeyboardZoom.__proto__ = Interaction$$1;
      KeyboardZoom.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      KeyboardZoom.prototype.constructor = KeyboardZoom;

      return KeyboardZoom;
    }(Interaction));


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/KeyboardZoom}
     */
    function handleEvent$3(mapBrowserEvent) {
      var stopEvent = false;
      if (mapBrowserEvent.type == EventType.KEYDOWN ||
          mapBrowserEvent.type == EventType.KEYPRESS) {
        var keyEvent = mapBrowserEvent.originalEvent;
        var charCode = keyEvent.charCode;
        if (this.condition_(mapBrowserEvent) &&
            (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
          var map = mapBrowserEvent.map;
          var delta = (charCode == '+'.charCodeAt(0)) ? this.delta_ : -this.delta_;
          var view = map.getView();
          zoomByDelta(view, delta, undefined, this.duration_);
          mapBrowserEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }

    /**
     * @module ol/interaction/MouseWheelZoom
     */


    /**
     * Maximum mouse wheel delta.
     * @type {number}
     */
    var MAX_DELTA = 1;


    /**
     * @enum {string}
     */
    var Mode = {
      TRACKPAD: 'trackpad',
      WHEEL: 'wheel'
    };


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. Default is
     * {@link module:ol/events/condition~always}.
     * @property {number} [duration=250] Animation duration in milliseconds.
     * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
     * @property {boolean} [constrainResolution=false] When using a trackpad or
     * magic mouse, zoom to the closest integer zoom level after the scroll gesture
     * ends.
     * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
     * location as the anchor. When set to `false`, zooming in and out will zoom to
     * the center of the screen instead of zooming on the mouse's location.
     */


    /**
     * @classdesc
     * Allows the user to zoom the map by scrolling the mouse wheel.
     * @api
     */
    var MouseWheelZoom = (function (Interaction$$1) {
      function MouseWheelZoom(opt_options) {

        Interaction$$1.call(this, {
          handleEvent: handleEvent$4
        });

        var options = opt_options || {};

        /**
         * @private
         * @type {number}
         */
        this.delta_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

        /**
         * @private
         * @type {number}
         */
        this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

        /**
         * @private
         * @type {boolean}
         */
        this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

        /**
         * @private
         * @type {boolean}
         */
        this.constrainResolution_ = options.constrainResolution || false;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : always;

        /**
         * @private
         * @type {?module:ol/coordinate~Coordinate}
         */
        this.lastAnchor_ = null;

        /**
         * @private
         * @type {number|undefined}
         */
        this.startTime_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.timeoutId_ = undefined;

        /**
         * @private
         * @type {module:ol/interaction/MouseWheelZoom~Mode|undefined}
         */
        this.mode_ = undefined;

        /**
         * Trackpad events separated by this delay will be considered separate
         * interactions.
         * @type {number}
         */
        this.trackpadEventGap_ = 400;

        /**
         * @type {number|undefined}
         */
        this.trackpadTimeoutId_ = undefined;

        /**
         * The number of delta values per zoom level
         * @private
         * @type {number}
         */
        this.trackpadDeltaPerZoom_ = 300;

        /**
         * The zoom factor by which scroll zooming is allowed to exceed the limits.
         * @private
         * @type {number}
         */
        this.trackpadZoomBuffer_ = 1.5;

      }

      if ( Interaction$$1 ) MouseWheelZoom.__proto__ = Interaction$$1;
      MouseWheelZoom.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      MouseWheelZoom.prototype.constructor = MouseWheelZoom;

      /**
       * @private
       */
      MouseWheelZoom.prototype.decrementInteractingHint_ = function decrementInteractingHint_ () {
        this.trackpadTimeoutId_ = undefined;
        var view = this.getMap().getView();
        view.setHint(ViewHint.INTERACTING, -1);
      };

      /**
       * @private
       * @param {module:ol/PluggableMap} map Map.
       */
      MouseWheelZoom.prototype.handleWheelZoom_ = function handleWheelZoom_ (map) {
        var view = map.getView();
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        var maxDelta = MAX_DELTA;
        var delta = clamp(this.delta_, -maxDelta, maxDelta);
        zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);
        this.mode_ = undefined;
        this.delta_ = 0;
        this.lastAnchor_ = null;
        this.startTime_ = undefined;
        this.timeoutId_ = undefined;
      };

      /**
       * Enable or disable using the mouse's location as an anchor when zooming
       * @param {boolean} useAnchor true to zoom to the mouse's location, false
       * to zoom to the center of the map
       * @api
       */
      MouseWheelZoom.prototype.setMouseAnchor = function setMouseAnchor (useAnchor) {
        this.useAnchor_ = useAnchor;
        if (!useAnchor) {
          this.lastAnchor_ = null;
        }
      };

      return MouseWheelZoom;
    }(Interaction));


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
     * mousewheel-event) and eventually zooms the map.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} Allow event propagation.
     * @this {module:ol/interaction/MouseWheelZoom}
     */
    function handleEvent$4(mapBrowserEvent) {
      if (!this.condition_(mapBrowserEvent)) {
        return true;
      }
      var type = mapBrowserEvent.type;
      if (type !== EventType.WHEEL && type !== EventType.MOUSEWHEEL) {
        return true;
      }

      mapBrowserEvent.preventDefault();

      var map = mapBrowserEvent.map;
      var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);

      if (this.useAnchor_) {
        this.lastAnchor_ = mapBrowserEvent.coordinate;
      }

      // Delta normalisation inspired by
      // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
      var delta;
      if (mapBrowserEvent.type == EventType.WHEEL) {
        delta = wheelEvent.deltaY;
        if (FIREFOX &&
            wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          delta /= DEVICE_PIXEL_RATIO;
        }
        if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
          delta *= 40;
        }
      } else if (mapBrowserEvent.type == EventType.MOUSEWHEEL) {
        delta = -wheelEvent.wheelDeltaY;
        if (SAFARI) {
          delta /= 3;
        }
      }

      if (delta === 0) {
        return false;
      }

      var now = Date.now();

      if (this.startTime_ === undefined) {
        this.startTime_ = now;
      }

      if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
        this.mode_ = Math.abs(delta) < 4 ?
          Mode.TRACKPAD :
          Mode.WHEEL;
      }

      if (this.mode_ === Mode.TRACKPAD) {
        var view = map.getView();
        if (this.trackpadTimeoutId_) {
          clearTimeout(this.trackpadTimeoutId_);
        } else {
          view.setHint(ViewHint.INTERACTING, 1);
        }
        this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
        var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
        var minResolution = view.getMinResolution();
        var maxResolution = view.getMaxResolution();
        var rebound = 0;
        if (resolution < minResolution) {
          resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
          rebound = 1;
        } else if (resolution > maxResolution) {
          resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
          rebound = -1;
        }
        if (this.lastAnchor_) {
          var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
          view.setCenter(view.constrainCenter(center));
        }
        view.setResolution(resolution);

        if (rebound === 0 && this.constrainResolution_) {
          view.animate({
            resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
            easing: easeOut,
            anchor: this.lastAnchor_,
            duration: this.duration_
          });
        }

        if (rebound > 0) {
          view.animate({
            resolution: minResolution,
            easing: easeOut,
            anchor: this.lastAnchor_,
            duration: 500
          });
        } else if (rebound < 0) {
          view.animate({
            resolution: maxResolution,
            easing: easeOut,
            anchor: this.lastAnchor_,
            duration: 500
          });
        }
        this.startTime_ = now;
        return false;
      }

      this.delta_ += delta;

      var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

      clearTimeout(this.timeoutId_);
      this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

      return false;
    }

    /**
     * @module ol/interaction/PinchRotate
     */


    /**
     * @typedef {Object} Options
     * @property {number} [duration=250] The duration of the animation in
     * milliseconds.
     * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
     */


    /**
     * @classdesc
     * Allows the user to rotate the map by twisting with two fingers
     * on a touch screen.
     * @api
     */
    var PinchRotate = (function (PointerInteraction$$1) {
      function PinchRotate(opt_options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$4,
          handleDragEvent: handleDragEvent$4,
          handleUpEvent: handleUpEvent$4,
          stopDown: FALSE
        });

        var options = opt_options || {};

        /**
         * @private
         * @type {module:ol/coordinate~Coordinate}
         */
        this.anchor_ = null;

        /**
         * @private
         * @type {number|undefined}
         */
        this.lastAngle_ = undefined;

        /**
         * @private
         * @type {boolean}
         */
        this.rotating_ = false;

        /**
         * @private
         * @type {number}
         */
        this.rotationDelta_ = 0.0;

        /**
         * @private
         * @type {number}
         */
        this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 250;

      }

      if ( PointerInteraction$$1 ) PinchRotate.__proto__ = PointerInteraction$$1;
      PinchRotate.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      PinchRotate.prototype.constructor = PinchRotate;

      return PinchRotate;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/PinchRotate}
     */
    function handleDragEvent$4(mapBrowserEvent) {
      var rotationDelta = 0.0;

      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1];

      // angle between touches
      var angle = Math.atan2(
        touch1.clientY - touch0.clientY,
        touch1.clientX - touch0.clientX);

      if (this.lastAngle_ !== undefined) {
        var delta = angle - this.lastAngle_;
        this.rotationDelta_ += delta;
        if (!this.rotating_ &&
            Math.abs(this.rotationDelta_) > this.threshold_) {
          this.rotating_ = true;
        }
        rotationDelta = delta;
      }
      this.lastAngle_ = angle;

      var map = mapBrowserEvent.map;
      var view = map.getView();
      if (view.getConstraints().rotation === disable) {
        return;
      }

      // rotate anchor point.
      // FIXME: should be the intersection point between the lines:
      //     touch0,touch1 and previousTouch0,previousTouch1
      var viewportPosition = map.getViewport().getBoundingClientRect();
      var centroid$$1 = centroid(this.targetPointers);
      centroid$$1[0] -= viewportPosition.left;
      centroid$$1[1] -= viewportPosition.top;
      this.anchor_ = map.getCoordinateFromPixel(centroid$$1);

      // rotate
      if (this.rotating_) {
        var rotation = view.getRotation();
        map.render();
        rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
      }
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/PinchRotate}
     */
    function handleUpEvent$4(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.setHint(ViewHint.INTERACTING, -1);
        if (this.rotating_) {
          var rotation = view.getRotation();
          rotate$3(view, rotation, this.anchor_, this.duration_);
        }
        return false;
      } else {
        return true;
      }
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/PinchRotate}
     */
    function handleDownEvent$4(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastAngle_ = undefined;
        this.rotating_ = false;
        this.rotationDelta_ = 0.0;
        if (!this.handlingDownUpSequence) {
          map.getView().setHint(ViewHint.INTERACTING, 1);
        }
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/interaction/PinchZoom
     */


    /**
     * @typedef {Object} Options
     * @property {number} [duration=400] Animation duration in milliseconds.
     * @property {boolean} [constrainResolution=false] Zoom to the closest integer
     * zoom level after the pinch gesture ends.
     */


    /**
     * @classdesc
     * Allows the user to zoom the map by pinching with two fingers
     * on a touch screen.
     * @api
     */
    var PinchZoom = (function (PointerInteraction$$1) {
      function PinchZoom(opt_options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$5,
          handleDragEvent: handleDragEvent$5,
          handleUpEvent: handleUpEvent$5,
          stopDown: FALSE
        });

        var options = opt_options ? opt_options : {};

        /**
         * @private
         * @type {boolean}
         */
        this.constrainResolution_ = options.constrainResolution || false;

        /**
         * @private
         * @type {module:ol/coordinate~Coordinate}
         */
        this.anchor_ = null;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 400;

        /**
         * @private
         * @type {number|undefined}
         */
        this.lastDistance_ = undefined;

        /**
         * @private
         * @type {number}
         */
        this.lastScaleDelta_ = 1;

      }

      if ( PointerInteraction$$1 ) PinchZoom.__proto__ = PointerInteraction$$1;
      PinchZoom.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      PinchZoom.prototype.constructor = PinchZoom;

      return PinchZoom;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/PinchZoom}
     */
    function handleDragEvent$5(mapBrowserEvent) {
      var scaleDelta = 1.0;

      var touch0 = this.targetPointers[0];
      var touch1 = this.targetPointers[1];
      var dx = touch0.clientX - touch1.clientX;
      var dy = touch0.clientY - touch1.clientY;

      // distance between touches
      var distance = Math.sqrt(dx * dx + dy * dy);

      if (this.lastDistance_ !== undefined) {
        scaleDelta = this.lastDistance_ / distance;
      }
      this.lastDistance_ = distance;


      var map = mapBrowserEvent.map;
      var view = map.getView();
      var resolution = view.getResolution();
      var maxResolution = view.getMaxResolution();
      var minResolution = view.getMinResolution();
      var newResolution = resolution * scaleDelta;
      if (newResolution > maxResolution) {
        scaleDelta = maxResolution / resolution;
        newResolution = maxResolution;
      } else if (newResolution < minResolution) {
        scaleDelta = minResolution / resolution;
        newResolution = minResolution;
      }

      if (scaleDelta != 1.0) {
        this.lastScaleDelta_ = scaleDelta;
      }

      // scale anchor point.
      var viewportPosition = map.getViewport().getBoundingClientRect();
      var centroid$$1 = centroid(this.targetPointers);
      centroid$$1[0] -= viewportPosition.left;
      centroid$$1[1] -= viewportPosition.top;
      this.anchor_ = map.getCoordinateFromPixel(centroid$$1);

      // scale, bypass the resolution constraint
      map.render();
      zoomWithoutConstraints(view, newResolution, this.anchor_);
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/PinchZoom}
     */
    function handleUpEvent$5(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        var map = mapBrowserEvent.map;
        var view = map.getView();
        view.setHint(ViewHint.INTERACTING, -1);
        var resolution = view.getResolution();
        if (this.constrainResolution_ ||
            resolution < view.getMinResolution() ||
            resolution > view.getMaxResolution()) {
          // Zoom to final resolution, with an animation, and provide a
          // direction not to zoom out/in if user was pinching in/out.
          // Direction is > 0 if pinching out, and < 0 if pinching in.
          var direction = this.lastScaleDelta_ - 1;
          zoom(view, resolution, this.anchor_, this.duration_, direction);
        }
        return false;
      } else {
        return true;
      }
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/PinchZoom}
     */
    function handleDownEvent$5(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        var map = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastDistance_ = undefined;
        this.lastScaleDelta_ = 1;
        if (!this.handlingDownUpSequence) {
          map.getView().setHint(ViewHint.INTERACTING, 1);
        }
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/interaction/DragAndDrop
     */


    /**
     * @typedef {Object} Options
     * @property {Array.<function(new: module:ol/format/Feature)>} [formatConstructors] Format constructors.
     * @property {module:ol/source/Vector} [source] Optional vector source where features will be added.  If a source is provided
     * all existing features will be removed and new features will be added when
     * they are dropped on the target.  If you want to add features to a vector
     * source without removing the existing features (append only), instead of
     * providing the source option listen for the "addfeatures" event.
     * @property {module:ol/proj~ProjectionLike} [projection] Target projection. By default, the map's view's projection is used.
     * @property {Element} [target] The element that is used as the drop target, default is the viewport element.
     */


    /**
     * @enum {string}
     */
    var DragAndDropEventType = {
      /**
       * Triggered when features are added
       * @event module:ol/interaction/DragAndDrop~DragAndDropEvent#addfeatures
       * @api
       */
      ADD_FEATURES: 'addfeatures'
    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/DragAndDrop~DragAndDrop} instances are instances
     * of this type.
     */
    var DragAndDropEvent = (function (Event$$1) {
      function DragAndDropEvent(type, file, opt_features, opt_projection) {

        Event$$1.call(this, type);

        /**
         * The features parsed from dropped data.
         * @type {Array.<module:ol/Feature>|undefined}
         * @api
         */
        this.features = opt_features;

        /**
         * The dropped file.
         * @type {File}
         * @api
         */
        this.file = file;

        /**
         * The feature projection.
         * @type {module:ol/proj/Projection|undefined}
         * @api
         */
        this.projection = opt_projection;

      }

      if ( Event$$1 ) DragAndDropEvent.__proto__ = Event$$1;
      DragAndDropEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      DragAndDropEvent.prototype.constructor = DragAndDropEvent;

      return DragAndDropEvent;
    }(Event));


    /**
     * @classdesc
     * Handles input of vector data by drag and drop.
     * @api
     *
     * @fires module:ol/interaction/DragAndDrop~DragAndDropEvent
     */
    var DragAndDrop = (function (Interaction$$1) {
      function DragAndDrop(opt_options) {

        var options = opt_options ? opt_options : {};

        Interaction$$1.call(this, {
          handleEvent: TRUE
        });

        /**
         * @private
         * @type {Array.<function(new: module:ol/format/Feature)>}
         */
        this.formatConstructors_ = options.formatConstructors ?
          options.formatConstructors : [];

        /**
         * @private
         * @type {module:ol/proj/Projection}
         */
        this.projection_ = options.projection ?
          get$2(options.projection) : null;

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.dropListenKeys_ = null;

        /**
         * @private
         * @type {module:ol/source/Vector}
         */
        this.source_ = options.source || null;

        /**
         * @private
         * @type {Element}
         */
        this.target = options.target ? options.target : null;

      }

      if ( Interaction$$1 ) DragAndDrop.__proto__ = Interaction$$1;
      DragAndDrop.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      DragAndDrop.prototype.constructor = DragAndDrop;

      /**
       * @param {File} file File.
       * @param {Event} event Load event.
       * @private
       */
      DragAndDrop.prototype.handleResult_ = function handleResult_ (file, event) {
        var this$1 = this;

        var result = event.target.result;
        var map = this.getMap();
        var projection = this.projection_;
        if (!projection) {
          var view = map.getView();
          projection = view.getProjection();
        }

        var formatConstructors = this.formatConstructors_;
        var features = [];
        for (var i = 0, ii = formatConstructors.length; i < ii; ++i) {
          /**
           * Avoid "cannot instantiate abstract class" error.
           * @type {Function}
           */
          var formatConstructor = formatConstructors[i];
          /**
           * @type {module:ol/format/Feature}
           */
          var format = new formatConstructor();
          features = this$1.tryReadFeatures_(format, result, {
            featureProjection: projection
          });
          if (features && features.length > 0) {
            break;
          }
        }
        if (this.source_) {
          this.source_.clear();
          this.source_.addFeatures(features);
        }
        this.dispatchEvent(
          new DragAndDropEvent(
            DragAndDropEventType.ADD_FEATURES, file,
            features, projection));
      };

      /**
       * @private
       */
      DragAndDrop.prototype.registerListeners_ = function registerListeners_ () {
        var map = this.getMap();
        if (map) {
          var dropArea = this.target ? this.target : map.getViewport();
          this.dropListenKeys_ = [
            listen(dropArea, EventType.DROP, handleDrop, this),
            listen(dropArea, EventType.DRAGENTER, handleStop, this),
            listen(dropArea, EventType.DRAGOVER, handleStop, this),
            listen(dropArea, EventType.DROP, handleStop, this)
          ];
        }
      };

      /**
       * @inheritDoc
       */
      DragAndDrop.prototype.setActive = function setActive (active) {
        Interaction$$1.prototype.setActive.call(this, active);
        if (active) {
          this.registerListeners_();
        } else {
          this.unregisterListeners_();
        }
      };

      /**
       * @inheritDoc
       */
      DragAndDrop.prototype.setMap = function setMap (map) {
        this.unregisterListeners_();
        Interaction$$1.prototype.setMap.call(this, map);
        if (this.getActive()) {
          this.registerListeners_();
        }
      };

      /**
       * @param {module:ol/format/Feature} format Format.
       * @param {string} text Text.
       * @param {module:ol/format/Feature~ReadOptions} options Read options.
       * @private
       * @return {Array.<module:ol/Feature>} Features.
       */
      DragAndDrop.prototype.tryReadFeatures_ = function tryReadFeatures_ (format, text, options) {
        try {
          return format.readFeatures(text, options);
        } catch (e) {
          return null;
        }
      };

      /**
       * @private
       */
      DragAndDrop.prototype.unregisterListeners_ = function unregisterListeners_ () {
        if (this.dropListenKeys_) {
          this.dropListenKeys_.forEach(unlistenByKey);
          this.dropListenKeys_ = null;
        }
      };

      return DragAndDrop;
    }(Interaction));


    /**
     * @param {DragEvent} event Event.
     * @this {module:ol/interaction/DragAndDrop}
     */
    function handleDrop(event) {
      var this$1 = this;

      var files = event.dataTransfer.files;
      for (var i = 0, ii = files.length; i < ii; ++i) {
        var file = files.item(i);
        var reader = new FileReader();
        reader.addEventListener(EventType.LOAD, this$1.handleResult_.bind(this$1, file));
        reader.readAsText(file);
      }
    }


    /**
     * @param {DragEvent} event Event.
     */
    function handleStop(event) {
      event.stopPropagation();
      event.preventDefault();
      event.dataTransfer.dropEffect = 'copy';
    }

    /**
     * @module ol/interaction/DragRotateAndZoom
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * Default is {@link module:ol/events/condition~shiftKeyOnly}.
     * @property {number} [duration=400] Animation duration in milliseconds.
     */


    /**
     * @classdesc
     * Allows the user to zoom and rotate the map by clicking and dragging
     * on the map.  By default, this interaction is limited to when the shift
     * key is held down.
     *
     * This interaction is only supported for mouse devices.
     *
     * And this interaction is not included in the default interactions.
     * @api
     */
    var DragRotateAndZoom = (function (PointerInteraction$$1) {
      function DragRotateAndZoom(opt_options) {

        var options = opt_options ? opt_options : {};

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$6,
          handleDragEvent: handleDragEvent$6,
          handleUpEvent: handleUpEvent$6
        });

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : shiftKeyOnly;

        /**
         * @private
         * @type {number|undefined}
         */
        this.lastAngle_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.lastMagnitude_ = undefined;

        /**
         * @private
         * @type {number}
         */
        this.lastScaleDelta_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.duration_ = options.duration !== undefined ? options.duration : 400;

      }

      if ( PointerInteraction$$1 ) DragRotateAndZoom.__proto__ = PointerInteraction$$1;
      DragRotateAndZoom.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      DragRotateAndZoom.prototype.constructor = DragRotateAndZoom;

      return DragRotateAndZoom;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @this {module:ol/interaction/DragRotateAndZoom}
     */
    function handleDragEvent$6(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return;
      }

      var map = mapBrowserEvent.map;
      var size = map.getSize();
      var offset = mapBrowserEvent.pixel;
      var deltaX = offset[0] - size[0] / 2;
      var deltaY = size[1] / 2 - offset[1];
      var theta = Math.atan2(deltaY, deltaX);
      var magnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      var view = map.getView();
      if (view.getConstraints().rotation !== disable && this.lastAngle_ !== undefined) {
        var angleDelta = theta - this.lastAngle_;
        rotateWithoutConstraints(view, view.getRotation() - angleDelta);
      }
      this.lastAngle_ = theta;
      if (this.lastMagnitude_ !== undefined) {
        var resolution = this.lastMagnitude_ * (view.getResolution() / magnitude);
        zoomWithoutConstraints(view, resolution);
      }
      if (this.lastMagnitude_ !== undefined) {
        this.lastScaleDelta_ = this.lastMagnitude_ / magnitude;
      }
      this.lastMagnitude_ = magnitude;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/DragRotateAndZoom}
     */
    function handleUpEvent$6(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return true;
      }

      var map = mapBrowserEvent.map;
      var view = map.getView();
      view.setHint(ViewHint.INTERACTING, -1);
      var direction = this.lastScaleDelta_ - 1;
      rotate$3(view, view.getRotation());
      zoom(view, view.getResolution(), undefined, this.duration_, direction);
      this.lastScaleDelta_ = 0;
      return false;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/DragRotateAndZoom}
     */
    function handleDownEvent$6(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return false;
      }

      if (this.condition_(mapBrowserEvent)) {
        mapBrowserEvent.map.getView().setHint(ViewHint.INTERACTING, 1);
        this.lastAngle_ = undefined;
        this.lastMagnitude_ = undefined;
        return true;
      } else {
        return false;
      }
    }

    /**
     * @module ol/color
     */


    /**
     * Return the color as an rgba string.
     * @param {module:ol/color~Color|string} color Color.
     * @return {string} Rgba string.
     * @api
     */
    function asString(color) {
      if (typeof color === 'string') {
        return color;
      } else {
        return toString(color);
      }
    }


    /**
     * @param {module:ol/color~Color} color Color.
     * @return {string} String.
     */
    function toString(color) {
      var r = color[0];
      if (r != (r | 0)) {
        r = (r + 0.5) | 0;
      }
      var g = color[1];
      if (g != (g | 0)) {
        g = (g + 0.5) | 0;
      }
      var b = color[2];
      if (b != (b | 0)) {
        b = (b + 0.5) | 0;
      }
      var a = color[3] === undefined ? 1 : color[3];
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    }

    /**
     * @module ol/colorlike
     */


    /**
     * A type accepted by CanvasRenderingContext2D.fillStyle
     * or CanvasRenderingContext2D.strokeStyle.
     * Represents a color, pattern, or gradient. The origin for patterns and
     * gradients as fill style is an increment of 512 css pixels from map coordinate
     * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
     * must be a factor of two (2, 4, 8, ..., 512).
     *
     * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
     * @api
     */


    /**
     * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
     * @return {module:ol/colorlike~ColorLike} The color as an {@link ol/colorlike~ColorLike}.
     * @api
     */
    function asColorLike(color) {
      if (isColorLike(color)) {
        return /** @type {string|CanvasPattern|CanvasGradient} */ (color);
      } else {
        return toString(/** @type {module:ol/color~Color} */ (color));
      }
    }


    /**
     * @param {?} color The value that is potentially an {@link ol/colorlike~ColorLike}.
     * @return {boolean} The color is an {@link ol/colorlike~ColorLike}.
     */
    function isColorLike(color) {
      return (
        typeof color === 'string' ||
        color instanceof CanvasPattern ||
        color instanceof CanvasGradient
      );
    }

    /**
     * @module ol/ImageState
     */

    /**
     * @enum {number}
     */
    var ImageState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3
    };

    /**
     * @module ol/structs/LRUCache
     */


    /**
     * @typedef {Object} Entry
     * @property {string} key_
     * @property {Object} newer
     * @property {Object} older
     * @property {*} value_
     */


    /**
     * @classdesc
     * Implements a Least-Recently-Used cache where the keys do not conflict with
     * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
     * items from the cache is the responsibility of the user.
     *
     * @fires module:ol/events/Event~Event
     * @template T
     */
    var LRUCache = (function (EventTarget$$1) {
      function LRUCache(opt_highWaterMark) {

        EventTarget$$1.call(this);

        /**
         * @type {number}
         */
        this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

        /**
         * @private
         * @type {number}
         */
        this.count_ = 0;

        /**
         * @private
         * @type {!Object.<string, module:ol/structs/LRUCache~Entry>}
         */
        this.entries_ = {};

        /**
         * @private
         * @type {?module:ol/structs/LRUCache~Entry}
         */
        this.oldest_ = null;

        /**
         * @private
         * @type {?module:ol/structs/LRUCache~Entry}
         */
        this.newest_ = null;

      }

      if ( EventTarget$$1 ) LRUCache.__proto__ = EventTarget$$1;
      LRUCache.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      LRUCache.prototype.constructor = LRUCache;


      /**
       * @return {boolean} Can expire cache.
       */
      LRUCache.prototype.canExpireCache = function canExpireCache () {
        return this.getCount() > this.highWaterMark;
      };


      /**
       * FIXME empty description for jsdoc
       */
      LRUCache.prototype.clear = function clear () {
        this.count_ = 0;
        this.entries_ = {};
        this.oldest_ = null;
        this.newest_ = null;
        this.dispatchEvent(EventType.CLEAR);
      };


      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */
      LRUCache.prototype.containsKey = function containsKey (key) {
        return this.entries_.hasOwnProperty(key);
      };


      /**
       * @param {function(this: S, T, string, module:ol/structs/LRUCache): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       * @param {S=} opt_this The object to use as `this` in `f`.
       * @template S
       */
      LRUCache.prototype.forEach = function forEach (f, opt_this) {
        var this$1 = this;

        var entry = this.oldest_;
        while (entry) {
          f.call(opt_this, entry.value_, entry.key_, this$1);
          entry = entry.newer;
        }
      };


      /**
       * @param {string} key Key.
       * @return {T} Value.
       */
      LRUCache.prototype.get = function get (key) {
        var entry = this.entries_[key];
        assert(entry !== undefined,
          15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
          return entry.value_;
        } else if (entry === this.oldest_) {
          this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (this.oldest_.newer);
          this.oldest_.older = null;
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        entry.newer = null;
        entry.older = this.newest_;
        this.newest_.newer = entry;
        this.newest_ = entry;
        return entry.value_;
      };


      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */
      LRUCache.prototype.remove = function remove (key) {
        var entry = this.entries_[key];
        assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
        if (entry === this.newest_) {
          this.newest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.older);
          if (this.newest_) {
            this.newest_.newer = null;
          }
        } else if (entry === this.oldest_) {
          this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);
          if (this.oldest_) {
            this.oldest_.older = null;
          }
        } else {
          entry.newer.older = entry.older;
          entry.older.newer = entry.newer;
        }
        delete this.entries_[key];
        --this.count_;
        return entry.value_;
      };


      /**
       * @return {number} Count.
       */
      LRUCache.prototype.getCount = function getCount () {
        return this.count_;
      };


      /**
       * @return {Array.<string>} Keys.
       */
      LRUCache.prototype.getKeys = function getKeys () {
        var keys = new Array(this.count_);
        var i = 0;
        var entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          keys[i++] = entry.key_;
        }
        return keys;
      };


      /**
       * @return {Array.<T>} Values.
       */
      LRUCache.prototype.getValues = function getValues () {
        var values = new Array(this.count_);
        var i = 0;
        var entry;
        for (entry = this.newest_; entry; entry = entry.older) {
          values[i++] = entry.value_;
        }
        return values;
      };


      /**
       * @return {T} Last value.
       */
      LRUCache.prototype.peekLast = function peekLast () {
        return this.oldest_.value_;
      };


      /**
       * @return {string} Last key.
       */
      LRUCache.prototype.peekLastKey = function peekLastKey () {
        return this.oldest_.key_;
      };


      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */
      LRUCache.prototype.peekFirstKey = function peekFirstKey () {
        return this.newest_.key_;
      };


      /**
       * @return {T} value Value.
       */
      LRUCache.prototype.pop = function pop () {
        var entry = this.oldest_;
        delete this.entries_[entry.key_];
        if (entry.newer) {
          entry.newer.older = null;
        }
        this.oldest_ = /** @type {module:ol/structs/LRUCache~Entry} */ (entry.newer);
        if (!this.oldest_) {
          this.newest_ = null;
        }
        --this.count_;
        return entry.value_;
      };


      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.replace = function replace (key, value) {
        this.get(key); // update `newest_`
        this.entries_[key].value_ = value;
      };


      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.set = function set (key, value) {
        assert(!(key in this.entries_),
          16); // Tried to set a value for a key that is used already
        var entry = /** @type {module:ol/structs/LRUCache~Entry} */ ({
          key_: key,
          newer: null,
          older: this.newest_,
          value_: value
        });
        if (!this.newest_) {
          this.oldest_ = entry;
        } else {
          this.newest_.newer = entry;
        }
        this.newest_ = entry;
        this.entries_[key] = entry;
        ++this.count_;
      };


      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */
      LRUCache.prototype.setSize = function setSize (size) {
        this.highWaterMark = size;
      };


      /**
       * Prune the cache.
       */
      LRUCache.prototype.prune = function prune () {
        var this$1 = this;

        while (this.canExpireCache()) {
          this$1.pop();
        }
      };

      return LRUCache;
    }(EventTarget));

    /**
     * @module ol/render/canvas
     */


    /**
     * @typedef {Object} FillState
     * @property {module:ol/colorlike~ColorLike} fillStyle
     */


    /**
     * @typedef {Object} FillStrokeState
     * @property {module:ol/colorlike~ColorLike} [currentFillStyle]
     * @property {module:ol/colorlike~ColorLike} [currentStrokeStyle]
     * @property {string} [currentLineCap]
     * @property {Array.<number>} currentLineDash
     * @property {number} [currentLineDashOffset]
     * @property {string} [currentLineJoin]
     * @property {number} [currentLineWidth]
     * @property {number} [currentMiterLimit]
     * @property {number} [lastStroke]
     * @property {module:ol/colorlike~ColorLike} [fillStyle]
     * @property {module:ol/colorlike~ColorLike} [strokeStyle]
     * @property {string} [lineCap]
     * @property {Array.<number>} lineDash
     * @property {number} [lineDashOffset]
     * @property {string} [lineJoin]
     * @property {number} [lineWidth]
     * @property {number} [miterLimit]
     */


    /**
     * @typedef {Object} StrokeState
     * @property {string} lineCap
     * @property {Array.<number>} lineDash
     * @property {number} lineDashOffset
     * @property {string} lineJoin
     * @property {number} lineWidth
     * @property {number} miterLimit
     * @property {module:ol/colorlike~ColorLike} strokeStyle
     */


    /**
     * @typedef {Object} TextState
     * @property {string} font
     * @property {string} [textAlign]
     * @property {string} textBaseline
     */


    /**
     * Container for decluttered replay instructions that need to be rendered or
     * omitted together, i.e. when styles render both an image and text, or for the
     * characters that form text along lines. The basic elements of this array are
     * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
     * rendered extent of the group in pixel space. `count` is the number of styles
     * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
     * In addition to these four elements, declutter instruction arrays (i.e. the
     * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
     * @typedef {Array.<*>} DeclutterGroup
     */


    /**
     * @const
     * @type {string}
     */
    var defaultFont = '10px sans-serif';


    /**
     * @const
     * @type {module:ol/color~Color}
     */
    var defaultFillStyle = [0, 0, 0, 1];


    /**
     * @const
     * @type {string}
     */
    var defaultLineCap = 'round';


    /**
     * @const
     * @type {Array.<number>}
     */
    var defaultLineDash = [];


    /**
     * @const
     * @type {number}
     */
    var defaultLineDashOffset = 0;


    /**
     * @const
     * @type {string}
     */
    var defaultLineJoin = 'round';


    /**
     * @const
     * @type {number}
     */
    var defaultMiterLimit = 10;


    /**
     * @const
     * @type {module:ol/color~Color}
     */
    var defaultStrokeStyle = [0, 0, 0, 1];


    /**
     * @const
     * @type {string}
     */
    var defaultTextAlign = 'center';


    /**
     * @const
     * @type {string}
     */
    var defaultTextBaseline = 'middle';


    /**
     * @const
     * @type {Array.<number>}
     */
    var defaultPadding = [0, 0, 0, 0];


    /**
     * @const
     * @type {number}
     */
    var defaultLineWidth = 1;


    /**
     * The label cache for text rendering. To change the default cache size of 2048
     * entries, use {@link module:ol/structs/LRUCache#setSize}.
     * @type {module:ol/structs/LRUCache.<HTMLCanvasElement>}
     * @api
     */
    var labelCache = new LRUCache();


    /**
     * @type {!Object.<string, number>}
     */
    var checkedFonts = {};


    /**
     * @type {CanvasRenderingContext2D}
     */
    var measureContext = null;


    /**
     * @type {!Object.<string, number>}
     */
    var textHeights = {};


    /**
     * Clears the label cache when a font becomes available.
     * @param {string} fontSpec CSS font spec.
     */
    var checkFont = (function() {
      var retries = 60;
      var checked = checkedFonts;
      var size = '32px ';
      var referenceFonts = ['monospace', 'serif'];
      var len = referenceFonts.length;
      var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
      var interval, referenceWidth;

      function isAvailable(font) {
        var context = getMeasureContext();
        var available = true;
        for (var i = 0; i < len; ++i) {
          var referenceFont = referenceFonts[i];
          context.font = size + referenceFont;
          referenceWidth = context.measureText(text).width;
          if (font != referenceFont) {
            context.font = size + font + ',' + referenceFont;
            var width = context.measureText(text).width;
            // If width and referenceWidth are the same, then the fallback was used
            // instead of the font we wanted, so the font is not available.
            available = available && width != referenceWidth;
          }
        }
        return available;
      }

      function check() {
        var done = true;
        for (var font in checked) {
          if (checked[font] < retries) {
            if (isAvailable(font)) {
              checked[font] = retries;
              clear(textHeights);
              // Make sure that loaded fonts are picked up by Safari
              measureContext = null;
              labelCache.clear();
            } else {
              ++checked[font];
              done = false;
            }
          }
        }
        if (done) {
          clearInterval(interval);
          interval = undefined;
        }
      }

      return function(fontSpec) {
        var fontFamilies = getFontFamilies(fontSpec);
        if (!fontFamilies) {
          return;
        }
        for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
          var fontFamily = fontFamilies[i];
          if (!(fontFamily in checked)) {
            checked[fontFamily] = retries;
            if (!isAvailable(fontFamily)) {
              checked[fontFamily] = 0;
              if (interval === undefined) {
                interval = setInterval(check, 32);
              }
            }
          }
        }
      };
    })();


    /**
     * @return {CanvasRenderingContext2D} Measure context.
     */
    function getMeasureContext() {
      if (!measureContext) {
        measureContext = createCanvasContext2D(1, 1);
      }
      return measureContext;
    }


    /**
     * @param {string} font Font to use for measuring.
     * @return {module:ol/size~Size} Measurement.
     */
    var measureTextHeight = (function() {
      var span;
      var heights = textHeights;
      return function(font) {
        var height = heights[font];
        if (height == undefined) {
          if (!span) {
            span = document.createElement('span');
            span.textContent = 'M';
            span.style.margin = span.style.padding = '0 !important';
            span.style.position = 'absolute !important';
            span.style.left = '-99999px !important';
          }
          span.style.font = font;
          document.body.appendChild(span);
          height = heights[font] = span.offsetHeight;
          document.body.removeChild(span);
        }
        return height;
      };
    })();


    /**
     * @param {string} font Font.
     * @param {string} text Text.
     * @return {number} Width.
     */
    function measureTextWidth(font, text) {
      var measureContext = getMeasureContext();
      if (font != measureContext.font) {
        measureContext.font = font;
      }
      return measureContext.measureText(text).width;
    }


    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} rotation Rotation.
     * @param {number} offsetX X offset.
     * @param {number} offsetY Y offset.
     */
    function rotateAtOffset(context, rotation, offsetX, offsetY) {
      if (rotation !== 0) {
        context.translate(offsetX, offsetY);
        context.rotate(rotation);
        context.translate(-offsetX, -offsetY);
      }
    }


    var resetTransform = create();


    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {module:ol/transform~Transform|null} transform Transform.
     * @param {number} opacity Opacity.
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} w Width.
     * @param {number} h Height.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} scale Scale.
     */
    function drawImage(context,
      transform, opacity, image, originX, originY, w, h, x, y, scale) {
      var alpha;
      if (opacity != 1) {
        alpha = context.globalAlpha;
        context.globalAlpha = alpha * opacity;
      }
      if (transform) {
        context.setTransform.apply(context, transform);
      }

      context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

      if (alpha) {
        context.globalAlpha = alpha;
      }
      if (transform) {
        context.setTransform.apply(context, resetTransform);
      }
    }

    /**
     * @module ol/style/Image
     */


    /**
     * @typedef {Object} Options
     * @property {number} opacity
     * @property {boolean} rotateWithView
     * @property {number} rotation
     * @property {number} scale
     * @property {boolean} snapToPixel
     */


    /**
     * @classdesc
     * A base class used for creating subclasses and not instantiated in
     * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
     * {@link module:ol/style/RegularShape~RegularShape}.
     * @api
     */
    var ImageStyle = function ImageStyle(options) {

      /**
      * @private
      * @type {number}
      */
      this.opacity_ = options.opacity;

      /**
      * @private
      * @type {boolean}
      */
      this.rotateWithView_ = options.rotateWithView;

      /**
      * @private
      * @type {number}
      */
      this.rotation_ = options.rotation;

      /**
      * @private
      * @type {number}
      */
      this.scale_ = options.scale;

      /**
      * @private
      * @type {boolean}
      */
      this.snapToPixel_ = options.snapToPixel;

    };

    /**
    * Get the symbolizer opacity.
    * @return {number} Opacity.
    * @api
    */
    ImageStyle.prototype.getOpacity = function getOpacity () {
      return this.opacity_;
    };

    /**
    * Determine whether the symbolizer rotates with the map.
    * @return {boolean} Rotate with map.
    * @api
    */
    ImageStyle.prototype.getRotateWithView = function getRotateWithView () {
      return this.rotateWithView_;
    };

    /**
    * Get the symoblizer rotation.
    * @return {number} Rotation.
    * @api
    */
    ImageStyle.prototype.getRotation = function getRotation () {
      return this.rotation_;
    };

    /**
    * Get the symbolizer scale.
    * @return {number} Scale.
    * @api
    */
    ImageStyle.prototype.getScale = function getScale () {
      return this.scale_;
    };

    /**
    * Determine whether the symbolizer should be snapped to a pixel.
    * @return {boolean} The symbolizer should snap to a pixel.
    * @api
    */
    ImageStyle.prototype.getSnapToPixel = function getSnapToPixel () {
      return this.snapToPixel_;
    };

    /**
    * Get the anchor point in pixels. The anchor determines the center point for the
    * symbolizer.
    * @abstract
    * @return {Array.<number>} Anchor.
    */
    ImageStyle.prototype.getAnchor = function getAnchor () {};

    /**
    * Get the image element for the symbolizer.
    * @abstract
    * @param {number} pixelRatio Pixel ratio.
    * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
    */
    ImageStyle.prototype.getImage = function getImage (pixelRatio) {};

    /**
    * @abstract
    * @param {number} pixelRatio Pixel ratio.
    * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
    */
    ImageStyle.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {};

    /**
    * @abstract
    * @return {module:ol/ImageState} Image state.
    */
    ImageStyle.prototype.getImageState = function getImageState () {};

    /**
    * @abstract
    * @return {module:ol/size~Size} Image size.
    */
    ImageStyle.prototype.getImageSize = function getImageSize () {};

    /**
    * @abstract
    * @return {module:ol/size~Size} Size of the hit-detection image.
    */
    ImageStyle.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {};

    /**
    * Get the origin of the symbolizer.
    * @abstract
    * @return {Array.<number>} Origin.
    */
    ImageStyle.prototype.getOrigin = function getOrigin () {};

    /**
    * Get the size of the symbolizer (in pixels).
    * @abstract
    * @return {module:ol/size~Size} Size.
    */
    ImageStyle.prototype.getSize = function getSize () {};

    /**
    * Set the opacity.
    *
    * @param {number} opacity Opacity.
    * @api
    */
    ImageStyle.prototype.setOpacity = function setOpacity (opacity) {
      this.opacity_ = opacity;
    };

    /**
    * Set whether to rotate the style with the view.
    *
    * @param {boolean} rotateWithView Rotate with map.
    * @api
    */
    ImageStyle.prototype.setRotateWithView = function setRotateWithView (rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    };

    /**
    * Set the rotation.
    *
    * @param {number} rotation Rotation.
    * @api
    */
    ImageStyle.prototype.setRotation = function setRotation (rotation) {
      this.rotation_ = rotation;
    };

    /**
    * Set the scale.
    *
    * @param {number} scale Scale.
    * @api
    */
    ImageStyle.prototype.setScale = function setScale (scale) {
      this.scale_ = scale;
    };

    /**
    * Set whether to snap the image to the closest pixel.
    *
    * @param {boolean} snapToPixel Snap to pixel?
    * @api
    */
    ImageStyle.prototype.setSnapToPixel = function setSnapToPixel (snapToPixel) {
      this.snapToPixel_ = snapToPixel;
    };

    /**
    * @abstract
    * @param {function(this: T, module:ol/events/Event)} listener Listener function.
    * @param {T} thisArg Value to use as `this` when executing `listener`.
    * @return {module:ol/events~EventsKey|undefined} Listener key.
    * @template T
    */
    ImageStyle.prototype.listenImageChange = function listenImageChange (listener, thisArg) {};

    /**
    * Load not yet loaded URI.
    * @abstract
    */
    ImageStyle.prototype.load = function load () {};

    /**
    * @abstract
    * @param {function(this: T, module:ol/events/Event)} listener Listener function.
    * @param {T} thisArg Value to use as `this` when executing `listener`.
    * @template T
    */
    ImageStyle.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

    /**
     * @module ol/style/RegularShape
     */


    /**
     * Specify radius for regular polygons, or radius1 and radius2 for stars.
     * @typedef {Object} Options
     * @property {module:ol/style/Fill} [fill] Fill style.
     * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
     * is the number of sides.
     * @property {number} [radius] Radius of a regular polygon.
     * @property {number} [radius1] Outer radius of a star.
     * @property {number} [radius2] Inner radius of a star.
     * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
     * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate
     * when drawing the shape in the output canvas. If `false` fractional numbers may be used. Using `true` allows for
     * "sharp" rendering (no blur), while using `false` allows for "accurate" rendering. Note that accuracy is important if
     * the shape's position is animated. Without it, the shape may jitter noticeably.
     * @property {module:ol/style/Stroke} [stroke] Stroke style.
     * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
     * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
     * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this symbol. When
     * using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given, the
     * symbol is added to an atlas. By default no atlas manager is used.
     */


    /**
     * @typedef {Object} RenderOptions
     * @property {module:ol/colorlike~ColorLike} [strokeStyle]
     * @property {number} strokeWidth
     * @property {number} size
     * @property {string} lineCap
     * @property {Array.<number>} lineDash
     * @property {number} lineDashOffset
     * @property {string} lineJoin
     * @property {number} miterLimit
     */


    /**
     * @classdesc
     * Set regular shape style for vector features. The resulting shape will be
     * a regular polygon when `radius` is provided, or a star when `radius1` and
     * `radius2` are provided.
     * @api
     */
    var RegularShape = (function (ImageStyle$$1) {
      function RegularShape(options) {
        /**
         * @type {boolean}
         */
        var snapToPixel = options.snapToPixel !== undefined ?
          options.snapToPixel : true;

        /**
         * @type {boolean}
         */
        var rotateWithView = options.rotateWithView !== undefined ?
          options.rotateWithView : false;

        ImageStyle$$1.call(this, {
          opacity: 1,
          rotateWithView: rotateWithView,
          rotation: options.rotation !== undefined ? options.rotation : 0,
          scale: 1,
          snapToPixel: snapToPixel
        });

        /**
         * @private
         * @type {Array.<string>}
         */
        this.checksums_ = null;

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.canvas_ = null;

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.hitDetectionCanvas_ = null;

        /**
         * @private
         * @type {module:ol/style/Fill}
         */
        this.fill_ = options.fill !== undefined ? options.fill : null;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.origin_ = [0, 0];

        /**
         * @private
         * @type {number}
         */
        this.points_ = options.points;

        /**
         * @protected
         * @type {number}
         */
        this.radius_ = /** @type {number} */ (options.radius !== undefined ?
          options.radius : options.radius1);

        /**
         * @private
         * @type {number|undefined}
         */
        this.radius2_ = options.radius2;

        /**
         * @private
         * @type {number}
         */
        this.angle_ = options.angle !== undefined ? options.angle : 0;

        /**
         * @private
         * @type {module:ol/style/Stroke}
         */
        this.stroke_ = options.stroke !== undefined ? options.stroke : null;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.anchor_ = null;

        /**
         * @private
         * @type {module:ol/size~Size}
         */
        this.size_ = null;

        /**
         * @private
         * @type {module:ol/size~Size}
         */
        this.imageSize_ = null;

        /**
         * @private
         * @type {module:ol/size~Size}
         */
        this.hitDetectionImageSize_ = null;

        /**
         * @protected
         * @type {module:ol/style/AtlasManager|undefined}
         */
        this.atlasManager_ = options.atlasManager;

        this.render_(this.atlasManager_);

      }

      if ( ImageStyle$$1 ) RegularShape.__proto__ = ImageStyle$$1;
      RegularShape.prototype = Object.create( ImageStyle$$1 && ImageStyle$$1.prototype );
      RegularShape.prototype.constructor = RegularShape;

      /**
       * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
       * @return {module:ol/style/RegularShape} The cloned style.
       * @api
       */
      RegularShape.prototype.clone = function clone () {
        var style = new RegularShape({
          fill: this.getFill() ? this.getFill().clone() : undefined,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          snapToPixel: this.getSnapToPixel(),
          stroke: this.getStroke() ? this.getStroke().clone() : undefined,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          atlasManager: this.atlasManager_
        });
        style.setOpacity(this.getOpacity());
        style.setScale(this.getScale());
        return style;
      };

      /**
       * @inheritDoc
       * @api
       */
      RegularShape.prototype.getAnchor = function getAnchor () {
        return this.anchor_;
      };

      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      RegularShape.prototype.getAngle = function getAngle () {
        return this.angle_;
      };

      /**
       * Get the fill style for the shape.
       * @return {module:ol/style/Fill} Fill style.
       * @api
       */
      RegularShape.prototype.getFill = function getFill () {
        return this.fill_;
      };

      /**
       * @inheritDoc
       */
      RegularShape.prototype.getHitDetectionImage = function getHitDetectionImage (pixelRatio) {
        return this.hitDetectionCanvas_;
      };

      /**
       * @inheritDoc
       * @api
       */
      RegularShape.prototype.getImage = function getImage (pixelRatio) {
        return this.canvas_;
      };

      /**
       * @inheritDoc
       */
      RegularShape.prototype.getImageSize = function getImageSize () {
        return this.imageSize_;
      };

      /**
       * @inheritDoc
       */
      RegularShape.prototype.getHitDetectionImageSize = function getHitDetectionImageSize () {
        return this.hitDetectionImageSize_;
      };

      /**
       * @inheritDoc
       */
      RegularShape.prototype.getImageState = function getImageState () {
        return ImageState.LOADED;
      };

      /**
       * @inheritDoc
       * @api
       */
      RegularShape.prototype.getOrigin = function getOrigin () {
        return this.origin_;
      };

      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      RegularShape.prototype.getPoints = function getPoints () {
        return this.points_;
      };

      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      RegularShape.prototype.getRadius = function getRadius () {
        return this.radius_;
      };

      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      RegularShape.prototype.getRadius2 = function getRadius2 () {
        return this.radius2_;
      };

      /**
       * @inheritDoc
       * @api
       */
      RegularShape.prototype.getSize = function getSize () {
        return this.size_;
      };

      /**
       * Get the stroke style for the shape.
       * @return {module:ol/style/Stroke} Stroke style.
       * @api
       */
      RegularShape.prototype.getStroke = function getStroke () {
        return this.stroke_;
      };

      /**
       * @inheritDoc
       */
      RegularShape.prototype.listenImageChange = function listenImageChange (listener, thisArg) {};

      /**
       * @inheritDoc
       */
      RegularShape.prototype.load = function load () {};

      /**
       * @inheritDoc
       */
      RegularShape.prototype.unlistenImageChange = function unlistenImageChange (listener, thisArg) {};

      /**
       * @protected
       * @param {module:ol/style/AtlasManager|undefined} atlasManager An atlas manager.
       */
      RegularShape.prototype.render_ = function render_ (atlasManager) {
        var imageSize;
        var lineCap = '';
        var lineJoin = '';
        var miterLimit = 0;
        var lineDash = null;
        var lineDashOffset = 0;
        var strokeStyle;
        var strokeWidth = 0;

        if (this.stroke_) {
          strokeStyle = this.stroke_.getColor();
          if (strokeStyle === null) {
            strokeStyle = defaultStrokeStyle;
          }
          strokeStyle = asColorLike(strokeStyle);
          strokeWidth = this.stroke_.getWidth();
          if (strokeWidth === undefined) {
            strokeWidth = defaultLineWidth;
          }
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset();
          if (!CANVAS_LINE_DASH) {
            lineDash = null;
            lineDashOffset = 0;
          }
          lineJoin = this.stroke_.getLineJoin();
          if (lineJoin === undefined) {
            lineJoin = defaultLineJoin;
          }
          lineCap = this.stroke_.getLineCap();
          if (lineCap === undefined) {
            lineCap = defaultLineCap;
          }
          miterLimit = this.stroke_.getMiterLimit();
          if (miterLimit === undefined) {
            miterLimit = defaultMiterLimit;
          }
        }

        var size = 2 * (this.radius_ + strokeWidth) + 1;

        /** @type {module:ol/style/RegularShape~RenderOptions} */
        var renderOptions = {
          strokeStyle: strokeStyle,
          strokeWidth: strokeWidth,
          size: size,
          lineCap: lineCap,
          lineDash: lineDash,
          lineDashOffset: lineDashOffset,
          lineJoin: lineJoin,
          miterLimit: miterLimit
        };

        if (atlasManager === undefined) {
          // no atlas manager is used, create a new canvas
          var context = createCanvasContext2D(size, size);
          this.canvas_ = context.canvas;

          // canvas.width and height are rounded to the closest integer
          size = this.canvas_.width;
          imageSize = size;

          this.draw_(renderOptions, context, 0, 0);

          this.createHitDetectionCanvas_(renderOptions);
        } else {
          // an atlas manager is used, add the symbol to an atlas
          size = Math.round(size);

          var hasCustomHitDetectionImage = !this.fill_;
          var renderHitDetectionCallback;
          if (hasCustomHitDetectionImage) {
            // render the hit-detection image into a separate atlas image
            renderHitDetectionCallback =
                this.drawHitDetectionCanvas_.bind(this, renderOptions);
          }

          var id = this.getChecksum();
          var info = atlasManager.add(
            id, size, size, this.draw_.bind(this, renderOptions),
            renderHitDetectionCallback);

          this.canvas_ = info.image;
          this.origin_ = [info.offsetX, info.offsetY];
          imageSize = info.image.width;

          if (hasCustomHitDetectionImage) {
            this.hitDetectionCanvas_ = info.hitImage;
            this.hitDetectionImageSize_ =
                [info.hitImage.width, info.hitImage.height];
          } else {
            this.hitDetectionCanvas_ = this.canvas_;
            this.hitDetectionImageSize_ = [imageSize, imageSize];
          }
        }

        this.anchor_ = [size / 2, size / 2];
        this.size_ = [size, size];
        this.imageSize_ = [imageSize, imageSize];
      };

      /**
       * @private
       * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       */
      RegularShape.prototype.draw_ = function draw_ (renderOptions, context, x, y) {
        var this$1 = this;

        var i, angle0, radiusC;
        // reset transform
        context.setTransform(1, 0, 0, 1, 0, 0);

        // then move to (x, y)
        context.translate(x, y);

        context.beginPath();

        var points = this.points_;
        if (points === Infinity) {
          context.arc(
            renderOptions.size / 2, renderOptions.size / 2,
            this.radius_, 0, 2 * Math.PI, true);
        } else {
          var radius2 = (this.radius2_ !== undefined) ? this.radius2_
            : this.radius_;
          if (radius2 !== this.radius_) {
            points = 2 * points;
          }
          for (i = 0; i <= points; i++) {
            angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this$1.angle_;
            radiusC = i % 2 === 0 ? this$1.radius_ : radius2;
            context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
              renderOptions.size / 2 + radiusC * Math.sin(angle0));
          }
        }


        if (this.fill_) {
          var color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (this.stroke_) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
        context.closePath();
      };

      /**
       * @private
       * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
       */
      RegularShape.prototype.createHitDetectionCanvas_ = function createHitDetectionCanvas_ (renderOptions) {
        this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
        if (this.fill_) {
          this.hitDetectionCanvas_ = this.canvas_;
          return;
        }

        // if no fill style is set, create an extra hit-detection image with a
        // default fill style
        var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.hitDetectionCanvas_ = context.canvas;

        this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
      };

      /**
       * @private
       * @param {module:ol/style/RegularShape~RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       */
      RegularShape.prototype.drawHitDetectionCanvas_ = function drawHitDetectionCanvas_ (renderOptions, context, x, y) {
        var this$1 = this;

        // reset transform
        context.setTransform(1, 0, 0, 1, 0, 0);

        // then move to (x, y)
        context.translate(x, y);

        context.beginPath();

        var points = this.points_;
        if (points === Infinity) {
          context.arc(
            renderOptions.size / 2, renderOptions.size / 2,
            this.radius_, 0, 2 * Math.PI, true);
        } else {
          var radius2 = (this.radius2_ !== undefined) ? this.radius2_
            : this.radius_;
          if (radius2 !== this.radius_) {
            points = 2 * points;
          }
          var i, radiusC, angle0;
          for (i = 0; i <= points; i++) {
            angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this$1.angle_;
            radiusC = i % 2 === 0 ? this$1.radius_ : radius2;
            context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0),
              renderOptions.size / 2 + radiusC * Math.sin(angle0));
          }
        }

        context.fillStyle = defaultFillStyle;
        context.fill();
        if (this.stroke_) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.stroke();
        }
        context.closePath();
      };

      /**
       * @return {string} The checksum.
       */
      RegularShape.prototype.getChecksum = function getChecksum () {
        var strokeChecksum = this.stroke_ ?
          this.stroke_.getChecksum() : '-';
        var fillChecksum = this.fill_ ?
          this.fill_.getChecksum() : '-';

        var recalculate = !this.checksums_ ||
            (strokeChecksum != this.checksums_[1] ||
            fillChecksum != this.checksums_[2] ||
            this.radius_ != this.checksums_[3] ||
            this.radius2_ != this.checksums_[4] ||
            this.angle_ != this.checksums_[5] ||
            this.points_ != this.checksums_[6]);

        if (recalculate) {
          var checksum = 'r' + strokeChecksum + fillChecksum +
              (this.radius_ !== undefined ? this.radius_.toString() : '-') +
              (this.radius2_ !== undefined ? this.radius2_.toString() : '-') +
              (this.angle_ !== undefined ? this.angle_.toString() : '-') +
              (this.points_ !== undefined ? this.points_.toString() : '-');
          this.checksums_ = [checksum, strokeChecksum, fillChecksum,
            this.radius_, this.radius2_, this.angle_, this.points_];
        }

        return this.checksums_[0];
      };

      return RegularShape;
    }(ImageStyle));

    /**
     * @module ol/style/Circle
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/style/Fill} [fill] Fill style.
     * @property {number} radius Circle radius.
     * @property {boolean} [snapToPixel=true] If `true` integral numbers of pixels are used as the X and Y pixel coordinate
     * when drawing the circle in the output canvas. If `false` fractional numbers may be used. Using `true` allows for
     * "sharp" rendering (no blur), while using `false` allows for "accurate" rendering. Note that accuracy is important if
     * the circle's position is animated. Without it, the circle may jitter noticeably.
     * @property {module:ol/style/Stroke} [stroke] Stroke style.
     * @property {module:ol/style/AtlasManager} [atlasManager] The atlas manager to use for this circle.
     * When using WebGL it is recommended to use an atlas manager to avoid texture switching. If an atlas manager is given,
     * the circle is added to an atlas. By default no atlas manager is used.
     */


    /**
     * @classdesc
     * Set circle style for vector features.
     * @api
     */
    var CircleStyle = (function (RegularShape$$1) {
      function CircleStyle(opt_options) {

        var options = opt_options || {};

        RegularShape$$1.call(this, {
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          snapToPixel: options.snapToPixel,
          stroke: options.stroke,
          atlasManager: options.atlasManager
        });

      }

      if ( RegularShape$$1 ) CircleStyle.__proto__ = RegularShape$$1;
      CircleStyle.prototype = Object.create( RegularShape$$1 && RegularShape$$1.prototype );
      CircleStyle.prototype.constructor = CircleStyle;

      /**
      * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
      * @return {module:ol/style/Circle} The cloned style.
      * @override
      * @api
      */
      CircleStyle.prototype.clone = function clone () {
        var style = new CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : undefined,
          stroke: this.getStroke() ? this.getStroke().clone() : undefined,
          radius: this.getRadius(),
          snapToPixel: this.getSnapToPixel(),
          atlasManager: this.atlasManager_
        });
        style.setOpacity(this.getOpacity());
        style.setScale(this.getScale());
        return style;
      };

      /**
      * Set the circle radius.
      *
      * @param {number} radius Circle radius.
      * @api
      */
      CircleStyle.prototype.setRadius = function setRadius (radius) {
        this.radius_ = radius;
        this.render_(this.atlasManager_);
      };

      return CircleStyle;
    }(RegularShape));

    /**
     * @module ol/style/Fill
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.
     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
     * Default null; if null, the Canvas/renderer default black will be used.
     */


    /**
     * @classdesc
     * Set fill style for vector features.
     * @api
     */
    var Fill = function Fill(opt_options) {

      var options = opt_options || {};

      /**
       * @private
       * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}
       */
      this.color_ = options.color !== undefined ? options.color : null;

      /**
       * @private
       * @type {string|undefined}
       */
      this.checksum_ = undefined;
    };

    /**
     * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
     * @return {module:ol/style/Fill} The cloned style.
     * @api
     */
    Fill.prototype.clone = function clone () {
      var color = this.getColor();
      return new Fill({
        color: (color && color.slice) ? color.slice() : color || undefined
      });
    };

    /**
     * Get the fill color.
     * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.
     * @api
     */
    Fill.prototype.getColor = function getColor () {
      return this.color_;
    };

    /**
     * Set the color.
     *
     * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
     * @api
     */
    Fill.prototype.setColor = function setColor (color) {
      this.color_ = color;
      this.checksum_ = undefined;
    };

    /**
     * @return {string} The checksum.
     */
    Fill.prototype.getChecksum = function getChecksum () {
      if (this.checksum_ === undefined) {
        if (
          this.color_ instanceof CanvasPattern ||
            this.color_ instanceof CanvasGradient
        ) {
          this.checksum_ = getUid(this.color_).toString();
        } else {
          this.checksum_ = 'f' + (this.color_ ? asString(this.color_) : '-');
        }
      }

      return this.checksum_;
    };

    /**
     * @module ol/style/Stroke
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/color~Color|module:ol/colorlike~ColorLike} [color] A color, gradient or pattern.
     * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
     * Default null; if null, the Canvas/renderer default black will be used.
     * @property {string} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
     * @property {string} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
     * @property {Array.<number>} [lineDash] Line dash pattern. Default is `undefined` (no dash).
     * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
     * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
     * @property {number} [lineDashOffset=0] Line dash offset.
     * @property {number} [miterLimit=10] Miter limit.
     * @property {number} [width] Width.
     */


    /**
     * @classdesc
     * Set stroke style for vector features.
     * Note that the defaults given are the Canvas defaults, which will be used if
     * option is not defined. The `get` functions return whatever was entered in
     * the options; they will not return the default.
     * @api
     */
    var Stroke = function Stroke(opt_options) {

      var options = opt_options || {};

      /**
       * @private
       * @type {module:ol/color~Color|module:ol/colorlike~ColorLike}
       */
      this.color_ = options.color !== undefined ? options.color : null;

      /**
       * @private
       * @type {string|undefined}
       */
      this.lineCap_ = options.lineCap;

      /**
       * @private
       * @type {Array.<number>}
       */
      this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

      /**
       * @private
       * @type {number|undefined}
       */
      this.lineDashOffset_ = options.lineDashOffset;

      /**
       * @private
       * @type {string|undefined}
       */
      this.lineJoin_ = options.lineJoin;

      /**
       * @private
       * @type {number|undefined}
       */
      this.miterLimit_ = options.miterLimit;

      /**
       * @private
       * @type {number|undefined}
       */
      this.width_ = options.width;

      /**
       * @private
       * @type {string|undefined}
       */
      this.checksum_ = undefined;
    };

    /**
     * Clones the style.
     * @return {module:ol/style/Stroke} The cloned style.
     * @api
     */
    Stroke.prototype.clone = function clone () {
      var color = this.getColor();
      return new Stroke({
        color: (color && color.slice) ? color.slice() : color || undefined,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    };

    /**
     * Get the stroke color.
     * @return {module:ol/color~Color|module:ol/colorlike~ColorLike} Color.
     * @api
     */
    Stroke.prototype.getColor = function getColor () {
      return this.color_;
    };

    /**
     * Get the line cap type for the stroke.
     * @return {string|undefined} Line cap.
     * @api
     */
    Stroke.prototype.getLineCap = function getLineCap () {
      return this.lineCap_;
    };

    /**
     * Get the line dash style for the stroke.
     * @return {Array.<number>} Line dash.
     * @api
     */
    Stroke.prototype.getLineDash = function getLineDash () {
      return this.lineDash_;
    };

    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    Stroke.prototype.getLineDashOffset = function getLineDashOffset () {
      return this.lineDashOffset_;
    };

    /**
     * Get the line join type for the stroke.
     * @return {string|undefined} Line join.
     * @api
     */
    Stroke.prototype.getLineJoin = function getLineJoin () {
      return this.lineJoin_;
    };

    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    Stroke.prototype.getMiterLimit = function getMiterLimit () {
      return this.miterLimit_;
    };

    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    Stroke.prototype.getWidth = function getWidth () {
      return this.width_;
    };

    /**
     * Set the color.
     *
     * @param {module:ol/color~Color|module:ol/colorlike~ColorLike} color Color.
     * @api
     */
    Stroke.prototype.setColor = function setColor (color) {
      this.color_ = color;
      this.checksum_ = undefined;
    };

    /**
     * Set the line cap.
     *
     * @param {string|undefined} lineCap Line cap.
     * @api
     */
    Stroke.prototype.setLineCap = function setLineCap (lineCap) {
      this.lineCap_ = lineCap;
      this.checksum_ = undefined;
    };

    /**
     * Set the line dash.
     *
     * Please note that Internet Explorer 10 and lower [do not support][mdn] the
     * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
     * property will have no visual effect in these browsers.
     *
     * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
     *
     * @param {Array.<number>} lineDash Line dash.
     * @api
     */
    Stroke.prototype.setLineDash = function setLineDash (lineDash) {
      this.lineDash_ = lineDash;
      this.checksum_ = undefined;
    };

    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    Stroke.prototype.setLineDashOffset = function setLineDashOffset (lineDashOffset) {
      this.lineDashOffset_ = lineDashOffset;
      this.checksum_ = undefined;
    };

    /**
     * Set the line join.
     *
     * @param {string|undefined} lineJoin Line join.
     * @api
     */
    Stroke.prototype.setLineJoin = function setLineJoin (lineJoin) {
      this.lineJoin_ = lineJoin;
      this.checksum_ = undefined;
    };

    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    Stroke.prototype.setMiterLimit = function setMiterLimit (miterLimit) {
      this.miterLimit_ = miterLimit;
      this.checksum_ = undefined;
    };

    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    Stroke.prototype.setWidth = function setWidth (width) {
      this.width_ = width;
      this.checksum_ = undefined;
    };

    /**
     * @return {string} The checksum.
     */
    Stroke.prototype.getChecksum = function getChecksum () {
      if (this.checksum_ === undefined) {
        this.checksum_ = 's';
        if (this.color_) {
          if (typeof this.color_ === 'string') {
            this.checksum_ += this.color_;
          } else {
            this.checksum_ += getUid(this.color_).toString();
          }
        } else {
          this.checksum_ += '-';
        }
        this.checksum_ += ',' +
            (this.lineCap_ !== undefined ?
              this.lineCap_.toString() : '-') + ',' +
            (this.lineDash_ ?
              this.lineDash_.toString() : '-') + ',' +
            (this.lineDashOffset_ !== undefined ?
              this.lineDashOffset_ : '-') + ',' +
            (this.lineJoin_ !== undefined ?
              this.lineJoin_ : '-') + ',' +
            (this.miterLimit_ !== undefined ?
              this.miterLimit_.toString() : '-') + ',' +
            (this.width_ !== undefined ?
              this.width_.toString() : '-');
      }

      return this.checksum_;
    };

    /**
     * @module ol/style/Style
     */


    /**
     * A function that takes an {@link module:ol/Feature} and a `{number}`
     * representing the view's resolution. The function should return a
     * {@link module:ol/style/Style} or an array of them. This way e.g. a
     * vector layer can be styled.
     *
     * @typedef {function((module:ol/Feature|module:ol/render/Feature), number):
     *     (module:ol/style/Style|Array.<module:ol/style/Style>)} StyleFunction
     */


    /**
     * A function that takes an {@link module:ol/Feature} as argument and returns an
     * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
     *
     * @typedef {function((module:ol/Feature|module:ol/render/Feature)):
     *     (module:ol/geom/Geometry|module:ol/render/Feature|undefined)} GeometryFunction
     */


    /**
     * Custom renderer function. Takes two arguments:
     *
     * 1. The pixel coordinates of the geometry in GeoJSON notation.
     * 2. The {@link module:ol/render~State} of the layer renderer.
     *
     * @typedef {function((module:ol/coordinate~Coordinate|Array<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>),module:ol/render~State)}
     * RenderFunction
     */


    /**
     * @typedef {Object} Options
     * @property {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} [geometry] Feature property or geometry
     * or function returning a geometry to render for this style.
     * @property {module:ol/style/Fill} [fill] Fill style.
     * @property {module:ol/style/Image} [image] Image style.
     * @property {module:ol/style/Style~RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
     * ignored, and the provided function will be called with each render frame for each geometry.
     * @property {module:ol/style/Stroke} [stroke] Stroke style.
     * @property {module:ol/style/Text} [text] Text style.
     * @property {number} [zIndex] Z index.
     */


    /**
     * @classdesc
     * Container for vector feature rendering styles. Any changes made to the style
     * or its children through `set*()` methods will not take effect until the
     * feature or layer that uses the style is re-rendered.
     * @api
     */
    var Style = function Style(opt_options) {

      var options = opt_options || {};

      /**
       * @private
       * @type {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}
       */
      this.geometry_ = null;

      /**
       * @private
       * @type {!module:ol/style/Style~GeometryFunction}
       */
      this.geometryFunction_ = defaultGeometryFunction;

      if (options.geometry !== undefined) {
        this.setGeometry(options.geometry);
      }

      /**
       * @private
       * @type {module:ol/style/Fill}
       */
      this.fill_ = options.fill !== undefined ? options.fill : null;

      /**
         * @private
         * @type {module:ol/style/Image}
         */
      this.image_ = options.image !== undefined ? options.image : null;

      /**
       * @private
       * @type {module:ol/style/Style~RenderFunction|null}
       */
      this.renderer_ = options.renderer !== undefined ? options.renderer : null;

      /**
       * @private
       * @type {module:ol/style/Stroke}
       */
      this.stroke_ = options.stroke !== undefined ? options.stroke : null;

      /**
       * @private
       * @type {module:ol/style/Text}
       */
      this.text_ = options.text !== undefined ? options.text : null;

      /**
       * @private
       * @type {number|undefined}
       */
      this.zIndex_ = options.zIndex;

    };

    /**
     * Clones the style.
     * @return {module:ol/style/Style} The cloned style.
     * @api
     */
    Style.prototype.clone = function clone () {
      var geometry = this.getGeometry();
      if (geometry && geometry.clone) {
        geometry = geometry.clone();
      }
      return new Style({
        geometry: geometry,
        fill: this.getFill() ? this.getFill().clone() : undefined,
        image: this.getImage() ? this.getImage().clone() : undefined,
        stroke: this.getStroke() ? this.getStroke().clone() : undefined,
        text: this.getText() ? this.getText().clone() : undefined,
        zIndex: this.getZIndex()
      });
    };

    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {module:ol/style/Style~RenderFunction|null} Custom renderer function.
     * @api
     */
    Style.prototype.getRenderer = function getRenderer () {
      return this.renderer_;
    };

    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {module:ol/style/Style~RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    Style.prototype.setRenderer = function setRenderer (renderer) {
      this.renderer_ = renderer;
    };

    /**
     * Get the geometry to be rendered.
     * @return {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    Style.prototype.getGeometry = function getGeometry () {
      return this.geometry_;
    };

    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!module:ol/style/Style~GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    Style.prototype.getGeometryFunction = function getGeometryFunction () {
      return this.geometryFunction_;
    };

    /**
     * Get the fill style.
     * @return {module:ol/style/Fill} Fill style.
     * @api
     */
    Style.prototype.getFill = function getFill () {
      return this.fill_;
    };

    /**
     * Set the fill style.
     * @param {module:ol/style/Fill} fill Fill style.
     * @api
     */
    Style.prototype.setFill = function setFill (fill) {
      this.fill_ = fill;
    };

    /**
     * Get the image style.
     * @return {module:ol/style/Image} Image style.
     * @api
     */
    Style.prototype.getImage = function getImage () {
      return this.image_;
    };

    /**
     * Set the image style.
     * @param {module:ol/style/Image} image Image style.
     * @api
     */
    Style.prototype.setImage = function setImage (image) {
      this.image_ = image;
    };

    /**
     * Get the stroke style.
     * @return {module:ol/style/Stroke} Stroke style.
     * @api
     */
    Style.prototype.getStroke = function getStroke () {
      return this.stroke_;
    };

    /**
     * Set the stroke style.
     * @param {module:ol/style/Stroke} stroke Stroke style.
     * @api
     */
    Style.prototype.setStroke = function setStroke (stroke) {
      this.stroke_ = stroke;
    };

    /**
     * Get the text style.
     * @return {module:ol/style/Text} Text style.
     * @api
     */
    Style.prototype.getText = function getText () {
      return this.text_;
    };

    /**
     * Set the text style.
     * @param {module:ol/style/Text} text Text style.
     * @api
     */
    Style.prototype.setText = function setText (text) {
      this.text_ = text;
    };

    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    Style.prototype.getZIndex = function getZIndex () {
      return this.zIndex_;
    };

    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|module:ol/geom/Geometry|module:ol/style/Style~GeometryFunction} geometry
     *   Feature property or geometry or function returning a geometry to render
     *   for this style.
     * @api
     */
    Style.prototype.setGeometry = function setGeometry (geometry) {
      if (typeof geometry === 'function') {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === 'string') {
        this.geometryFunction_ = function(feature) {
          return (
            /** @type {module:ol/geom/Geometry} */ (feature.get(geometry))
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== undefined) {
        this.geometryFunction_ = function() {
          return (
            /** @type {module:ol/geom/Geometry} */ (geometry)
          );
        };
      }
      this.geometry_ = geometry;
    };

    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    Style.prototype.setZIndex = function setZIndex (zIndex) {
      this.zIndex_ = zIndex;
    };


    /**
     * Convert the provided object into a style function.  Functions passed through
     * unchanged.  Arrays of module:ol/style/Style or single style objects wrapped in a
     * new style function.
     * @param {module:ol/style/Style~StyleFunction|Array.<module:ol/style/Style>|module:ol/style/Style} obj
     *     A style function, a single style, or an array of styles.
     * @return {module:ol/style/Style~StyleFunction} A style function.
     */
    function toFunction(obj) {
      var styleFunction;

      if (typeof obj === 'function') {
        styleFunction = obj;
      } else {
        /**
         * @type {Array.<module:ol/style/Style>}
         */
        var styles;
        if (Array.isArray(obj)) {
          styles = obj;
        } else {
          assert(obj instanceof Style,
            41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`
          styles = [obj];
        }
        styleFunction = function() {
          return styles;
        };
      }
      return styleFunction;
    }


    /**
     * @type {Array.<module:ol/style/Style>}
     */
    var defaultStyles = null;


    /**
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     * @param {number} resolution Resolution.
     * @return {Array.<module:ol/style/Style>} Style.
     */
    function createDefaultStyle(feature, resolution) {
      // We don't use an immediately-invoked function
      // and a closure so we don't get an error at script evaluation time in
      // browsers that do not support Canvas. (module:ol/style/Circle~CircleStyle does
      // canvas.getContext('2d') at construction time, which will cause an.error
      // in such browsers.)
      if (!defaultStyles) {
        var fill = new Fill({
          color: 'rgba(255,255,255,0.4)'
        });
        var stroke = new Stroke({
          color: '#3399CC',
          width: 1.25
        });
        defaultStyles = [
          new Style({
            image: new CircleStyle({
              fill: fill,
              stroke: stroke,
              radius: 5
            }),
            fill: fill,
            stroke: stroke
          })
        ];
      }
      return defaultStyles;
    }


    /**
     * Default styles for editing features.
     * @return {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} Styles
     */
    function createEditingStyle() {
      /** @type {Object.<module:ol/geom/GeometryType, Array.<module:ol/style/Style>>} */
      var styles = {};
      var white = [255, 255, 255, 1];
      var blue = [0, 153, 255, 1];
      var width = 3;
      styles[GeometryType.POLYGON] = [
        new Style({
          fill: new Fill({
            color: [255, 255, 255, 0.5]
          })
        })
      ];
      styles[GeometryType.MULTI_POLYGON] =
          styles[GeometryType.POLYGON];

      styles[GeometryType.LINE_STRING] = [
        new Style({
          stroke: new Stroke({
            color: white,
            width: width + 2
          })
        }),
        new Style({
          stroke: new Stroke({
            color: blue,
            width: width
          })
        })
      ];
      styles[GeometryType.MULTI_LINE_STRING] =
          styles[GeometryType.LINE_STRING];

      styles[GeometryType.CIRCLE] =
          styles[GeometryType.POLYGON].concat(
            styles[GeometryType.LINE_STRING]
          );


      styles[GeometryType.POINT] = [
        new Style({
          image: new CircleStyle({
            radius: width * 2,
            fill: new Fill({
              color: blue
            }),
            stroke: new Stroke({
              color: white,
              width: width / 2
            })
          }),
          zIndex: Infinity
        })
      ];
      styles[GeometryType.MULTI_POINT] =
          styles[GeometryType.POINT];

      styles[GeometryType.GEOMETRY_COLLECTION] =
          styles[GeometryType.POLYGON].concat(
            styles[GeometryType.LINE_STRING],
            styles[GeometryType.POINT]
          );

      return styles;
    }


    /**
     * Function that is called with a feature and returns its default geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature to get the geometry for.
     * @return {module:ol/geom/Geometry|module:ol/render/Feature|undefined} Geometry to render.
     */
    function defaultGeometryFunction(feature) {
      return feature.getGeometry();
    }

    /**
     * @module ol/Feature
     */

    /**
     * @classdesc
     * A vector object for geographic features with a geometry and other
     * attribute properties, similar to the features in vector file formats like
     * GeoJSON.
     *
     * Features can be styled individually with `setStyle`; otherwise they use the
     * style of their vector layer.
     *
     * Note that attribute properties are set as {@link module:ol/Object} properties on
     * the feature object, so they are observable, and have get/set accessors.
     *
     * Typically, a feature has a single geometry property. You can set the
     * geometry using the `setGeometry` method and get it with `getGeometry`.
     * It is possible to store more than one geometry on a feature using attribute
     * properties. By default, the geometry used for rendering is identified by
     * the property name `geometry`. If you want to use another geometry property
     * for rendering, use the `setGeometryName` method to change the attribute
     * property associated with the geometry for the feature.  For example:
     *
     * ```js
     *
     * import Feature from 'ol/Feature';
     * import Polygon from 'ol/geom/Polygon';
     * import Point from 'ol/geom/Point';
     *
     * var feature = new Feature({
     *   geometry: new Polygon(polyCoords),
     *   labelPoint: new Point(labelCoords),
     *   name: 'My Polygon'
     * });
     *
     * // get the polygon geometry
     * var poly = feature.getGeometry();
     *
     * // Render the feature as a point using the coordinates from labelPoint
     * feature.setGeometryName('labelPoint');
     *
     * // get the point geometry
     * var point = feature.getGeometry();
     * ```
     *
     * @api
     */
    var Feature = (function (BaseObject$$1) {
      function Feature(opt_geometryOrProperties) {

        BaseObject$$1.call(this);

        /**
         * @private
         * @type {number|string|undefined}
         */
        this.id_ = undefined;

        /**
         * @type {string}
         * @private
         */
        this.geometryName_ = 'geometry';

        /**
         * User provided style.
         * @private
         * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
         */
        this.style_ = null;

        /**
         * @private
         * @type {module:ol/style/Style~StyleFunction|undefined}
         */
        this.styleFunction_ = undefined;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.geometryChangeKey_ = null;

        listen(
          this, getChangeEventType(this.geometryName_),
          this.handleGeometryChanged_, this);

        if (opt_geometryOrProperties !== undefined) {
          if (opt_geometryOrProperties instanceof Geometry ||
              !opt_geometryOrProperties) {
            var geometry = opt_geometryOrProperties;
            this.setGeometry(geometry);
          } else {
            /** @type {Object.<string, *>} */
            var properties = opt_geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }

      if ( BaseObject$$1 ) Feature.__proto__ = BaseObject$$1;
      Feature.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Feature.prototype.constructor = Feature;

      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {module:ol/Feature} The clone.
       * @api
       */
      Feature.prototype.clone = function clone () {
        var clone = new Feature(this.getProperties());
        clone.setGeometryName(this.getGeometryName());
        var geometry = this.getGeometry();
        if (geometry) {
          clone.setGeometry(geometry.clone());
        }
        var style = this.getStyle();
        if (style) {
          clone.setStyle(style);
        }
        return clone;
      };

      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {module:ol/geom/Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      Feature.prototype.getGeometry = function getGeometry () {
        return (
          /** @type {module:ol/geom/Geometry|undefined} */ (this.get(this.geometryName_))
        );
      };

      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      Feature.prototype.getId = function getId () {
        return this.id_;
      };

      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      Feature.prototype.getGeometryName = function getGeometryName () {
        return this.geometryName_;
      };

      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} The feature style.
       * @api
       */
      Feature.prototype.getStyle = function getStyle () {
        return this.style_;
      };

      /**
       * Get the feature's style function.
       * @return {module:ol/style/Style~StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      Feature.prototype.getStyleFunction = function getStyleFunction () {
        return this.styleFunction_;
      };

      /**
       * @private
       */
      Feature.prototype.handleGeometryChange_ = function handleGeometryChange_ () {
        this.changed();
      };

      /**
       * @private
       */
      Feature.prototype.handleGeometryChanged_ = function handleGeometryChanged_ () {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        var geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(geometry,
            EventType.CHANGE, this.handleGeometryChange_, this);
        }
        this.changed();
      };

      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {module:ol/geom/Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      Feature.prototype.setGeometry = function setGeometry (geometry) {
        this.set(this.geometryName_, geometry);
      };

      /**
       * Set the style for the feature.  This can be a single style object, an array
       * of styles, or a function that takes a resolution and returns an array of
       * styles. If it is `null` the feature has no style (a `null` style).
       * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} style Style for this feature.
       * @api
       * @fires module:ol/events/Event~Event#event:change
       */
      Feature.prototype.setStyle = function setStyle (style) {
        this.style_ = style;
        this.styleFunction_ = !style ? undefined : createStyleFunction(style);
        this.changed();
      };

      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~Event#event:change
       */
      Feature.prototype.setId = function setId (id) {
        this.id_ = id;
        this.changed();
      };

      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      Feature.prototype.setGeometryName = function setGeometryName (name) {
        unlisten(
          this, getChangeEventType(this.geometryName_),
          this.handleGeometryChanged_, this);
        this.geometryName_ = name;
        listen(
          this, getChangeEventType(this.geometryName_),
          this.handleGeometryChanged_, this);
        this.handleGeometryChanged_();
      };

      return Feature;
    }(BaseObject));


    /**
     * Convert the provided object into a feature style function.  Functions passed
     * through unchanged.  Arrays of module:ol/style/Style or single style objects wrapped
     * in a new feature style function.
     * @param {module:ol/style/Style~StyleFunction|!Array.<module:ol/style/Style>|!module:ol/style/Style} obj
     *     A feature style function, a single style, or an array of styles.
     * @return {module:ol/style/Style~StyleFunction} A style function.
     */
    function createStyleFunction(obj) {
      if (typeof obj === 'function') {
        return obj;
      } else {
        /**
         * @type {Array.<module:ol/style/Style>}
         */
        var styles;
        if (Array.isArray(obj)) {
          styles = obj;
        } else {
          assert(obj instanceof Style,
            41); // Expected an `module:ol/style/Style~Style` or an array of `module:ol/style/Style~Style`
          styles = [obj];
        }
        return function() {
          return styles;
        };
      }
    }

    /**
     * @module ol/geom/Circle
     */

    /**
     * @classdesc
     * Circle geometry.
     *
     * @api
     */
    var Circle = (function (SimpleGeometry$$1) {
      function Circle(center, opt_radius, opt_layout) {
        SimpleGeometry$$1.call(this);
        if (opt_layout !== undefined && opt_radius === undefined) {
          this.setFlatCoordinates(opt_layout, center);
        } else {
          var radius = opt_radius ? opt_radius : 0;
          this.setCenterAndRadius(center, radius, opt_layout);
        }
      }

      if ( SimpleGeometry$$1 ) Circle.__proto__ = SimpleGeometry$$1;
      Circle.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      Circle.prototype.constructor = Circle;

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/Circle} Clone.
       * @override
       * @api
       */
      Circle.prototype.clone = function clone$$1 () {
        return new Circle(this.flatCoordinates.slice(), undefined, this.layout);
      };

      /**
       * @inheritDoc
       */
      Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        var squaredDistance = dx * dx + dy * dy;
        if (squaredDistance < minSquaredDistance) {
          if (squaredDistance === 0) {
            for (var i = 0; i < this.stride; ++i) {
              closestPoint[i] = flatCoordinates[i];
            }
          } else {
            var delta = this.getRadius() / Math.sqrt(squaredDistance);
            closestPoint[0] = flatCoordinates[0] + delta * dx;
            closestPoint[1] = flatCoordinates[1] + delta * dy;
            for (var i$1 = 2; i$1 < this.stride; ++i$1) {
              closestPoint[i$1] = flatCoordinates[i$1];
            }
          }
          closestPoint.length = this.stride;
          return squaredDistance;
        } else {
          return minSquaredDistance;
        }
      };

      /**
       * @inheritDoc
       */
      Circle.prototype.containsXY = function containsXY$$1 (x, y) {
        var flatCoordinates = this.flatCoordinates;
        var dx = x - flatCoordinates[0];
        var dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
      };

      /**
       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @return {module:ol/coordinate~Coordinate} Center.
       * @api
       */
      Circle.prototype.getCenter = function getCenter$$1 () {
        return this.flatCoordinates.slice(0, this.stride);
      };

      /**
       * @inheritDoc
       */
      Circle.prototype.computeExtent = function computeExtent (extent) {
        var flatCoordinates = this.flatCoordinates;
        var radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return createOrUpdate(
          flatCoordinates[0] - radius, flatCoordinates[1] - radius,
          flatCoordinates[0] + radius, flatCoordinates[1] + radius,
          extent);
      };

      /**
       * Return the radius of the circle.
       * @return {number} Radius.
       * @api
       */
      Circle.prototype.getRadius = function getRadius () {
        return Math.sqrt(this.getRadiusSquared_());
      };

      /**
       * @private
       * @return {number} Radius squared.
       */
      Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {
        var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
      };

      /**
       * @inheritDoc
       * @api
       */
      Circle.prototype.getType = function getType () {
        return GeometryType.CIRCLE;
      };

      /**
       * @inheritDoc
       * @api
       */
      Circle.prototype.intersectsExtent = function intersectsExtent (extent) {
        var circleExtent = this.getExtent();
        if (intersects(extent, circleExtent)) {
          var center = this.getCenter();

          if (extent[0] <= center[0] && extent[2] >= center[0]) {
            return true;
          }
          if (extent[1] <= center[1] && extent[3] >= center[1]) {
            return true;
          }

          return forEachCorner(extent, this.intersectsCoordinate, this);
        }
        return false;

      };

      /**
       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {module:ol/coordinate~Coordinate} center Center.
       * @api
       */
      Circle.prototype.setCenter = function setCenter (center) {
        var stride = this.stride;
        var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        var flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for (var i = 1; i < stride; ++i) {
          flatCoordinates[stride + i] = center[i];
        }
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
      };

      /**
       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
       * number) of the circle.
       * @param {!module:ol/coordinate~Coordinate} center Center.
       * @param {number} radius Radius.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @api
       */
      Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {
        this.setLayout(opt_layout, center, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        /** @type {Array.<number>} */
        var flatCoordinates = this.flatCoordinates;
        var offset = deflateCoordinate(
          flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset++] = flatCoordinates[0] + radius;
        for (var i = 1, ii = this.stride; i < ii; ++i) {
          flatCoordinates[offset++] = flatCoordinates[i];
        }
        flatCoordinates.length = offset;
        this.changed();
      };

      /**
       * @inheritDoc
       */
      Circle.prototype.getCoordinates = function getCoordinates () {};

      /**
       * @inheritDoc
       */
      Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};

      /**
       * Set the radius of the circle. The radius is in the units of the projection.
       * @param {number} radius Radius.
       * @api
       */
      Circle.prototype.setRadius = function setRadius (radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
      };

      return Circle;
    }(SimpleGeometry));


    /**
     * Transform each coordinate of the circle from one coordinate reference system
     * to another. The geometry is modified in place.
     * If you do not want the geometry modified in place, first clone() it and
     * then use this function on the clone.
     *
     * Internally a circle is currently represented by two points: the center of
     * the circle `[cx, cy]`, and the point to the right of the circle
     * `[cx + r, cy]`. This `transform` function just transforms these two points.
     * So the resulting geometry is also a circle, and that circle does not
     * correspond to the shape that would be obtained by transforming every point
     * of the original circle.
     *
     * @param {module:ol/proj~ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {module:ol/proj~ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {module:ol/geom/Circle} This geometry.  Note that original geometry is
     *     modified in place.
     * @function
     * @api
     */
    Circle.prototype.transform;

    /**
     * @module ol/geom/flat/interpolate
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} fraction Fraction.
     * @param {Array.<number>=} opt_dest Destination.
     * @return {Array.<number>} Destination.
     */
    function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {
      var pointX = NaN;
      var pointY = NaN;
      var n = (end - offset) / stride;
      if (n === 1) {
        pointX = flatCoordinates[offset];
        pointY = flatCoordinates[offset + 1];
      } else if (n == 2) {
        pointX = (1 - fraction) * flatCoordinates[offset] +
            fraction * flatCoordinates[offset + stride];
        pointY = (1 - fraction) * flatCoordinates[offset + 1] +
            fraction * flatCoordinates[offset + stride + 1];
      } else if (n !== 0) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length = 0;
        var cumulativeLengths = [0];
        for (var i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          cumulativeLengths.push(length);
          x1 = x2;
          y1 = y2;
        }
        var target = fraction * length;
        var index = binarySearch(cumulativeLengths, target);
        if (index < 0) {
          var t = (target - cumulativeLengths[-index - 2]) /
              (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
          var o = offset + (-index - 2) * stride;
          pointX = lerp(
            flatCoordinates[o], flatCoordinates[o + stride], t);
          pointY = lerp(
            flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
        } else {
          pointX = flatCoordinates[offset + index * stride];
          pointY = flatCoordinates[offset + index * stride + 1];
        }
      }
      if (opt_dest) {
        opt_dest[0] = pointX;
        opt_dest[1] = pointY;
        return opt_dest;
      } else {
        return [pointX, pointY];
      }
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {number} m M.
     * @param {boolean} extrapolate Extrapolate.
     * @return {module:ol/coordinate~Coordinate} Coordinate.
     */
    function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
      if (end == offset) {
        return null;
      }
      var coordinate;
      if (m < flatCoordinates[offset + stride - 1]) {
        if (extrapolate) {
          coordinate = flatCoordinates.slice(offset, offset + stride);
          coordinate[stride - 1] = m;
          return coordinate;
        } else {
          return null;
        }
      } else if (flatCoordinates[end - 1] < m) {
        if (extrapolate) {
          coordinate = flatCoordinates.slice(end - stride, end);
          coordinate[stride - 1] = m;
          return coordinate;
        } else {
          return null;
        }
      }
      // FIXME use O(1) search
      if (m == flatCoordinates[offset + stride - 1]) {
        return flatCoordinates.slice(offset, offset + stride);
      }
      var lo = offset / stride;
      var hi = end / stride;
      while (lo < hi) {
        var mid = (lo + hi) >> 1;
        if (m < flatCoordinates[(mid + 1) * stride - 1]) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      var m0 = flatCoordinates[lo * stride - 1];
      if (m == m0) {
        return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
      }
      var m1 = flatCoordinates[(lo + 1) * stride - 1];
      var t = (m - m0) / (m1 - m0);
      coordinate = [];
      for (var i = 0; i < stride - 1; ++i) {
        coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],
          flatCoordinates[lo * stride + i], t));
      }
      coordinate.push(m);
      return coordinate;
    }


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {number} m M.
     * @param {boolean} extrapolate Extrapolate.
     * @param {boolean} interpolate Interpolate.
     * @return {module:ol/coordinate~Coordinate} Coordinate.
     */
    function lineStringsCoordinateAtM(
      flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
      if (interpolate) {
        return lineStringCoordinateAtM(
          flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
      }
      var coordinate;
      if (m < flatCoordinates[stride - 1]) {
        if (extrapolate) {
          coordinate = flatCoordinates.slice(0, stride);
          coordinate[stride - 1] = m;
          return coordinate;
        } else {
          return null;
        }
      }
      if (flatCoordinates[flatCoordinates.length - 1] < m) {
        if (extrapolate) {
          coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
          coordinate[stride - 1] = m;
          return coordinate;
        } else {
          return null;
        }
      }
      for (var i = 0, ii = ends.length; i < ii; ++i) {
        var end = ends[i];
        if (offset == end) {
          continue;
        }
        if (m < flatCoordinates[offset + stride - 1]) {
          return null;
        } else if (m <= flatCoordinates[end - 1]) {
          return lineStringCoordinateAtM(
            flatCoordinates, offset, end, stride, m, false);
        }
        offset = end;
      }
      return null;
    }

    /**
     * @module ol/geom/flat/length
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {number} Length.
     */
    function lineStringLength(flatCoordinates, offset, end, stride) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      var length = 0;
      for (var i = offset + stride; i < end; i += stride) {
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        x1 = x2;
        y1 = y2;
      }
      return length;
    }

    /**
     * @module ol/geom/LineString
     */

    /**
     * @classdesc
     * Linestring geometry.
     *
     * @api
     */
    var LineString = (function (SimpleGeometry$$1) {
      function LineString(coordinates, opt_layout) {

        SimpleGeometry$$1.call(this);

        /**
         * @private
         * @type {module:ol/coordinate~Coordinate}
         */
        this.flatMidpoint_ = null;

        /**
         * @private
         * @type {number}
         */
        this.flatMidpointRevision_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDelta_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDeltaRevision_ = -1;

        if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
          this.setFlatCoordinates(opt_layout, coordinates);
        } else {
          this.setCoordinates(coordinates, opt_layout);
        }

      }

      if ( SimpleGeometry$$1 ) LineString.__proto__ = SimpleGeometry$$1;
      LineString.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      LineString.prototype.constructor = LineString;

      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @api
       */
      LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = coordinate.slice();
        } else {
          extend(this.flatCoordinates, coordinate);
        }
        this.changed();
      };

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/LineString} Clone.
       * @override
       * @api
       */
      LineString.prototype.clone = function clone$$1 () {
        return new LineString(this.flatCoordinates.slice(), this.layout);
      };

      /**
       * @inheritDoc
       */
      LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(maxSquaredDelta(
            this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };

      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, module:ol/coordinate~Coordinate, module:ol/coordinate~Coordinate): T} callback Function
       *     called for each segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {
        return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
      };

      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @return {module:ol/coordinate~Coordinate} Coordinate.
       * @api
       */
      LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {
        if (this.layout != GeometryLayout.XYM &&
            this.layout != GeometryLayout.XYZM) {
          return null;
        }
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        return lineStringCoordinateAtM(this.flatCoordinates, 0,
          this.flatCoordinates.length, this.stride, m, extrapolate);
      };

      /**
       * Return the coordinates of the linestring.
       * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
       * @override
       * @api
       */
      LineString.prototype.getCoordinates = function getCoordinates () {
        return inflateCoordinates(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };

      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {module:ol/coordinate~Coordinate=} opt_dest Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {module:ol/coordinate~Coordinate} Coordinate of the interpolated point.
       * @api
       */
      LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {
        return interpolatePoint(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          fraction, opt_dest);
      };

      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      LineString.prototype.getLength = function getLength () {
        return lineStringLength(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };

      /**
       * @return {Array.<number>} Flat midpoint.
       */
      LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
          this.flatMidpointRevision_ = this.getRevision();
        }
        return this.flatMidpoint_;
      };

      /**
       * @inheritDoc
       */
      LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          squaredTolerance, simplifiedFlatCoordinates, 0);
        return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
      };

      /**
       * @inheritDoc
       * @api
       */
      LineString.prototype.getType = function getType () {
        return GeometryType.LINE_STRING;
      };

      /**
       * @inheritDoc
       * @api
       */
      LineString.prototype.intersectsExtent = function intersectsExtent (extent) {
        return intersectsLineString(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,
          extent);
      };

      /**
       * Set the coordinates of the linestring.
       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      };

      return LineString;
    }(SimpleGeometry));

    /**
     * @module ol/geom/MultiLineString
     */

    /**
     * @classdesc
     * Multi-linestring geometry.
     *
     * @api
     */
    var MultiLineString = (function (SimpleGeometry$$1) {
      function MultiLineString(coordinates, opt_layout, opt_ends) {

        SimpleGeometry$$1.call(this);

        /**
         * @type {Array.<number>}
         * @private
         */
        this.ends_ = [];

        /**
         * @private
         * @type {number}
         */
        this.maxDelta_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDeltaRevision_ = -1;

        if (Array.isArray(coordinates[0])) {
          this.setCoordinates(coordinates, opt_layout);
        } else if (opt_layout !== undefined && opt_ends) {
          this.setFlatCoordinates(opt_layout, coordinates);
          this.ends_ = opt_ends;
        } else {
          var layout = this.getLayout();
          var flatCoordinates = [];
          var ends = [];
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            var lineString = coordinates[i];
            if (i === 0) {
              layout = lineString.getLayout();
            }
            extend(flatCoordinates, lineString.getFlatCoordinates());
            ends.push(flatCoordinates.length);
          }
          this.setFlatCoordinates(layout, flatCoordinates);
          this.ends_ = ends;
        }

      }

      if ( SimpleGeometry$$1 ) MultiLineString.__proto__ = SimpleGeometry$$1;
      MultiLineString.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      MultiLineString.prototype.constructor = MultiLineString;

      /**
       * Append the passed linestring to the multilinestring.
       * @param {module:ol/geom/LineString} lineString LineString.
       * @api
       */
      MultiLineString.prototype.appendLineString = function appendLineString (lineString) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = lineString.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      };

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/MultiLineString} Clone.
       * @override
       * @api
       */
      MultiLineString.prototype.clone = function clone$$1 () {
        return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };

      /**
       * @inheritDoc
       */
      MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(
            this.flatCoordinates, 0, this.ends_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates, 0, this.ends_, this.stride,
          this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };

      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `opt_interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `opt_interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
       * @return {module:ol/coordinate~Coordinate} Coordinate.
       * @api
       */
      MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {
        if ((this.layout != GeometryLayout.XYM &&
             this.layout != GeometryLayout.XYZM) ||
            this.flatCoordinates.length === 0) {
          return null;
        }
        var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
        var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
        return lineStringsCoordinateAtM(this.flatCoordinates, 0,
          this.ends_, this.stride, m, extrapolate, interpolate);
      };

      /**
       * Return the coordinates of the multilinestring.
       * @return {Array.<Array.<module:ol/coordinate~Coordinate>>} Coordinates.
       * @override
       * @api
       */
      MultiLineString.prototype.getCoordinates = function getCoordinates () {
        return inflateCoordinatesArray(
          this.flatCoordinates, 0, this.ends_, this.stride);
      };

      /**
       * @return {Array.<number>} Ends.
       */
      MultiLineString.prototype.getEnds = function getEnds () {
        return this.ends_;
      };

      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {module:ol/geom/LineString} LineString.
       * @api
       */
      MultiLineString.prototype.getLineString = function getLineString (index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LineString(this.flatCoordinates.slice(
          index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };

      /**
       * Return the linestrings of this multilinestring.
       * @return {Array.<module:ol/geom/LineString>} LineStrings.
       * @api
       */
      MultiLineString.prototype.getLineStrings = function getLineStrings () {
        var flatCoordinates = this.flatCoordinates;
        var ends = this.ends_;
        var layout = this.layout;
        /** @type {Array.<module:ol/geom/LineString>} */
        var lineStrings = [];
        var offset = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
          lineStrings.push(lineString);
          offset = end;
        }
        return lineStrings;
      };

      /**
       * @return {Array.<number>} Flat midpoints.
       */
      MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {
        var midpoints = [];
        var flatCoordinates = this.flatCoordinates;
        var offset = 0;
        var ends = this.ends_;
        var stride = this.stride;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var midpoint = interpolatePoint(
            flatCoordinates, offset, end, stride, 0.5);
          extend(midpoints, midpoint);
          offset = end;
        }
        return midpoints;
      };

      /**
       * @inheritDoc
       */
      MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,
          simplifiedFlatCoordinates, 0, simplifiedEnds);
        return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiLineString.prototype.getType = function getType () {
        return GeometryType.MULTI_LINE_STRING;
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {
        return intersectsLineStringArray(
          this.flatCoordinates, 0, this.ends_, this.stride, extent);
      };

      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array.<Array.<module:ol/coordinate~Coordinate>>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        var ends = deflateCoordinatesArray(
          this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      };

      return MultiLineString;
    }(SimpleGeometry));

    /**
     * @module ol/geom/MultiPoint
     */

    /**
     * @classdesc
     * Multi-point geometry.
     *
     * @api
     */
    var MultiPoint = (function (SimpleGeometry$$1) {
      function MultiPoint(coordinates, opt_layout) {
        SimpleGeometry$$1.call(this);
        if (opt_layout && !Array.isArray(coordinates[0])) {
          this.setFlatCoordinates(opt_layout, coordinates);
        } else {
          this.setCoordinates(coordinates, opt_layout);
        }
      }

      if ( SimpleGeometry$$1 ) MultiPoint.__proto__ = SimpleGeometry$$1;
      MultiPoint.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      MultiPoint.prototype.constructor = MultiPoint;

      /**
       * Append the passed point to this multipoint.
       * @param {module:ol/geom/Point} point Point.
       * @api
       */
      MultiPoint.prototype.appendPoint = function appendPoint (point) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = point.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, point.getFlatCoordinates());
        }
        this.changed();
      };

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/MultiPoint} Clone.
       * @override
       * @api
       */
      MultiPoint.prototype.clone = function clone$$1 () {
        var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
        return multiPoint;
      };

      /**
       * @inheritDoc
       */
      MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var squaredDistance$$1 = squaredDistance(
            x, y, flatCoordinates[i], flatCoordinates[i + 1]);
          if (squaredDistance$$1 < minSquaredDistance) {
            minSquaredDistance = squaredDistance$$1;
            for (var j = 0; j < stride; ++j) {
              closestPoint[j] = flatCoordinates[i + j];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      };

      /**
       * Return the coordinates of the multipoint.
       * @return {Array.<module:ol/coordinate~Coordinate>} Coordinates.
       * @override
       * @api
       */
      MultiPoint.prototype.getCoordinates = function getCoordinates () {
        return inflateCoordinates(
          this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };

      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {module:ol/geom/Point} Point.
       * @api
       */
      MultiPoint.prototype.getPoint = function getPoint (index) {
        var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) {
          return null;
        }
        return new Point(this.flatCoordinates.slice(
          index * this.stride, (index + 1) * this.stride), this.layout);
      };

      /**
       * Return the points of this multipoint.
       * @return {Array.<module:ol/geom/Point>} Points.
       * @api
       */
      MultiPoint.prototype.getPoints = function getPoints () {
        var flatCoordinates = this.flatCoordinates;
        var layout = this.layout;
        var stride = this.stride;
        /** @type {Array.<module:ol/geom/Point>} */
        var points = [];
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var point = new Point(flatCoordinates.slice(i, i + stride), layout);
          points.push(point);
        }
        return points;
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiPoint.prototype.getType = function getType () {
        return GeometryType.MULTI_POINT;
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {
        var flatCoordinates = this.flatCoordinates;
        var stride = this.stride;
        for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];
          if (containsXY(extent, x, y)) {
            return true;
          }
        }
        return false;
      };

      /**
       * Set the coordinates of the multipoint.
       * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates, 0, coordinates, this.stride);
        this.changed();
      };

      return MultiPoint;
    }(SimpleGeometry));

    /**
     * @module ol/geom/flat/center
     */


    /**
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array.<Array.<number>>} endss Endss.
     * @param {number} stride Stride.
     * @return {Array.<number>} Flat centers.
     */
    function linearRingss$1(flatCoordinates, offset, endss, stride) {
      var flatCenters = [];
      var extent = createEmpty();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
        var ends = endss[i];
        extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
        flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
        offset = ends[ends.length - 1];
      }
      return flatCenters;
    }

    /**
     * @module ol/geom/MultiPolygon
     */

    /**
     * @classdesc
     * Multi-polygon geometry.
     *
     * @api
     */
    var MultiPolygon = (function (SimpleGeometry$$1) {
      function MultiPolygon(coordinates, opt_layout, opt_endss) {

        SimpleGeometry$$1.call(this);

        /**
         * @type {Array.<Array.<number>>}
         * @private
         */
        this.endss_ = [];

        /**
         * @private
         * @type {number}
         */
        this.flatInteriorPointsRevision_ = -1;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.flatInteriorPoints_ = null;

        /**
         * @private
         * @type {number}
         */
        this.maxDelta_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.maxDeltaRevision_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.orientedRevision_ = -1;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.orientedFlatCoordinates_ = null;

        if (!opt_endss && !Array.isArray(coordinates[0])) {
          var layout = this.getLayout();
          var flatCoordinates = [];
          var endss = [];
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            var polygon = coordinates[i];
            if (i === 0) {
              layout = polygon.getLayout();
            }
            var offset = flatCoordinates.length;
            var ends = polygon.getEnds();
            for (var j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] += offset;
            }
            extend(flatCoordinates, polygon.getFlatCoordinates());
            endss.push(ends);
          }
          opt_layout = layout;
          coordinates = flatCoordinates;
          opt_endss = endss;
        }
        if (opt_layout !== undefined && opt_endss) {
          this.setFlatCoordinates(opt_layout, coordinates);
          this.endss_ = opt_endss;
        } else {
          this.setCoordinates(coordinates, opt_layout);
        }

      }

      if ( SimpleGeometry$$1 ) MultiPolygon.__proto__ = SimpleGeometry$$1;
      MultiPolygon.prototype = Object.create( SimpleGeometry$$1 && SimpleGeometry$$1.prototype );
      MultiPolygon.prototype.constructor = MultiPolygon;

      /**
       * Append the passed polygon to this multipolygon.
       * @param {module:ol/geom/Polygon} polygon Polygon.
       * @api
       */
      MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {
        /** @type {Array.<number>} */
        var ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          var offset = this.flatCoordinates.length;
          extend(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] += offset;
          }
        }
        this.endss_.push(ends);
        this.changed();
      };

      /**
       * Make a complete copy of the geometry.
       * @return {!module:ol/geom/MultiPolygon} Clone.
       * @override
       * @api
       */
      MultiPolygon.prototype.clone = function clone$$1 () {
        var this$1 = this;

        var len = this.endss_.length;
        var newEndss = new Array(len);
        for (var i = 0; i < len; ++i) {
          newEndss[i] = this$1.endss_[i].slice();
        }

        return new MultiPolygon(
          this.flatCoordinates.slice(), this.layout, newEndss);
      };

      /**
       * @inheritDoc
       */
      MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(
            this.flatCoordinates, 0, this.endss_, this.stride, 0));
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
          this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };

      /**
       * @inheritDoc
       */
      MultiPolygon.prototype.containsXY = function containsXY$$1 (x, y) {
        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
      };

      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      MultiPolygon.prototype.getArea = function getArea$$1 () {
        return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      };

      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} Coordinates.
       * @override
       * @api
       */
      MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {
        var flatCoordinates;
        if (opt_right !== undefined) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates, 0, this.endss_, this.stride, opt_right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }

        return inflateMultiCoordinatesArray(
          flatCoordinates, 0, this.endss_, this.stride);
      };

      /**
       * @return {Array.<Array.<number>>} Endss.
       */
      MultiPolygon.prototype.getEndss = function getEndss () {
        return this.endss_;
      };

      /**
       * @return {Array.<number>} Flat interior points.
       */
      MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          var flatCenters = linearRingss$1(
            this.flatCoordinates, 0, this.endss_, this.stride);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,
            flatCenters);
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return this.flatInteriorPoints_;
      };

      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
       * @return {module:ol/geom/MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {
        return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
      };

      /**
       * @return {Array.<number>} Oriented flat coordinates.
       */
      MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {
        if (this.orientedRevision_ != this.getRevision()) {
          var flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(
            flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length =
                orientLinearRingsArray(
                  this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
          }
          this.orientedRevision_ = this.getRevision();
        }
        return this.orientedFlatCoordinates_;
      };

      /**
       * @inheritDoc
       */
      MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {
        var simplifiedFlatCoordinates = [];
        var simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates, 0, this.endss_, this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates, 0, simplifiedEndss);
        return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
      };

      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {module:ol/geom/Polygon} Polygon.
       * @api
       */
      MultiPolygon.prototype.getPolygon = function getPolygon (index) {
        if (index < 0 || this.endss_.length <= index) {
          return null;
        }
        var offset;
        if (index === 0) {
          offset = 0;
        } else {
          var prevEnds = this.endss_[index - 1];
          offset = prevEnds[prevEnds.length - 1];
        }
        var ends = this.endss_[index].slice();
        var end = ends[ends.length - 1];
        if (offset !== 0) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] -= offset;
          }
        }
        return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
      };

      /**
       * Return the polygons of this multipolygon.
       * @return {Array.<module:ol/geom/Polygon>} Polygons.
       * @api
       */
      MultiPolygon.prototype.getPolygons = function getPolygons () {
        var layout = this.layout;
        var flatCoordinates = this.flatCoordinates;
        var endss = this.endss_;
        var polygons = [];
        var offset = 0;
        for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i].slice();
          var end = ends[ends.length - 1];
          if (offset !== 0) {
            for (var j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] -= offset;
            }
          }
          var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);
          polygons.push(polygon);
          offset = end;
        }
        return polygons;
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiPolygon.prototype.getType = function getType () {
        return GeometryType.MULTI_POLYGON;
      };

      /**
       * @inheritDoc
       * @api
       */
      MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
      };

      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array.<Array.<Array.<module:ol/coordinate~Coordinate>>>} coordinates Coordinates.
       * @param {module:ol/geom/GeometryLayout=} opt_layout Layout.
       * @override
       * @api
       */
      MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {
        this.setLayout(opt_layout, coordinates, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        var endss = deflateMultiCoordinatesArray(
          this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          var lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ?
            0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      };

      return MultiPolygon;
    }(SimpleGeometry));

    /**
     * @module ol/layer/VectorRenderType
     */

    /**
     * @enum {string}
     * Render mode for vector layers:
     *  * `'image'`: Vector layers are rendered as images. Great performance, but
     *    point symbols and texts are always rotated with the view and pixels are
     *    scaled during zoom animations.
     *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
     *    even during animations, but slower performance.
     * @api
     */
    var VectorRenderType = {
      IMAGE: 'image',
      VECTOR: 'vector'
    };

    /**
     * @module ol/layer/Vector
     */


    /**
     * @enum {string}
     * @private
     */
    var Property$2 = {
      RENDER_ORDER: 'renderOrder'
    };


    /**
     * @classdesc
     * Vector data that is rendered client-side.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @api
     */
    var VectorLayer = (function (Layer$$1) {
      function VectorLayer(opt_options) {
        var options = opt_options ?
          opt_options : /** @type {module:ol/layer/Vector~Options} */ ({});

        var baseOptions = assign({}, options);

        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        Layer$$1.call(this, baseOptions);

        /**
        * @private
        * @type {boolean}
        */
        this.declutter_ = options.declutter !== undefined ? options.declutter : false;

        /**
        * @type {number}
        * @private
        */
        this.renderBuffer_ = options.renderBuffer !== undefined ?
          options.renderBuffer : 100;

        /**
        * User provided style.
        * @type {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
        * @private
        */
        this.style_ = null;

        /**
        * Style function for use within the library.
        * @type {module:ol/style/Style~StyleFunction|undefined}
        * @private
        */
        this.styleFunction_ = undefined;

        this.setStyle(options.style);

        /**
        * @type {boolean}
        * @private
        */
        this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ?
          options.updateWhileAnimating : false;

        /**
        * @type {boolean}
        * @private
        */
        this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ?
          options.updateWhileInteracting : false;

        /**
        * @private
        * @type {module:ol/layer/VectorTileRenderType|string}
        */
        this.renderMode_ = options.renderMode || VectorRenderType.VECTOR;

        /**
        * The layer type.
        * @protected
        * @type {module:ol/LayerType}
        */
        this.type = LayerType.VECTOR;

      }

      if ( Layer$$1 ) VectorLayer.__proto__ = Layer$$1;
      VectorLayer.prototype = Object.create( Layer$$1 && Layer$$1.prototype );
      VectorLayer.prototype.constructor = VectorLayer;

      /**
      * @return {boolean} Declutter.
      */
      VectorLayer.prototype.getDeclutter = function getDeclutter () {
        return this.declutter_;
      };

      /**
      * @param {boolean} declutter Declutter.
      */
      VectorLayer.prototype.setDeclutter = function setDeclutter (declutter) {
        this.declutter_ = declutter;
      };

      /**
      * @return {number|undefined} Render buffer.
      */
      VectorLayer.prototype.getRenderBuffer = function getRenderBuffer () {
        return this.renderBuffer_;
      };

      /**
      * @return {function(module:ol/Feature, module:ol/Feature): number|null|undefined} Render
      *     order.
      */
      VectorLayer.prototype.getRenderOrder = function getRenderOrder () {
        return (
        /** @type {module:ol/render~OrderFunction|null|undefined} */ (this.get(Property$2.RENDER_ORDER))
        );
      };

      /**
      * Get the style for features.  This returns whatever was passed to the `style`
      * option at construction or to the `setStyle` method.
      * @return {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction}
      *     Layer style.
      * @api
      */
      VectorLayer.prototype.getStyle = function getStyle () {
        return this.style_;
      };

      /**
      * Get the style function.
      * @return {module:ol/style/Style~StyleFunction|undefined} Layer style function.
      * @api
      */
      VectorLayer.prototype.getStyleFunction = function getStyleFunction () {
        return this.styleFunction_;
      };

      /**
      * @return {boolean} Whether the rendered layer should be updated while
      *     animating.
      */
      VectorLayer.prototype.getUpdateWhileAnimating = function getUpdateWhileAnimating () {
        return this.updateWhileAnimating_;
      };

      /**
      * @return {boolean} Whether the rendered layer should be updated while
      *     interacting.
      */
      VectorLayer.prototype.getUpdateWhileInteracting = function getUpdateWhileInteracting () {
        return this.updateWhileInteracting_;
      };

      /**
      * @param {module:ol/render~OrderFunction|null|undefined} renderOrder
      *     Render order.
      */
      VectorLayer.prototype.setRenderOrder = function setRenderOrder (renderOrder) {
        this.set(Property$2.RENDER_ORDER, renderOrder);
      };

      /**
      * Set the style for features.  This can be a single style object, an array
      * of styles, or a function that takes a feature and resolution and returns
      * an array of styles. If it is `undefined` the default style is used. If
      * it is `null` the layer has no style (a `null` style), so only features
      * that have their own styles will be rendered in the layer. See
      * {@link module:ol/style} for information on the default style.
      * @param {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction|null|undefined}
      *     style Layer style.
      * @api
      */
      VectorLayer.prototype.setStyle = function setStyle (style) {
        this.style_ = style !== undefined ? style : createDefaultStyle;
        this.styleFunction_ = style === null ?
          undefined : toFunction(this.style_);
        this.changed();
      };

      /**
      * @return {module:ol/layer/VectorRenderType|string} The render mode.
      */
      VectorLayer.prototype.getRenderMode = function getRenderMode () {
        return this.renderMode_;
      };

      return VectorLayer;
    }(Layer));


    /**
     * Return the associated {@link module:ol/source/Vector vectorsource} of the layer.
     * @function
     * @return {module:ol/source/Vector} Source.
     * @api
     */
    VectorLayer.prototype.getSource;

    /**
     * @module ol/format/FormatType
     */

    /**
     * @enum {string}
     */
    var FormatType = {
      ARRAY_BUFFER: 'arraybuffer',
      JSON: 'json',
      TEXT: 'text',
      XML: 'xml'
    };

    /**
     * @module ol/featureloader
     */


    /**
     * {@link module:ol/source/Vector} sources use a function of this type to
     * load features.
     *
     * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
     * a `{number}` representing the resolution (map units per pixel) and an
     * {@link module:ol/proj/Projection} for the projection  as
     * arguments. `this` within the function is bound to the
     * {@link module:ol/source/Vector} it's called from.
     *
     * The function is responsible for loading the features and adding them to the
     * source.
     * @typedef {function(this:module:ol/source/Vector, module:ol/extent~Extent, number,
     *                    module:ol/proj/Projection)} FeatureLoader
     * @api
     */


    /**
     * {@link module:ol/source/Vector} sources use a function of this type to
     * get the url to load features from.
     *
     * This function takes an {@link module:ol/extent~Extent} representing the area
     * to be loaded, a `{number}` representing the resolution (map units per pixel)
     * and an {@link module:ol/proj/Projection} for the projection  as
     * arguments and returns a `{string}` representing the URL.
     * @typedef {function(module:ol/extent~Extent, number, module:ol/proj/Projection): string} FeatureUrlFunction
     * @api
     */


    /**
     * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.
     * @param {module:ol/format/Feature} format Feature format.
     * @param {function(this:module:ol/VectorTile, Array.<module:ol/Feature>, module:ol/proj/Projection, module:ol/extent~Extent)|function(this:module:ol/source/Vector, Array.<module:ol/Feature>)} success
     *     Function called with the loaded features and optionally with the data
     *     projection. Called with the vector tile or source as `this`.
     * @param {function(this:module:ol/VectorTile)|function(this:module:ol/source/Vector)} failure
     *     Function called when loading failed. Called with the vector tile or
     *     source as `this`.
     * @return {module:ol/featureloader~FeatureLoader} The feature loader.
     */
    function loadFeaturesXhr(url, format, success, failure) {
      return (
        /**
         * @param {module:ol/extent~Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @param {module:ol/proj/Projection} projection Projection.
         * @this {module:ol/source/Vector|module:ol/VectorTile}
         */
        function(extent, resolution, projection) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET',
            typeof url === 'function' ? url(extent, resolution, projection) : url,
            true);
          if (format.getType() == FormatType.ARRAY_BUFFER) {
            xhr.responseType = 'arraybuffer';
          }
          /**
           * @param {Event} event Event.
           * @private
           */
          xhr.onload = function(event) {
            // status will be 0 for file:// urls
            if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
              var type = format.getType();
              /** @type {Document|Node|Object|string|undefined} */
              var source;
              if (type == FormatType.JSON || type == FormatType.TEXT) {
                source = xhr.responseText;
              } else if (type == FormatType.XML) {
                source = xhr.responseXML;
                if (!source) {
                  source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                }
              } else if (type == FormatType.ARRAY_BUFFER) {
                source = /** @type {ArrayBuffer} */ (xhr.response);
              }
              if (source) {
                success.call(this, format.readFeatures(source,
                  {featureProjection: projection}),
                format.readProjection(source), format.getLastExtent());
              } else {
                failure.call(this);
              }
            } else {
              failure.call(this);
            }
          }.bind(this);
          /**
           * @private
           */
          xhr.onerror = function() {
            failure.call(this);
          }.bind(this);
          xhr.send();
        }
      );
    }


    /**
     * Create an XHR feature loader for a `url` and `format`. The feature loader
     * loads features (with XHR), parses the features, and adds them to the
     * vector source.
     * @param {string|module:ol/featureloader~FeatureUrlFunction} url Feature URL service.
     * @param {module:ol/format/Feature} format Feature format.
     * @return {module:ol/featureloader~FeatureLoader} The feature loader.
     * @api
     */
    function xhr(url, format) {
      return loadFeaturesXhr(url, format,
        /**
         * @param {Array.<module:ol/Feature>} features The loaded features.
         * @param {module:ol/proj/Projection} dataProjection Data
         * projection.
         * @this {module:ol/source/Vector}
         */
        function(features, dataProjection) {
          this.addFeatures(features);
        }, /* FIXME handle error */ UNDEFINED);
    }

    /**
     * @module ol/loadingstrategy
     */


    /**
     * Strategy function for loading all features with a single request.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array.<module:ol/extent~Extent>} Extents.
     * @api
     */
    function all(extent, resolution) {
      return [[-Infinity, -Infinity, Infinity, Infinity]];
    }

    /**
     * @module ol/source/Source
     */


    /**
     * A function that returns a string or an array of strings representing source
     * attributions.
     *
     * @typedef {function(module:ol/PluggableMap~FrameState): (string|Array.<string>)} Attribution
     */


    /**
     * A type that can be used to provide attribution information for data sources.
     *
     * It represents either
     * * a simple string (e.g. `'© Acme Inc.'`)
     * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
     * * a function that returns a string or array of strings (`{@link module:ol/source/Source~Attribution}`)
     *
     * @typedef {string|Array.<string>|module:ol/source/Source~Attribution} AttributionLike
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions]
     * @property {module:ol/proj~ProjectionLike} projection
     * @property {module:ol/source/State} [state]
     * @property {boolean} [wrapX]
     */


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for {@link module:ol/layer/Layer~Layer} sources.
     *
     * A generic `change` event is triggered when the state of the source changes.
     * @api
     */
    var Source = (function (BaseObject$$1) {
      function Source(options) {

        BaseObject$$1.call(this);

        /**
        * @private
        * @type {module:ol/proj/Projection}
        */
        this.projection_ = get$2(options.projection);

        /**
        * @private
        * @type {?module:ol/source/Source~Attribution}
        */
        this.attributions_ = this.adaptAttributions_(options.attributions);

        /**
        * @private
        * @type {module:ol/source/State}
        */
        this.state_ = options.state !== undefined ?
          options.state : SourceState.READY;

        /**
        * @private
        * @type {boolean}
        */
        this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;

      }

      if ( BaseObject$$1 ) Source.__proto__ = BaseObject$$1;
      Source.prototype = Object.create( BaseObject$$1 && BaseObject$$1.prototype );
      Source.prototype.constructor = Source;

      /**
      * Turns the attributions option into an attributions function.
      * @param {module:ol/source/Source~AttributionLike|undefined} attributionLike The attribution option.
      * @return {?module:ol/source/Source~Attribution} An attribution function (or null).
      */
      Source.prototype.adaptAttributions_ = function adaptAttributions_ (attributionLike) {
        if (!attributionLike) {
          return null;
        }
        if (Array.isArray(attributionLike)) {
          return function(frameState) {
            return attributionLike;
          };
        }

        if (typeof attributionLike === 'function') {
          return attributionLike;
        }

        return function(frameState) {
          return [attributionLike];
        };
      };

      /**
      * Get the attribution function for the source.
      * @return {?module:ol/source/Source~Attribution} Attribution function.
      */
      Source.prototype.getAttributions = function getAttributions () {
        return this.attributions_;
      };

      /**
      * Get the projection of the source.
      * @return {module:ol/proj/Projection} Projection.
      * @api
      */
      Source.prototype.getProjection = function getProjection () {
        return this.projection_;
      };

      /**
      * @abstract
      * @return {Array.<number>|undefined} Resolutions.
      */
      Source.prototype.getResolutions = function getResolutions () {};

      /**
      * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
      * @return {module:ol/source/State} State.
      * @api
      */
      Source.prototype.getState = function getState () {
        return this.state_;
      };

      /**
      * @return {boolean|undefined} Wrap X.
      */
      Source.prototype.getWrapX = function getWrapX () {
        return this.wrapX_;
      };

      /**
      * Refreshes the source and finally dispatches a 'change' event.
      * @api
      */
      Source.prototype.refresh = function refresh () {
        this.changed();
      };

      /**
      * Set the attributions of the source.
      * @param {module:ol/source/Source~AttributionLike|undefined} attributions Attributions.
      *     Can be passed as `string`, `Array<string>`, `{@link module:ol/source/Source~Attribution}`,
      *     or `undefined`.
      * @api
      */
      Source.prototype.setAttributions = function setAttributions (attributions) {
        this.attributions_ = this.adaptAttributions_(attributions);
        this.changed();
      };

      /**
      * Set the state of the source.
      * @param {module:ol/source/State} state State.
      * @protected
      */
      Source.prototype.setState = function setState (state) {
        this.state_ = state;
        this.changed();
      };

      return Source;
    }(BaseObject));

    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
     * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
     * @return {T|undefined} Callback result.
     * @template T
     */
    Source.prototype.forEachFeatureAtCoordinate = UNDEFINED;

    /**
     * @module ol/source/VectorEventType
     */

    /**
     * @enum {string}
     */
    var VectorEventType = {
      /**
       * Triggered when a feature is added to the source.
       * @event ol/source/Vector~VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: 'addfeature',

      /**
       * Triggered when a feature is updated.
       * @event ol/source/Vector~VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: 'changefeature',

      /**
       * Triggered when the clear method is called on the source.
       * @event ol/source/Vector~VectorSourceEvent#clear
       * @api
       */
      CLEAR: 'clear',

      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
       * @event ol/source/Vector~VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: 'removefeature'
    };

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var quickselect = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
    	module.exports = factory();
    }(commonjsGlobal, (function () {
    function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
    }

    function quickselectStep(arr, k, left, right, compare) {

        while (right > left) {
            if (right - left > 600) {
                var n = right - left + 1;
                var m = k - left + 1;
                var z = Math.log(n);
                var s = 0.5 * Math.exp(2 * z / 3);
                var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                quickselectStep(arr, k, newLeft, newRight, compare);
            }

            var t = arr[k];
            var i = left;
            var j = right;

            swap(arr, left, k);
            if (compare(arr[right], t) > 0) swap(arr, left, right);

            while (i < j) {
                swap(arr, i, j);
                i++;
                j--;
                while (compare(arr[i], t) < 0) i++;
                while (compare(arr[j], t) > 0) j--;
            }

            if (compare(arr[left], t) === 0) swap(arr, left, j);
            else {
                j++;
                swap(arr, j, right);
            }

            if (j <= k) left = j + 1;
            if (k <= j) right = j - 1;
        }
    }

    function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    return quickselect;

    })));
    });

    var C__Users_rendr_nextgis_nextgisweb_frontend_packages_olMapAdapter_node_modules_rbush = rbush;
    var default_1 = rbush;



    function rbush(maxEntries, format) {
        if (!(this instanceof rbush)) return new rbush(maxEntries, format);

        // max entries in a node is 9 by default; min node fill is 40% for best performance
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

        if (format) {
            this._initFormat(format);
        }

        this.clear();
    }

    rbush.prototype = {

        all: function () {
            return this._all(this.data, []);
        },

        search: function (bbox) {

            var node = this.data,
                result = [],
                toBBox = this.toBBox;

            if (!intersects$1(bbox, node)) return result;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects$1(bbox, childBBox)) {
                        if (node.leaf) result.push(child);
                        else if (contains(bbox, childBBox)) this._all(child, result);
                        else nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return result;
        },

        collides: function (bbox) {

            var node = this.data,
                toBBox = this.toBBox;

            if (!intersects$1(bbox, node)) return false;

            var nodesToSearch = [],
                i, len, child, childBBox;

            while (node) {
                for (i = 0, len = node.children.length; i < len; i++) {

                    child = node.children[i];
                    childBBox = node.leaf ? toBBox(child) : child;

                    if (intersects$1(bbox, childBBox)) {
                        if (node.leaf || contains(bbox, childBBox)) return true;
                        nodesToSearch.push(child);
                    }
                }
                node = nodesToSearch.pop();
            }

            return false;
        },

        load: function (data) {
            if (!(data && data.length)) return this;

            if (data.length < this._minEntries) {
                for (var i = 0, len = data.length; i < len; i++) {
                    this.insert(data[i]);
                }
                return this;
            }

            // recursively build the tree with the given data from scratch using OMT algorithm
            var node = this._build(data.slice(), 0, data.length - 1, 0);

            if (!this.data.children.length) {
                // save as is if tree is empty
                this.data = node;

            } else if (this.data.height === node.height) {
                // split root if trees have the same height
                this._splitRoot(this.data, node);

            } else {
                if (this.data.height < node.height) {
                    // swap trees if inserted one is bigger
                    var tmpNode = this.data;
                    this.data = node;
                    node = tmpNode;
                }

                // insert the small tree into the large tree at appropriate level
                this._insert(node, this.data.height - node.height - 1, true);
            }

            return this;
        },

        insert: function (item) {
            if (item) this._insert(item, this.data.height - 1);
            return this;
        },

        clear: function () {
            this.data = createNode([]);
            return this;
        },

        remove: function (item, equalsFn) {
            if (!item) return this;

            var node = this.data,
                bbox = this.toBBox(item),
                path = [],
                indexes = [],
                i, parent, index, goingUp;

            // depth-first iterative tree traversal
            while (node || path.length) {

                if (!node) { // go up
                    node = path.pop();
                    parent = path[path.length - 1];
                    i = indexes.pop();
                    goingUp = true;
                }

                if (node.leaf) { // check current node
                    index = findItem(item, node.children, equalsFn);

                    if (index !== -1) {
                        // item found, remove the item and condense tree upwards
                        node.children.splice(index, 1);
                        path.push(node);
                        this._condense(path);
                        return this;
                    }
                }

                if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                    path.push(node);
                    indexes.push(i);
                    i = 0;
                    parent = node;
                    node = node.children[0];

                } else if (parent) { // go right
                    i++;
                    node = parent.children[i];
                    goingUp = false;

                } else node = null; // nothing found
            }

            return this;
        },

        toBBox: function (item) { return item; },

        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,

        toJSON: function () { return this.data; },

        fromJSON: function (data) {
            this.data = data;
            return this;
        },

        _all: function (node, result) {
            var nodesToSearch = [];
            while (node) {
                if (node.leaf) result.push.apply(result, node.children);
                else nodesToSearch.push.apply(nodesToSearch, node.children);

                node = nodesToSearch.pop();
            }
            return result;
        },

        _build: function (items, left, right, height) {

            var N = right - left + 1,
                M = this._maxEntries,
                node;

            if (N <= M) {
                // reached leaf level; return leaf
                node = createNode(items.slice(left, right + 1));
                calcBBox(node, this.toBBox);
                return node;
            }

            if (!height) {
                // target height of the bulk-loaded tree
                height = Math.ceil(Math.log(N) / Math.log(M));

                // target number of root entries to maximize storage utilization
                M = Math.ceil(N / Math.pow(M, height - 1));
            }

            node = createNode([]);
            node.leaf = false;
            node.height = height;

            // split the items into M mostly square tiles

            var N2 = Math.ceil(N / M),
                N1 = N2 * Math.ceil(Math.sqrt(M)),
                i, j, right2, right3;

            multiSelect(items, left, right, N1, this.compareMinX);

            for (i = left; i <= right; i += N1) {

                right2 = Math.min(i + N1 - 1, right);

                multiSelect(items, i, right2, N2, this.compareMinY);

                for (j = i; j <= right2; j += N2) {

                    right3 = Math.min(j + N2 - 1, right2);

                    // pack each entry recursively
                    node.children.push(this._build(items, j, right3, height - 1));
                }
            }

            calcBBox(node, this.toBBox);

            return node;
        },

        _chooseSubtree: function (bbox, node, level, path) {

            var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

            while (true) {
                path.push(node);

                if (node.leaf || path.length - 1 === level) break;

                minArea = minEnlargement = Infinity;

                for (i = 0, len = node.children.length; i < len; i++) {
                    child = node.children[i];
                    area = bboxArea(child);
                    enlargement = enlargedArea(bbox, child) - area;

                    // choose entry with the least area enlargement
                    if (enlargement < minEnlargement) {
                        minEnlargement = enlargement;
                        minArea = area < minArea ? area : minArea;
                        targetNode = child;

                    } else if (enlargement === minEnlargement) {
                        // otherwise choose one with the smallest area
                        if (area < minArea) {
                            minArea = area;
                            targetNode = child;
                        }
                    }
                }

                node = targetNode || node.children[0];
            }

            return node;
        },

        _insert: function (item, level, isNode) {

            var toBBox = this.toBBox,
                bbox = isNode ? item : toBBox(item),
                insertPath = [];

            // find the best node for accommodating the item, saving all nodes along the path too
            var node = this._chooseSubtree(bbox, this.data, level, insertPath);

            // put the item into the node
            node.children.push(item);
            extend$2(node, bbox);

            // split on node overflow; propagate upwards if necessary
            while (level >= 0) {
                if (insertPath[level].children.length > this._maxEntries) {
                    this._split(insertPath, level);
                    level--;
                } else break;
            }

            // adjust bboxes along the insertion path
            this._adjustParentBBoxes(bbox, insertPath, level);
        },

        // split overflowed node into two
        _split: function (insertPath, level) {

            var node = insertPath[level],
                M = node.children.length,
                m = this._minEntries;

            this._chooseSplitAxis(node, m, M);

            var splitIndex = this._chooseSplitIndex(node, m, M);

            var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
            newNode.height = node.height;
            newNode.leaf = node.leaf;

            calcBBox(node, this.toBBox);
            calcBBox(newNode, this.toBBox);

            if (level) insertPath[level - 1].children.push(newNode);
            else this._splitRoot(node, newNode);
        },

        _splitRoot: function (node, newNode) {
            // split root node
            this.data = createNode([node, newNode]);
            this.data.height = node.height + 1;
            this.data.leaf = false;
            calcBBox(this.data, this.toBBox);
        },

        _chooseSplitIndex: function (node, m, M) {

            var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

            minOverlap = minArea = Infinity;

            for (i = m; i <= M - m; i++) {
                bbox1 = distBBox(node, 0, i, this.toBBox);
                bbox2 = distBBox(node, i, M, this.toBBox);

                overlap = intersectionArea(bbox1, bbox2);
                area = bboxArea(bbox1) + bboxArea(bbox2);

                // choose distribution with minimum overlap
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    index = i;

                    minArea = area < minArea ? area : minArea;

                } else if (overlap === minOverlap) {
                    // otherwise choose distribution with minimum area
                    if (area < minArea) {
                        minArea = area;
                        index = i;
                    }
                }
            }

            return index;
        },

        // sorts node children by the best axis for split
        _chooseSplitAxis: function (node, m, M) {

            var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
                compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
                xMargin = this._allDistMargin(node, m, M, compareMinX),
                yMargin = this._allDistMargin(node, m, M, compareMinY);

            // if total distributions margin value is minimal for x, sort by minX,
            // otherwise it's already sorted by minY
            if (xMargin < yMargin) node.children.sort(compareMinX);
        },

        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function (node, m, M, compare) {

            node.children.sort(compare);

            var toBBox = this.toBBox,
                leftBBox = distBBox(node, 0, m, toBBox),
                rightBBox = distBBox(node, M - m, M, toBBox),
                margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
                i, child;

            for (i = m; i < M - m; i++) {
                child = node.children[i];
                extend$2(leftBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(leftBBox);
            }

            for (i = M - m - 1; i >= m; i--) {
                child = node.children[i];
                extend$2(rightBBox, node.leaf ? toBBox(child) : child);
                margin += bboxMargin(rightBBox);
            }

            return margin;
        },

        _adjustParentBBoxes: function (bbox, path, level) {
            // adjust bboxes along the given tree path
            for (var i = level; i >= 0; i--) {
                extend$2(path[i], bbox);
            }
        },

        _condense: function (path) {
            // go through the path, removing empty nodes and updating bboxes
            for (var i = path.length - 1, siblings; i >= 0; i--) {
                if (path[i].children.length === 0) {
                    if (i > 0) {
                        siblings = path[i - 1].children;
                        siblings.splice(siblings.indexOf(path[i]), 1);

                    } else this.clear();

                } else calcBBox(path[i], this.toBBox);
            }
        },

        _initFormat: function (format) {
            // data format (minX, minY, maxX, maxY accessors)

            // uses eval-type function compilation instead of just accepting a toBBox function
            // because the algorithms are very sensitive to sorting functions performance,
            // so they should be dead simple and without inner calls

            var compareArr = ['return a', ' - b', ';'];

            this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
            this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

            this.toBBox = new Function('a',
                'return {minX: a' + format[0] +
                ', minY: a' + format[1] +
                ', maxX: a' + format[2] +
                ', maxY: a' + format[3] + '};');
        }
    };

    function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);

        for (var i = 0; i < items.length; i++) {
            if (equalsFn(item, items[i])) return i;
        }
        return -1;
    }

    // calculate node's bbox from bboxes of its children
    function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
    }

    // min bounding rectangle of node children from k to p-1
    function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            extend$2(destNode, node.leaf ? toBBox(child) : child);
        }

        return destNode;
    }

    function extend$2(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
    }

    function compareNodeMinX(a, b) { return a.minX - b.minX; }
    function compareNodeMinY(a, b) { return a.minY - b.minY; }

    function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
    function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

    function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
               (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX),
            minY = Math.max(a.minY, b.minY),
            maxX = Math.min(a.maxX, b.maxX),
            maxY = Math.min(a.maxY, b.maxY);

        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    }

    function contains(a, b) {
        return a.minX <= b.minX &&
               a.minY <= b.minY &&
               b.maxX <= a.maxX &&
               b.maxY <= a.maxY;
    }

    function intersects$1(a, b) {
        return b.minX <= a.maxX &&
               b.minY <= a.maxY &&
               b.maxX >= a.minX &&
               b.maxY >= a.minY;
    }

    function createNode(children) {
        return {
            children: children,
            height: 1,
            leaf: true,
            minX: Infinity,
            minY: Infinity,
            maxX: -Infinity,
            maxY: -Infinity
        };
    }

    // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach

    function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right],
            mid;

        while (stack.length) {
            right = stack.pop();
            left = stack.pop();

            if (right - left <= n) continue;

            mid = left + Math.ceil((right - left) / n / 2) * n;
            quickselect(arr, mid, left, right, compare);

            stack.push(left, mid, mid, right);
        }
    }
    C__Users_rendr_nextgis_nextgisweb_frontend_packages_olMapAdapter_node_modules_rbush.default = default_1;

    /**
     * @module ol/structs/RBush
     */

    /**
     * @typedef {Object} Entry
     * @property {number} minX
     * @property {number} minY
     * @property {number} maxX
     * @property {number} maxY
     * @property {Object} [value]
     */

    /**
     * @classdesc
     * Wrapper around the RBush by Vladimir Agafonkin.
     * See https://github.com/mourner/rbush.
     *
     * @template T
     */
    var RBush = function RBush(opt_maxEntries) {

      /**
       * @private
       */
      this.rbush_ = C__Users_rendr_nextgis_nextgisweb_frontend_packages_olMapAdapter_node_modules_rbush(opt_maxEntries, undefined);

      /**
       * A mapping between the objects added to this rbush wrapper
       * and the objects that are actually added to the internal rbush.
       * @private
       * @type {Object.<number, module:ol/structs/RBush~Entry>}
       */
      this.items_ = {};

    };

    /**
     * Insert a value into the RBush.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {T} value Value.
     */
    RBush.prototype.insert = function insert (extent, value) {
      /** @type {module:ol/structs/RBush~Entry} */
      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value: value
      };

      this.rbush_.insert(item);
      this.items_[getUid(value)] = item;
    };


    /**
     * Bulk-insert values into the RBush.
     * @param {Array.<module:ol/extent~Extent>} extents Extents.
     * @param {Array.<T>} values Values.
     */
    RBush.prototype.load = function load (extents, values) {
        var this$1 = this;

      var items = new Array(values.length);
      for (var i = 0, l = values.length; i < l; i++) {
        var extent = extents[i];
        var value = values[i];

        /** @type {module:ol/structs/RBush~Entry} */
        var item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value: value
        };
        items[i] = item;
        this$1.items_[getUid(value)] = item;
      }
      this.rbush_.load(items);
    };


    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    RBush.prototype.remove = function remove (value) {
      var uid = getUid(value);

      // get the object in which the value was wrapped when adding to the
      // internal rbush. then use that object to do the removal.
      var item = this.items_[uid];
      delete this.items_[uid];
      return this.rbush_.remove(item) !== null;
    };


    /**
     * Update the extent of a value in the RBush.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {T} value Value.
     */
    RBush.prototype.update = function update (extent, value) {
      var item = this.items_[getUid(value)];
      var bbox = [item.minX, item.minY, item.maxX, item.maxY];
      if (!equals$2(bbox, extent)) {
        this.remove(value);
        this.insert(extent, value);
      }
    };


    /**
     * Return all values in the RBush.
     * @return {Array.<T>} All.
     */
    RBush.prototype.getAll = function getAll () {
      var items = this.rbush_.all();
      return items.map(function(item) {
        return item.value;
      });
    };


    /**
     * Return all values in the given extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {Array.<T>} All in extent.
     */
    RBush.prototype.getInExtent = function getInExtent (extent) {
      /** @type {module:ol/structs/RBush~Entry} */
      var bbox = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3]
      };
      var items = this.rbush_.search(bbox);
      return items.map(function(item) {
        return item.value;
      });
    };


    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(this: S, T): *} callback Callback.
     * @param {S=} opt_this The object to use as `this` in `callback`.
     * @return {*} Callback return value.
     * @template S
     */
    RBush.prototype.forEach = function forEach (callback, opt_this) {
      return this.forEach_(this.getAll(), callback, opt_this);
    };


    /**
     * Calls a callback function with each value in the provided extent.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {function(this: S, T): *} callback Callback.
     * @param {S=} opt_this The object to use as `this` in `callback`.
     * @return {*} Callback return value.
     * @template S
     */
    RBush.prototype.forEachInExtent = function forEachInExtent (extent, callback, opt_this) {
      return this.forEach_(this.getInExtent(extent), callback, opt_this);
    };


    /**
     * @param {Array.<T>} values Values.
     * @param {function(this: S, T): *} callback Callback.
     * @param {S=} opt_this The object to use as `this` in `callback`.
     * @private
     * @return {*} Callback return value.
     * @template S
     */
    RBush.prototype.forEach_ = function forEach_ (values, callback, opt_this) {
      var result;
      for (var i = 0, l = values.length; i < l; i++) {
        result = callback.call(opt_this, values[i]);
        if (result) {
          return result;
        }
      }
      return result;
    };


    /**
     * @return {boolean} Is empty.
     */
    RBush.prototype.isEmpty = function isEmpty$1$$1 () {
      return isEmpty(this.items_);
    };


    /**
     * Remove all values from the RBush.
     */
    RBush.prototype.clear = function clear$$1 () {
      this.rbush_.clear();
      this.items_ = {};
    };


    /**
     * @param {module:ol/extent~Extent=} opt_extent Extent.
     * @return {module:ol/extent~Extent} Extent.
     */
    RBush.prototype.getExtent = function getExtent (opt_extent) {
      // FIXME add getExtent() to rbush
      var data = this.rbush_.data;
      return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
    };


    /**
     * @param {module:ol/structs/RBush} rbush R-Tree.
     */
    RBush.prototype.concat = function concat (rbush) {
        var this$1 = this;

      this.rbush_.load(rbush.rbush_.all());
      for (var i in rbush.items_) {
        this$1.items_[i | 0] = rbush.items_[i | 0];
      }
    };

    /**
     * @module ol/source/Vector
     */

    /**
     * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
     * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
     * is one of the standard {@link module:ol/loadingstrategy} strategies.
     *
     * @typedef {function(module:ol/extent~Extent, number): Array.<module:ol/extent~Extent>} LoadingStrategy
     * @api
     */


    /**
     * @classdesc
     * Events emitted by {@link module:ol/source/Vector} instances are instances of this
     * type.
     */
    var VectorSourceEvent = (function (Event$$1) {
      function VectorSourceEvent(type, opt_feature) {

        Event$$1.call(this, type);

        /**
         * The feature being added or removed.
         * @type {module:ol/Feature|undefined}
         * @api
         */
        this.feature = opt_feature;

      }

      if ( Event$$1 ) VectorSourceEvent.__proto__ = Event$$1;
      VectorSourceEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      VectorSourceEvent.prototype.constructor = VectorSourceEvent;

      return VectorSourceEvent;
    }(Event));


    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
     * @property {Array.<module:ol/Feature>|module:ol/Collection.<module:ol/Feature>} [features]
     * Features. If provided as {@link module:ol/Collection}, the features in the source
     * and the collection will stay in sync.
     * @property {module:ol/format/Feature} [format] The feature format used by the XHR
     * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
     * @property {module:ol/featureloader~FeatureLoader} [loader]
     * The loader function used to load features, from a remote source for example.
     * If this is not set and `url` is set, the source will create and use an XHR
     * feature loader.
     *
     * Example:
     *
     * ```js
     * import {Vector} from 'ol/source';
     * import {GeoJSON} from 'ol/format';
     * import {bbox} from 'ol/loadingstrategy';
     *
     * var vectorSource = new Vector({
     *   format: new GeoJSON(),
     *   loader: function(extent, resolution, projection) {
     *      var proj = projection.getCode();
     *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
     *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
     *          'outputFormat=application/json&srsname=' + proj + '&' +
     *          'bbox=' + extent.join(',') + ',' + proj;
     *      var xhr = new XMLHttpRequest();
     *      xhr.open('GET', url);
     *      var onError = function() {
     *        vectorSource.removeLoadedExtent(extent);
     *      }
     *      xhr.onerror = onError;
     *      xhr.onload = function() {
     *        if (xhr.status == 200) {
     *          vectorSource.addFeatures(
     *              vectorSource.getFormat().readFeatures(xhr.responseText));
     *        } else {
     *          onError();
     *        }
     *      }
     *      xhr.send();
     *    },
     *    strategy: bbox
     *  });
     * ```
     * @property {boolean} [overlaps=true] This source may have overlapping geometries.
     * Setting this to `false` (e.g. for sources with polygons that represent administrative
     * boundaries or TopoJSON sources) allows the renderer to optimise fill and
     * stroke operations.
     * @property {module:ol/source/Vector~LoadingStrategy} [strategy] The loading strategy to use.
     * By default an {@link module:ol/loadingstrategy~all}
     * strategy is used, a one-off strategy which loads all features at once.
     * @property {string|module:ol/featureloader~FeatureUrlfunction} [url]
     * Setting this option instructs the source to load features using an XHR loader
     * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
     * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
     * the given URL. Use a {@link module:ol/featureloader~FeatureUrlfunction} to generate the url with
     * other loading strategies.
     * Requires `format` to be set as well.
     * When default XHR feature loader is provided, the features will
     * be transformed from the data projection to the view projection
     * during parsing. If your remote data source does not advertise its projection
     * properly, this transformation will be incorrect. For some formats, the
     * default projection (usually EPSG:4326) can be overridden by setting the
     * dataProjection constructor option on the format.
     * Note that if a source contains non-feature data, such as a GeoJSON geometry
     * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
     * @property {boolean} [useSpatialIndex=true]
     * By default, an RTree is used as spatial index. When features are removed and
     * added frequently, and the total number of features is low, setting this to
     * `false` may improve performance.
     *
     * Note that
     * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
     * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
     * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
     * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
     * through all features.
     *
     * When set to `false`, the features will be maintained in an
     * {@link module:ol/Collection}, which can be retrieved through
     * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
     * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
     * -180° and 180° meridians to work properly, this should be set to `false`. The
     * resulting geometry coordinates will then exceed the world bounds.
     */


    /**
     * @classdesc
     * Provides a source of features for vector layers. Vector features provided
     * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
     * vector data that is optimized for rendering.
     *
     * @fires ol/source/Vector~VectorSourceEvent
     * @api
     */
    var VectorSource = (function (Source$$1) {
      function VectorSource(opt_options) {

        var options = opt_options || {};

        Source$$1.call(this, {
          attributions: options.attributions,
          projection: undefined,
          state: SourceState.READY,
          wrapX: options.wrapX !== undefined ? options.wrapX : true
        });

        /**
         * @private
         * @type {module:ol/featureloader~FeatureLoader}
         */
        this.loader_ = UNDEFINED;

        /**
         * @private
         * @type {module:ol/format/Feature|undefined}
         */
        this.format_ = options.format;

        /**
         * @private
         * @type {boolean}
         */
        this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

        /**
         * @private
         * @type {string|module:ol/featureloader~FeatureUrlFunction|undefined}
         */
        this.url_ = options.url;

        if (options.loader !== undefined) {
          this.loader_ = options.loader;
        } else if (this.url_ !== undefined) {
          assert(this.format_, 7); // `format` must be set when `url` is set
          // create a XHR feature loader for "url" and "format"
          this.loader_ = xhr(this.url_, /** @type {module:ol/format/Feature} */ (this.format_));
        }

        /**
         * @private
         * @type {module:ol/source/Vector~LoadingStrategy}
         */
        this.strategy_ = options.strategy !== undefined ? options.strategy : all;

        var useSpatialIndex =
            options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

        /**
         * @private
         * @type {module:ol/structs/RBush.<module:ol/Feature>}
         */
        this.featuresRtree_ = useSpatialIndex ? new RBush() : null;

        /**
         * @private
         * @type {module:ol/structs/RBush.<{extent: module:ol/extent~Extent}>}
         */
        this.loadedExtentsRtree_ = new RBush();

        /**
         * @private
         * @type {!Object.<string, module:ol/Feature>}
         */
        this.nullGeometryFeatures_ = {};

        /**
         * A lookup of features by id (the return from feature.getId()).
         * @private
         * @type {!Object.<string, module:ol/Feature>}
         */
        this.idIndex_ = {};

        /**
         * A lookup of features without id (keyed by getUid(feature)).
         * @private
         * @type {!Object.<string, module:ol/Feature>}
         */
        this.undefIdIndex_ = {};

        /**
         * @private
         * @type {Object.<string, Array.<module:ol/events~EventsKey>>}
         */
        this.featureChangeKeys_ = {};

        /**
         * @private
         * @type {module:ol/Collection.<module:ol/Feature>}
         */
        this.featuresCollection_ = null;

        var collection, features;
        if (options.features instanceof Collection) {
          collection = options.features;
          features = collection.getArray();
        } else if (Array.isArray(options.features)) {
          features = options.features;
        }
        if (!useSpatialIndex && collection === undefined) {
          collection = new Collection(features);
        }
        if (features !== undefined) {
          this.addFeaturesInternal(features);
        }
        if (collection !== undefined) {
          this.bindFeaturesCollection_(collection);
        }

      }

      if ( Source$$1 ) VectorSource.__proto__ = Source$$1;
      VectorSource.prototype = Object.create( Source$$1 && Source$$1.prototype );
      VectorSource.prototype.constructor = VectorSource;

      return VectorSource;
    }(Source));


    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * @param {module:ol/Feature} feature Feature to add.
     * @api
     */
    VectorSource.prototype.addFeature = function(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    };


    /**
     * Add a feature without firing a `change` event.
     * @param {module:ol/Feature} feature Feature.
     * @protected
     */
    VectorSource.prototype.addFeatureInternal = function(feature) {
      var featureKey = getUid(feature).toString();

      if (!this.addToIndex_(featureKey, feature)) {
        return;
      }

      this.setupChangeEvents_(featureKey, feature);

      var geometry = feature.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }

      this.dispatchEvent(
        new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
    };


    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {module:ol/Feature} feature The feature.
     * @private
     */
    VectorSource.prototype.setupChangeEvents_ = function(featureKey, feature) {
      this.featureChangeKeys_[featureKey] = [
        listen(feature, EventType.CHANGE,
          this.handleFeatureChange_, this),
        listen(feature, ObjectEventType.PROPERTYCHANGE,
          this.handleFeatureChange_, this)
      ];
    };


    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {module:ol/Feature} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    VectorSource.prototype.addToIndex_ = function(featureKey, feature) {
      var valid = true;
      var id = feature.getId();
      if (id !== undefined) {
        if (!(id.toString() in this.idIndex_)) {
          this.idIndex_[id.toString()] = feature;
        } else {
          valid = false;
        }
      } else {
        assert(!(featureKey in this.undefIdIndex_),
          30); // The passed `feature` was already added to the source
        this.undefIdIndex_[featureKey] = feature;
      }
      return valid;
    };


    /**
     * Add a batch of features to the source.
     * @param {Array.<module:ol/Feature>} features Features to add.
     * @api
     */
    VectorSource.prototype.addFeatures = function(features) {
      this.addFeaturesInternal(features);
      this.changed();
    };


    /**
     * Add features without firing a `change` event.
     * @param {Array.<module:ol/Feature>} features Features.
     * @protected
     */
    VectorSource.prototype.addFeaturesInternal = function(features) {
      var this$1 = this;

      var extents = [];
      var newFeatures = [];
      var geometryFeatures = [];

      for (var i = 0, length = features.length; i < length; i++) {
        var feature = features[i];
        var featureKey = getUid(feature).toString();
        if (this$1.addToIndex_(featureKey, feature)) {
          newFeatures.push(feature);
        }
      }

      for (var i$1 = 0, length$1 = newFeatures.length; i$1 < length$1; i$1++) {
        var feature$1 = newFeatures[i$1];
        var featureKey$1 = getUid(feature$1).toString();
        this$1.setupChangeEvents_(featureKey$1, feature$1);

        var geometry = feature$1.getGeometry();
        if (geometry) {
          var extent = geometry.getExtent();
          extents.push(extent);
          geometryFeatures.push(feature$1);
        } else {
          this$1.nullGeometryFeatures_[featureKey$1] = feature$1;
        }
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.load(extents, geometryFeatures);
      }

      for (var i$2 = 0, length$2 = newFeatures.length; i$2 < length$2; i$2++) {
        this$1.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i$2]));
      }
    };


    /**
     * @param {!module:ol/Collection.<module:ol/Feature>} collection Collection.
     * @private
     */
    VectorSource.prototype.bindFeaturesCollection_ = function(collection) {
      var modifyingCollection = false;
      listen(this, VectorEventType.ADDFEATURE,
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.push(evt.feature);
            modifyingCollection = false;
          }
        });
      listen(this, VectorEventType.REMOVEFEATURE,
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.remove(evt.feature);
            modifyingCollection = false;
          }
        });
      listen(collection, CollectionEventType.ADD,
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.addFeature(/** @type {module:ol/Feature} */ (evt.element));
            modifyingCollection = false;
          }
        }, this);
      listen(collection, CollectionEventType.REMOVE,
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.removeFeature(/** @type {module:ol/Feature} */ (evt.element));
            modifyingCollection = false;
          }
        }, this);
      this.featuresCollection_ = collection;
    };


    /**
     * Remove all features from the source.
     * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector~VectorSourceEvent#removefeature} events.
     * @api
     */
    VectorSource.prototype.clear = function(opt_fast) {
      var this$1 = this;

      if (opt_fast) {
        for (var featureId in this$1.featureChangeKeys_) {
          var keys = this$1.featureChangeKeys_[featureId];
          keys.forEach(unlistenByKey);
        }
        if (!this.featuresCollection_) {
          this.featureChangeKeys_ = {};
          this.idIndex_ = {};
          this.undefIdIndex_ = {};
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.forEach(this.removeFeatureInternal, this);
          for (var id in this$1.nullGeometryFeatures_) {
            this$1.removeFeatureInternal(this$1.nullGeometryFeatures_[id]);
          }
        }
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.clear();
      }

      if (this.featuresRtree_) {
        this.featuresRtree_.clear();
      }
      this.loadedExtentsRtree_.clear();
      this.nullGeometryFeatures_ = {};

      var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
      this.dispatchEvent(clearEvent);
      this.changed();
    };


    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(module:ol/Feature): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeature = function(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      } else if (this.featuresCollection_) {
        return this.featuresCollection_.forEach(callback);
      }
    };


    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {function(module:ol/Feature): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    VectorSource.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
      var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
      return this.forEachFeatureInExtent(extent, function(feature) {
        var geometry = feature.getGeometry();
        if (geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        } else {
          return undefined;
        }
      });
    };


    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {function(module:ol/Feature): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeatureInExtent = function(extent, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent, callback);
      } else if (this.featuresCollection_) {
        return this.featuresCollection_.forEach(callback);
      }
    };


    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {function(module:ol/Feature): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    VectorSource.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
      return this.forEachFeatureInExtent(extent,
        /**
         * @param {module:ol/Feature} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         * @template T
         */
        function(feature) {
          var geometry = feature.getGeometry();
          if (geometry.intersectsExtent(extent)) {
            var result = callback(feature);
            if (result) {
              return result;
            }
          }
        });
    };


    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection} as `features`.
     * @return {module:ol/Collection.<module:ol/Feature>} The collection of features.
     * @api
     */
    VectorSource.prototype.getFeaturesCollection = function() {
      return this.featuresCollection_;
    };


    /**
     * Get all features on the source in random order.
     * @return {Array.<module:ol/Feature>} Features.
     * @api
     */
    VectorSource.prototype.getFeatures = function() {
      var features;
      if (this.featuresCollection_) {
        features = this.featuresCollection_.getArray();
      } else if (this.featuresRtree_) {
        features = this.featuresRtree_.getAll();
        if (!isEmpty(this.nullGeometryFeatures_)) {
          extend(features, getValues(this.nullGeometryFeatures_));
        }
      }
      return (
        /** @type {Array.<module:ol/Feature>} */ (features)
      );
    };


    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @return {Array.<module:ol/Feature>} Features.
     * @api
     */
    VectorSource.prototype.getFeaturesAtCoordinate = function(coordinate) {
      var features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
        features.push(feature);
      });
      return features;
    };


    /**
     * Get all features in the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {module:ol/extent~Extent} extent Extent.
     * @return {Array.<module:ol/Feature>} Features.
     * @api
     */
    VectorSource.prototype.getFeaturesInExtent = function(extent) {
      return this.featuresRtree_.getInExtent(extent);
    };


    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {function(module:ol/Feature):boolean=} opt_filter Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {module:ol/Feature} Closest feature.
     * @api
     */
    VectorSource.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
      // Find the closest feature using branch and bound.  We start searching an
      // infinite extent, and find the distance from the first feature found.  This
      // becomes the closest feature.  We then compute a smaller extent which any
      // closer feature must intersect.  We continue searching with this smaller
      // extent, trying to find a closer feature.  Every time we find a closer
      // feature, we update the extent being searched so that any even closer
      // feature must intersect it.  We continue until we run out of features.
      var x = coordinate[0];
      var y = coordinate[1];
      var closestFeature = null;
      var closestPoint = [NaN, NaN];
      var minSquaredDistance = Infinity;
      var extent = [-Infinity, -Infinity, Infinity, Infinity];
      var filter = opt_filter ? opt_filter : TRUE;
      this.featuresRtree_.forEachInExtent(extent,
        /**
         * @param {module:ol/Feature} feature Feature.
         */
        function(feature) {
          if (filter(feature)) {
            var geometry = feature.getGeometry();
            var previousMinSquaredDistance = minSquaredDistance;
            minSquaredDistance = geometry.closestPointXY(
              x, y, closestPoint, minSquaredDistance);
            if (minSquaredDistance < previousMinSquaredDistance) {
              closestFeature = feature;
              // This is sneaky.  Reduce the extent that it is currently being
              // searched while the R-Tree traversal using this same extent object
              // is still in progress.  This is safe because the new extent is
              // strictly contained by the old extent.
              var minDistance = Math.sqrt(minSquaredDistance);
              extent[0] = x - minDistance;
              extent[1] = y - minDistance;
              extent[2] = x + minDistance;
              extent[3] = y + minDistance;
            }
          }
        });
      return closestFeature;
    };


    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {module:ol/extent~Extent=} opt_extent Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    VectorSource.prototype.getExtent = function(opt_extent) {
      return this.featuresRtree_.getExtent(opt_extent);
    };


    /**
     * Get a feature by its identifier (the value returned by feature.getId()).
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {module:ol/Feature} The feature (or `null` if not found).
     * @api
     */
    VectorSource.prototype.getFeatureById = function(id) {
      var feature = this.idIndex_[id.toString()];
      return feature !== undefined ? feature : null;
    };


    /**
     * Get the format associated with this source.
     *
     * @return {module:ol/format/Feature|undefined} The feature format.
     * @api
     */
    VectorSource.prototype.getFormat = function() {
      return this.format_;
    };


    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    VectorSource.prototype.getOverlaps = function() {
      return this.overlaps_;
    };


    /**
     * @override
     */
    VectorSource.prototype.getResolutions = function() {};


    /**
     * Get the url associated with this source.
     *
     * @return {string|module:ol/featureloader~FeatureUrlFunction|undefined} The url.
     * @api
     */
    VectorSource.prototype.getUrl = function() {
      return this.url_;
    };


    /**
     * @param {module:ol/events/Event} event Event.
     * @private
     */
    VectorSource.prototype.handleFeatureChange_ = function(event) {
      var feature = /** @type {module:ol/Feature} */ (event.target);
      var featureKey = getUid(feature).toString();
      var geometry = feature.getGeometry();
      if (!geometry) {
        if (!(featureKey in this.nullGeometryFeatures_)) {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      } else {
        var extent = geometry.getExtent();
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.update(extent, feature);
          }
        }
      }
      var id = feature.getId();
      if (id !== undefined) {
        var sid = id.toString();
        if (featureKey in this.undefIdIndex_) {
          delete this.undefIdIndex_[featureKey];
          this.idIndex_[sid] = feature;
        } else {
          if (this.idIndex_[sid] !== feature) {
            this.removeFromIdIndex_(feature);
            this.idIndex_[sid] = feature;
          }
        }
      } else {
        if (!(featureKey in this.undefIdIndex_)) {
          this.removeFromIdIndex_(feature);
          this.undefIdIndex_[featureKey] = feature;
        }
      }
      this.changed();
      this.dispatchEvent(new VectorSourceEvent(
        VectorEventType.CHANGEFEATURE, feature));
    };

    /**
     * Returns true if the feature is contained within the source.
     * @param {module:ol/Feature} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    VectorSource.prototype.hasFeature = function(feature) {
      var id = feature.getId();
      if (id !== undefined) {
        return id in this.idIndex_;
      } else {
        var featureKey = getUid(feature).toString();
        return featureKey in this.undefIdIndex_;
      }
    };

    /**
     * @return {boolean} Is empty.
     */
    VectorSource.prototype.isEmpty = function() {
      return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
    };


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {module:ol/proj/Projection} projection Projection.
     */
    VectorSource.prototype.loadFeatures = function(extent, resolution, projection) {
      var this$1 = this;

      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var extentsToLoad = this.strategy_(extent, resolution);
      var loop = function ( i, ii ) {
        var extentToLoad = extentsToLoad[i];
        var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
          /**
           * @param {{extent: module:ol/extent~Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(object) {
            return containsExtent(object.extent, extentToLoad);
          });
        if (!alreadyLoaded) {
          this$1.loader_.call(this$1, extentToLoad, resolution, projection);
          loadedExtentsRtree.insert(extentToLoad, {extent: extentToLoad.slice()});
        }
      };

      for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) loop( i, ii );
    };


    /**
     * Remove an extent from the list of loaded extents.
     * @param {module:ol/extent~Extent} extent Extent.
     * @api
     */
    VectorSource.prototype.removeLoadedExtent = function(extent) {
      var loadedExtentsRtree = this.loadedExtentsRtree_;
      var obj;
      loadedExtentsRtree.forEachInExtent(extent, function(object) {
        if (equals$2(object.extent, extent)) {
          obj = object;
          return true;
        }
      });
      if (obj) {
        loadedExtentsRtree.remove(obj);
      }
    };


    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {module:ol/Feature} feature Feature to remove.
     * @api
     */
    VectorSource.prototype.removeFeature = function(feature) {
      var featureKey = getUid(feature).toString();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
      }
      this.removeFeatureInternal(feature);
      this.changed();
    };


    /**
     * Remove feature without firing a `change` event.
     * @param {module:ol/Feature} feature Feature.
     * @protected
     */
    VectorSource.prototype.removeFeatureInternal = function(feature) {
      var featureKey = getUid(feature).toString();
      this.featureChangeKeys_[featureKey].forEach(unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      var id = feature.getId();
      if (id !== undefined) {
        delete this.idIndex_[id.toString()];
      } else {
        delete this.undefIdIndex_[featureKey];
      }
      this.dispatchEvent(new VectorSourceEvent(
        VectorEventType.REMOVEFEATURE, feature));
    };


    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {module:ol/Feature} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */
    VectorSource.prototype.removeFromIdIndex_ = function(feature) {
      var this$1 = this;

      var removed = false;
      for (var id in this$1.idIndex_) {
        if (this$1.idIndex_[id] === feature) {
          delete this$1.idIndex_[id];
          removed = true;
          break;
        }
      }
      return removed;
    };


    /**
     * Set the new loader of the source. The next loadFeatures call will use the
     * new loader.
     * @param {module:ol/featureloader~FeatureLoader} loader The loader to set.
     * @api
     */
    VectorSource.prototype.setLoader = function(loader) {
      this.loader_ = loader;
    };

    /**
     * @module ol/interaction/Draw
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/geom/GeometryType} type Geometry type of
     * the geometries being drawn with this instance.
     * @property {number} [clickTolerance=6] The maximum distance in pixels between
     * "down" and "up" for a "up" event to be considered a "click" event and
     * actually add a point/vertex to the geometry being drawn.  The default of `6`
     * was chosen for the draw interaction to behave correctly on mouse as well as
     * on touch devices.
     * @property {module:ol/Collection.<module:ol/Feature>} [features]
     * Destination collection for the drawn features.
     * @property {module:ol/source/Vector} [source] Destination source for
     * the drawn features.
     * @property {number} [dragVertexDelay=500] Delay in milliseconds after pointerdown
     * before the current vertex can be dragged to its exact position.
     * @property {number} [snapTolerance=12] Pixel distance for snapping to the
     * drawing finish.
     * @property {boolean} [stopClick=false] Stop click, singleclick, and
     * doubleclick events from firing during drawing.
     * @property {number} [maxPoints] The number of points that can be drawn before
     * a polygon ring or line string is finished. By default there is no
     * restriction.
     * @property {number} [minPoints] The number of points that must be drawn
     * before a polygon ring or line string can be finished. Default is `3` for
     * polygon rings and `2` for line strings.
     * @property {module:ol/events/condition~Condition} [finishCondition] A function
     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether the drawing can be finished.
     * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
     * Style for sketch features.
     * @property {module:ol/interaction/Draw~GeometryFunction} [geometryFunction]
     * Function that is called when a geometry's coordinates are updated.
     * @property {string} [geometryName] Geometry name to use for features created
     * by the draw interaction.
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default {@link module:ol/events/condition~noModifierKeys}, i.e. a click,
     * adds a vertex or deactivates freehand drawing.
     * @property {boolean} [freehand=false] Operate in freehand mode for lines,
     * polygons, and circles.  This makes the interaction always operate in freehand
     * mode and takes precedence over any `freehandCondition` option.
     * @property {module:ol/events/condition~Condition} [freehandCondition]
     * Condition that activates freehand drawing for lines and polygons. This
     * function takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
     * returns a boolean to indicate whether that event should be handled. The
     * default is {@link module:ol/events/condition~shiftKeyOnly}, meaning that the
     * Shift key activates freehand drawing.
     * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
     * overlay.
     */


    /**
     * Function that takes an array of coordinates and an optional existing geometry as
     * arguments, and returns a geometry. The optional existing geometry is the
     * geometry that is returned when the function is called without a second
     * argument.
     * @typedef {function(!Array.<module:ol/coordinate~Coordinate>, module:ol/geom/SimpleGeometry=):
     *     module:ol/geom/SimpleGeometry} GeometryFunction
     */


    /**
     * Draw mode.  This collapses multi-part geometry types with their single-part
     * cousins.
     * @enum {string}
     */
    var Mode$1 = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      CIRCLE: 'Circle'
    };


    /**
     * @enum {string}
     */
    var DrawEventType = {
      /**
       * Triggered upon feature draw start
       * @event module:ol/interaction/Draw~DrawEvent#drawstart
       * @api
       */
      DRAWSTART: 'drawstart',
      /**
       * Triggered upon feature draw end
       * @event module:ol/interaction/Draw~DrawEvent#drawend
       * @api
       */
      DRAWEND: 'drawend'
    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/Draw~Draw} instances are
     * instances of this type.
     */
    var DrawEvent = (function (Event$$1) {
      function DrawEvent(type, feature) {

        Event$$1.call(this, type);

        /**
         * The feature being drawn.
         * @type {module:ol/Feature}
         * @api
         */
        this.feature = feature;

      }

      if ( Event$$1 ) DrawEvent.__proto__ = Event$$1;
      DrawEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      DrawEvent.prototype.constructor = DrawEvent;

      return DrawEvent;
    }(Event));


    /**
     * @classdesc
     * Interaction for drawing feature geometries.
     *
     * @fires module:ol/interaction/Draw~DrawEvent
     * @api
     */
    var Draw = (function (PointerInteraction$$1) {
      function Draw(options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$7,
          handleEvent: handleEvent$5,
          handleUpEvent: handleUpEvent$7,
          stopDown: FALSE
        });

        /**
         * @type {boolean}
         * @private
         */
        this.shouldHandle_ = false;

        /**
         * @type {module:ol/pixel~Pixel}
         * @private
         */
        this.downPx_ = null;

        /**
         * @type {number|undefined}
         * @private
         */
        this.downTimeout_;

        /**
         * @type {number|undefined}
         * @private
         */
        this.lastDragTime_;

        /**
         * @type {boolean}
         * @private
         */
        this.freehand_ = false;

        /**
         * Target source for drawn features.
         * @type {module:ol/source/Vector}
         * @private
         */
        this.source_ = options.source ? options.source : null;

        /**
         * Target collection for drawn features.
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @private
         */
        this.features_ = options.features ? options.features : null;

        /**
         * Pixel distance for snapping.
         * @type {number}
         * @private
         */
        this.snapTolerance_ = options.snapTolerance ? options.snapTolerance : 12;

        /**
         * Geometry type.
         * @type {module:ol/geom/GeometryType}
         * @private
         */
        this.type_ = /** @type {module:ol/geom/GeometryType} */ (options.type);

        /**
         * Drawing mode (derived from geometry type.
         * @type {module:ol/interaction/Draw~Mode}
         * @private
         */
        this.mode_ = getMode(this.type_);

        /**
         * Stop click, singleclick, and doubleclick events from firing during drawing.
         * Default is `false`.
         * @type {boolean}
         * @private
         */
        this.stopClick_ = !!options.stopClick;

        /**
         * The number of points that must be drawn before a polygon ring or line
         * string can be finished.  The default is 3 for polygon rings and 2 for
         * line strings.
         * @type {number}
         * @private
         */
        this.minPoints_ = options.minPoints ?
          options.minPoints :
          (this.mode_ === Mode$1.POLYGON ? 3 : 2);

        /**
         * The number of points that can be drawn before a polygon ring or line string
         * is finished. The default is no restriction.
         * @type {number}
         * @private
         */
        this.maxPoints_ = options.maxPoints ? options.maxPoints : Infinity;

        /**
         * A function to decide if a potential finish coordinate is permissible
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.finishCondition_ = options.finishCondition ? options.finishCondition : TRUE;

        var geometryFunction = options.geometryFunction;
        if (!geometryFunction) {
          if (this.type_ === GeometryType.CIRCLE) {
            /**
             * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates
             *     The coordinates.
             * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.
             * @return {module:ol/geom/SimpleGeometry} A geometry.
             */
            geometryFunction = function(coordinates, opt_geometry) {
              var circle = opt_geometry ? /** @type {module:ol/geom/Circle} */ (opt_geometry) :
                new Circle([NaN, NaN]);
              var squaredLength = squaredDistance$1(
                coordinates[0], coordinates[1]);
              circle.setCenterAndRadius(coordinates[0], Math.sqrt(squaredLength));
              return circle;
            };
          } else {
            var Constructor;
            var mode = this.mode_;
            if (mode === Mode$1.POINT) {
              Constructor = Point;
            } else if (mode === Mode$1.LINE_STRING) {
              Constructor = LineString;
            } else if (mode === Mode$1.POLYGON) {
              Constructor = Polygon;
            }
            /**
             * @param {!Array.<module:ol/coordinate~Coordinate>} coordinates
             *     The coordinates.
             * @param {module:ol/geom/SimpleGeometry=} opt_geometry Optional geometry.
             * @return {module:ol/geom/SimpleGeometry} A geometry.
             */
            geometryFunction = function(coordinates, opt_geometry) {
              var geometry = opt_geometry;
              if (geometry) {
                if (mode === Mode$1.POLYGON) {
                  if (coordinates[0].length) {
                    // Add a closing coordinate to match the first
                    geometry.setCoordinates([coordinates[0].concat([coordinates[0][0]])]);
                  } else {
                    geometry.setCoordinates([]);
                  }
                } else {
                  geometry.setCoordinates(coordinates);
                }
              } else {
                geometry = new Constructor(coordinates);
              }
              return geometry;
            };
          }
        }

        /**
         * @type {module:ol/interaction/Draw~GeometryFunction}
         * @private
         */
        this.geometryFunction_ = geometryFunction;

        /**
         * @type {number}
         * @private
         */
        this.dragVertexDelay_ = options.dragVertexDelay !== undefined ? options.dragVertexDelay : 500;

        /**
         * Finish coordinate for the feature (first point for polygons, last point for
         * linestrings).
         * @type {module:ol/coordinate~Coordinate}
         * @private
         */
        this.finishCoordinate_ = null;

        /**
         * Sketch feature.
         * @type {module:ol/Feature}
         * @private
         */
        this.sketchFeature_ = null;

        /**
         * Sketch point.
         * @type {module:ol/Feature}
         * @private
         */
        this.sketchPoint_ = null;

        /**
         * Sketch coordinates. Used when drawing a line or polygon.
         * @type {module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>}
         * @private
         */
        this.sketchCoords_ = null;

        /**
         * Sketch line. Used when drawing polygon.
         * @type {module:ol/Feature}
         * @private
         */
        this.sketchLine_ = null;

        /**
         * Sketch line coordinates. Used when drawing a polygon or circle.
         * @type {Array.<module:ol/coordinate~Coordinate>}
         * @private
         */
        this.sketchLineCoords_ = null;

        /**
         * Squared tolerance for handling up events.  If the squared distance
         * between a down and up event is greater than this tolerance, up events
         * will not be handled.
         * @type {number}
         * @private
         */
        this.squaredClickTolerance_ = options.clickTolerance ?
          options.clickTolerance * options.clickTolerance : 36;

        /**
         * Draw overlay where our sketch features are drawn.
         * @type {module:ol/layer/Vector}
         * @private
         */
        this.overlay_ = new VectorLayer({
          source: new VectorSource({
            useSpatialIndex: false,
            wrapX: options.wrapX ? options.wrapX : false
          }),
          style: options.style ? options.style :
            getDefaultStyleFunction(),
          updateWhileInteracting: true
        });

        /**
         * Name of the geometry attribute for newly created features.
         * @type {string|undefined}
         * @private
         */
        this.geometryName_ = options.geometryName;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : noModifierKeys;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.freehandCondition_;
        if (options.freehand) {
          this.freehandCondition_ = always;
        } else {
          this.freehandCondition_ = options.freehandCondition ?
            options.freehandCondition : shiftKeyOnly;
        }

        listen(this,
          getChangeEventType(InteractionProperty.ACTIVE),
          this.updateState_, this);

      }

      if ( PointerInteraction$$1 ) Draw.__proto__ = PointerInteraction$$1;
      Draw.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      Draw.prototype.constructor = Draw;

      /**
       * @inheritDoc
       */
      Draw.prototype.setMap = function setMap (map) {
        PointerInteraction$$1.prototype.setMap.call(this, map);
        this.updateState_();
      };

      /**
       * Handle move events.
       * @param {module:ol/MapBrowserEvent} event A move event.
       * @return {boolean} Pass the event to other interactions.
       * @private
       */
      Draw.prototype.handlePointerMove_ = function handlePointerMove_ (event) {
        if (this.downPx_ &&
            ((!this.freehand_ && this.shouldHandle_) ||
            (this.freehand_ && !this.shouldHandle_))) {
          var downPx = this.downPx_;
          var clickPx = event.pixel;
          var dx = downPx[0] - clickPx[0];
          var dy = downPx[1] - clickPx[1];
          var squaredDistance$$1 = dx * dx + dy * dy;
          this.shouldHandle_ = this.freehand_ ?
            squaredDistance$$1 > this.squaredClickTolerance_ :
            squaredDistance$$1 <= this.squaredClickTolerance_;
          if (!this.shouldHandle_) {
            return true;
          }
        }

        if (this.finishCoordinate_) {
          this.modifyDrawing_(event);
        } else {
          this.createOrUpdateSketchPoint_(event);
        }
        return true;
      };

      /**
       * Determine if an event is within the snapping tolerance of the start coord.
       * @param {module:ol/MapBrowserEvent} event Event.
       * @return {boolean} The event is within the snapping tolerance of the start.
       * @private
       */
      Draw.prototype.atFinish_ = function atFinish_ (event) {
        var this$1 = this;

        var at = false;
        if (this.sketchFeature_) {
          var potentiallyDone = false;
          var potentiallyFinishCoordinates = [this.finishCoordinate_];
          if (this.mode_ === Mode$1.LINE_STRING) {
            potentiallyDone = this.sketchCoords_.length > this.minPoints_;
          } else if (this.mode_ === Mode$1.POLYGON) {
            potentiallyDone = this.sketchCoords_[0].length >
                this.minPoints_;
            potentiallyFinishCoordinates = [this.sketchCoords_[0][0],
              this.sketchCoords_[0][this.sketchCoords_[0].length - 2]];
          }
          if (potentiallyDone) {
            var map = event.map;
            for (var i = 0, ii = potentiallyFinishCoordinates.length; i < ii; i++) {
              var finishCoordinate = potentiallyFinishCoordinates[i];
              var finishPixel = map.getPixelFromCoordinate(finishCoordinate);
              var pixel = event.pixel;
              var dx = pixel[0] - finishPixel[0];
              var dy = pixel[1] - finishPixel[1];
              var snapTolerance = this$1.freehand_ ? 1 : this$1.snapTolerance_;
              at = Math.sqrt(dx * dx + dy * dy) <= snapTolerance;
              if (at) {
                this$1.finishCoordinate_ = finishCoordinate;
                break;
              }
            }
          }
        }
        return at;
      };

      /**
       * @param {module:ol/MapBrowserEvent} event Event.
       * @private
       */
      Draw.prototype.createOrUpdateSketchPoint_ = function createOrUpdateSketchPoint_ (event) {
        var coordinates = event.coordinate.slice();
        if (!this.sketchPoint_) {
          this.sketchPoint_ = new Feature(new Point(coordinates));
          this.updateSketchFeatures_();
        } else {
          var sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());
          sketchPointGeom.setCoordinates(coordinates);
        }
      };

      /**
       * Start the drawing.
       * @param {module:ol/MapBrowserEvent} event Event.
       * @private
       */
      Draw.prototype.startDrawing_ = function startDrawing_ (event) {
        var start = event.coordinate;
        this.finishCoordinate_ = start;
        if (this.mode_ === Mode$1.POINT) {
          this.sketchCoords_ = start.slice();
        } else if (this.mode_ === Mode$1.POLYGON) {
          this.sketchCoords_ = [[start.slice(), start.slice()]];
          this.sketchLineCoords_ = this.sketchCoords_[0];
        } else {
          this.sketchCoords_ = [start.slice(), start.slice()];
        }
        if (this.sketchLineCoords_) {
          this.sketchLine_ = new Feature(
            new LineString(this.sketchLineCoords_));
        }
        var geometry = this.geometryFunction_(this.sketchCoords_);
        this.sketchFeature_ = new Feature();
        if (this.geometryName_) {
          this.sketchFeature_.setGeometryName(this.geometryName_);
        }
        this.sketchFeature_.setGeometry(geometry);
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
      };

      /**
       * Modify the drawing.
       * @param {module:ol/MapBrowserEvent} event Event.
       * @private
       */
      Draw.prototype.modifyDrawing_ = function modifyDrawing_ (event) {
        var coordinate = event.coordinate;
        var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
        var coordinates, last;
        if (this.mode_ === Mode$1.POINT) {
          last = this.sketchCoords_;
        } else if (this.mode_ === Mode$1.POLYGON) {
          coordinates = this.sketchCoords_[0];
          last = coordinates[coordinates.length - 1];
          if (this.atFinish_(event)) {
            // snap to finish
            coordinate = this.finishCoordinate_.slice();
          }
        } else {
          coordinates = this.sketchCoords_;
          last = coordinates[coordinates.length - 1];
        }
        last[0] = coordinate[0];
        last[1] = coordinate[1];
        this.geometryFunction_(/** @type {!Array.<module:ol/coordinate~Coordinate>} */ (this.sketchCoords_), geometry);
        if (this.sketchPoint_) {
          var sketchPointGeom = /** @type {module:ol/geom/Point} */ (this.sketchPoint_.getGeometry());
          sketchPointGeom.setCoordinates(coordinate);
        }
        var sketchLineGeom;
        if (geometry instanceof Polygon &&
            this.mode_ !== Mode$1.POLYGON) {
          if (!this.sketchLine_) {
            this.sketchLine_ = new Feature();
          }
          var ring = geometry.getLinearRing(0);
          sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
          if (!sketchLineGeom) {
            sketchLineGeom = new LineString(ring.getFlatCoordinates(), ring.getLayout());
            this.sketchLine_.setGeometry(sketchLineGeom);
          } else {
            sketchLineGeom.setFlatCoordinates(
              ring.getLayout(), ring.getFlatCoordinates());
            sketchLineGeom.changed();
          }
        } else if (this.sketchLineCoords_) {
          sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
          sketchLineGeom.setCoordinates(this.sketchLineCoords_);
        }
        this.updateSketchFeatures_();
      };

      /**
       * Add a new coordinate to the drawing.
       * @param {module:ol/MapBrowserEvent} event Event.
       * @private
       */
      Draw.prototype.addToDrawing_ = function addToDrawing_ (event) {
        var coordinate = event.coordinate;
        var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
        var done;
        var coordinates;
        if (this.mode_ === Mode$1.LINE_STRING) {
          this.finishCoordinate_ = coordinate.slice();
          coordinates = this.sketchCoords_;
          if (coordinates.length >= this.maxPoints_) {
            if (this.freehand_) {
              coordinates.pop();
            } else {
              done = true;
            }
          }
          coordinates.push(coordinate.slice());
          this.geometryFunction_(coordinates, geometry);
        } else if (this.mode_ === Mode$1.POLYGON) {
          coordinates = this.sketchCoords_[0];
          if (coordinates.length >= this.maxPoints_) {
            if (this.freehand_) {
              coordinates.pop();
            } else {
              done = true;
            }
          }
          coordinates.push(coordinate.slice());
          if (done) {
            this.finishCoordinate_ = coordinates[0];
          }
          this.geometryFunction_(this.sketchCoords_, geometry);
        }
        this.updateSketchFeatures_();
        if (done) {
          this.finishDrawing();
        }
      };

      /**
       * Remove last point of the feature currently being drawn.
       * @api
       */
      Draw.prototype.removeLastPoint = function removeLastPoint () {
        if (!this.sketchFeature_) {
          return;
        }
        var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (this.sketchFeature_.getGeometry());
        var coordinates, sketchLineGeom;
        if (this.mode_ === Mode$1.LINE_STRING) {
          coordinates = this.sketchCoords_;
          coordinates.splice(-2, 1);
          this.geometryFunction_(coordinates, geometry);
          if (coordinates.length >= 2) {
            this.finishCoordinate_ = coordinates[coordinates.length - 2].slice();
          }
        } else if (this.mode_ === Mode$1.POLYGON) {
          coordinates = this.sketchCoords_[0];
          coordinates.splice(-2, 1);
          sketchLineGeom = /** @type {module:ol/geom/LineString} */ (this.sketchLine_.getGeometry());
          sketchLineGeom.setCoordinates(coordinates);
          this.geometryFunction_(this.sketchCoords_, geometry);
        }

        if (coordinates.length === 0) {
          this.finishCoordinate_ = null;
        }

        this.updateSketchFeatures_();
      };

      /**
       * Stop drawing and add the sketch feature to the target layer.
       * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
       * dispatched before inserting the feature.
       * @api
       */
      Draw.prototype.finishDrawing = function finishDrawing () {
        var sketchFeature = this.abortDrawing_();
        if (!sketchFeature) {
          return;
        }
        var coordinates = this.sketchCoords_;
        var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (sketchFeature.getGeometry());
        if (this.mode_ === Mode$1.LINE_STRING) {
          // remove the redundant last point
          coordinates.pop();
          this.geometryFunction_(coordinates, geometry);
        } else if (this.mode_ === Mode$1.POLYGON) {
          // remove the redundant last point in ring
          coordinates[0].pop();
          this.geometryFunction_(coordinates, geometry);
          coordinates = geometry.getCoordinates();
        }

        // cast multi-part geometries
        if (this.type_ === GeometryType.MULTI_POINT) {
          sketchFeature.setGeometry(new MultiPoint([coordinates]));
        } else if (this.type_ === GeometryType.MULTI_LINE_STRING) {
          sketchFeature.setGeometry(new MultiLineString([coordinates]));
        } else if (this.type_ === GeometryType.MULTI_POLYGON) {
          sketchFeature.setGeometry(new MultiPolygon([coordinates]));
        }

        // First dispatch event to allow full set up of feature
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND, sketchFeature));

        // Then insert feature
        if (this.features_) {
          this.features_.push(sketchFeature);
        }
        if (this.source_) {
          this.source_.addFeature(sketchFeature);
        }
      };

      /**
       * Stop drawing without adding the sketch feature to the target layer.
       * @return {module:ol/Feature} The sketch feature (or null if none).
       * @private
       */
      Draw.prototype.abortDrawing_ = function abortDrawing_ () {
        this.finishCoordinate_ = null;
        var sketchFeature = this.sketchFeature_;
        if (sketchFeature) {
          this.sketchFeature_ = null;
          this.sketchPoint_ = null;
          this.sketchLine_ = null;
          this.overlay_.getSource().clear(true);
        }
        return sketchFeature;
      };

      /**
       * Extend an existing geometry by adding additional points. This only works
       * on features with `LineString` geometries, where the interaction will
       * extend lines by adding points to the end of the coordinates array.
       * @param {!module:ol/Feature} feature Feature to be extended.
       * @api
       */
      Draw.prototype.extend = function extend (feature) {
        var geometry = feature.getGeometry();
        var lineString = /** @type {module:ol/geom/LineString} */ (geometry);
        this.sketchFeature_ = feature;
        this.sketchCoords_ = lineString.getCoordinates();
        var last = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = last.slice();
        this.sketchCoords_.push(last.slice());
        this.updateSketchFeatures_();
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART, this.sketchFeature_));
      };

      /**
       * Redraw the sketch features.
       * @private
       */
      Draw.prototype.updateSketchFeatures_ = function updateSketchFeatures_ () {
        var sketchFeatures = [];
        if (this.sketchFeature_) {
          sketchFeatures.push(this.sketchFeature_);
        }
        if (this.sketchLine_) {
          sketchFeatures.push(this.sketchLine_);
        }
        if (this.sketchPoint_) {
          sketchFeatures.push(this.sketchPoint_);
        }
        var overlaySource = this.overlay_.getSource();
        overlaySource.clear(true);
        overlaySource.addFeatures(sketchFeatures);
      };

      /**
       * @private
       */
      Draw.prototype.updateState_ = function updateState_ () {
        var map = this.getMap();
        var active = this.getActive();
        if (!map || !active) {
          this.abortDrawing_();
        }
        this.overlay_.setMap(active ? map : null);
      };

      return Draw;
    }(PointerInteraction));


    /**
     * @return {module:ol/style/Style~StyleFunction} Styles.
     */
    function getDefaultStyleFunction() {
      var styles = createEditingStyle();
      return function(feature, resolution) {
        return styles[feature.getGeometry().getType()];
      };
    }


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may actually
     * draw or finish the drawing.
     * @param {module:ol/MapBrowserEvent} event Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/Draw}
     * @api
     */
    function handleEvent$5(event) {
      if (event.originalEvent.type === EventType.CONTEXTMENU) {
        // Avoid context menu for long taps when drawing on mobile
        event.preventDefault();
      }
      this.freehand_ = this.mode_ !== Mode$1.POINT && this.freehandCondition_(event);
      var move = event.type === MapBrowserEventType.POINTERMOVE;
      var pass = true;
      if (this.lastDragTime_ && event.type === MapBrowserEventType.POINTERDRAG) {
        var now = Date.now();
        if (now - this.lastDragTime_ >= this.dragVertexDelay_) {
          this.downPx_ = event.pixel;
          this.shouldHandle_ = !this.freehand_;
          move = true;
        } else {
          this.lastDragTime_ = undefined;
        }
        if (this.shouldHandle_ && this.downTimeout_) {
          clearTimeout(this.downTimeout_);
          this.downTimeout_ = undefined;
        }
      }
      if (this.freehand_ &&
          event.type === MapBrowserEventType.POINTERDRAG &&
          this.sketchFeature_ !== null) {
        this.addToDrawing_(event);
        pass = false;
      } else if (this.freehand_ &&
          event.type === MapBrowserEventType.POINTERDOWN) {
        pass = false;
      } else if (move) {
        pass = event.type === MapBrowserEventType.POINTERMOVE;
        if (pass && this.freehand_) {
          pass = this.handlePointerMove_(event);
        } else if (event.pointerEvent.pointerType == POINTER_TYPE ||
            (event.type === MapBrowserEventType.POINTERDRAG && !this.downTimeout_)) {
          this.handlePointerMove_(event);
        }
      } else if (event.type === MapBrowserEventType.DBLCLICK) {
        pass = false;
      }

      return handleEvent$1.call(this, event) && pass;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} event Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/Draw}
     */
    function handleDownEvent$7(event) {
      this.shouldHandle_ = !this.freehand_;

      if (this.freehand_) {
        this.downPx_ = event.pixel;
        if (!this.finishCoordinate_) {
          this.startDrawing_(event);
        }
        return true;
      } else if (this.condition_(event)) {
        this.lastDragTime_ = Date.now();
        this.downTimeout_ = setTimeout(function() {
          this.handlePointerMove_(new MapBrowserPointerEvent(
            MapBrowserEventType.POINTERMOVE, event.map, event.pointerEvent, event.frameState));
        }.bind(this), this.dragVertexDelay_);
        this.downPx_ = event.pixel;
        return true;
      } else {
        return false;
      }
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} event Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/Draw}
     */
    function handleUpEvent$7(event) {
      var pass = true;

      if (this.downTimeout_) {
        clearTimeout(this.downTimeout_);
        this.downTimeout_ = undefined;
      }

      this.handlePointerMove_(event);

      var circleMode = this.mode_ === Mode$1.CIRCLE;

      if (this.shouldHandle_) {
        if (!this.finishCoordinate_) {
          this.startDrawing_(event);
          if (this.mode_ === Mode$1.POINT) {
            this.finishDrawing();
          }
        } else if (this.freehand_ || circleMode) {
          this.finishDrawing();
        } else if (this.atFinish_(event)) {
          if (this.finishCondition_(event)) {
            this.finishDrawing();
          }
        } else {
          this.addToDrawing_(event);
        }
        pass = false;
      } else if (this.freehand_) {
        this.finishCoordinate_ = null;
        this.abortDrawing_();
      }
      if (!pass && this.stopClick_) {
        event.stopPropagation();
      }
      return pass;
    }


    /**
     * Get the drawing mode.  The mode for mult-part geometries is the same as for
     * their single-part cousins.
     * @param {module:ol/geom/GeometryType} type Geometry type.
     * @return {module:ol/interaction/Draw~Mode} Drawing mode.
     */
    function getMode(type) {
      var mode;
      if (type === GeometryType.POINT ||
          type === GeometryType.MULTI_POINT) {
        mode = Mode$1.POINT;
      } else if (type === GeometryType.LINE_STRING ||
          type === GeometryType.MULTI_LINE_STRING) {
        mode = Mode$1.LINE_STRING;
      } else if (type === GeometryType.POLYGON ||
          type === GeometryType.MULTI_POLYGON) {
        mode = Mode$1.POLYGON;
      } else if (type === GeometryType.CIRCLE) {
        mode = Mode$1.CIRCLE;
      }
      return (
        /** @type {!module:ol/interaction/Draw~Mode} */ (mode)
      );
    }

    /**
     * @module ol/interaction/Extent
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/extent~Extent} [extent] Initial extent. Defaults to no
     * initial extent.
     * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [boxStyle]
     * Style for the drawn extent box. Defaults to
     * {@link module:ol/style/Style~createEditing()['Polygon']}
     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
     * pointer close enough to a segment or vertex for editing.
     * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [pointerStyle]
     * Style for the cursor used to draw the extent. Defaults to
     * {@link module:ol/style/Style~createEditing()['Point']}
     * @property {boolean} [wrapX=false] Wrap the drawn extent across multiple maps
     * in the X direction? Only affects visuals, not functionality.
     */


    /**
     * @enum {string}
     */
    var ExtentEventType = {
      /**
       * Triggered after the extent is changed
       * @event module:ol/interaction/Extent~ExtentEventType#extentchanged
       * @api
       */
      EXTENTCHANGED: 'extentchanged'
    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/Extent~Extent} instances are
     * instances of this type.
     */
    var ExtentInteractionEvent = (function (Event$$1) {
      function ExtentInteractionEvent(extent) {
        Event$$1.call(this, ExtentEventType.EXTENTCHANGED);

        /**
         * The current extent.
         * @type {module:ol/extent~Extent}
         * @api
         */
        this.extent = extent;
      }

      if ( Event$$1 ) ExtentInteractionEvent.__proto__ = Event$$1;
      ExtentInteractionEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      ExtentInteractionEvent.prototype.constructor = ExtentInteractionEvent;

      return ExtentInteractionEvent;
    }(Event));


    /**
     * @classdesc
     * Allows the user to draw a vector box by clicking and dragging on the map.
     * Once drawn, the vector box can be modified by dragging its vertices or edges.
     * This interaction is only supported for mouse devices.
     *
     * @fires module:ol/interaction/Extent~Event
     * @api
     */
    var ExtentInteraction = (function (PointerInteraction$$1) {
      function ExtentInteraction(opt_options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$8,
          handleDragEvent: handleDragEvent$7,
          handleEvent: handleEvent$6,
          handleUpEvent: handleUpEvent$8
        });

        var options = opt_options || {};

        /**
         * Extent of the drawn box
         * @type {module:ol/extent~Extent}
         * @private
         */
        this.extent_ = null;

        /**
         * Handler for pointer move events
         * @type {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null}
         * @private
         */
        this.pointerHandler_ = null;

        /**
         * Pixel threshold to snap to extent
         * @type {number}
         * @private
         */
        this.pixelTolerance_ = options.pixelTolerance !== undefined ?
          options.pixelTolerance : 10;

        /**
         * Is the pointer snapped to an extent vertex
         * @type {boolean}
         * @private
         */
        this.snappedToVertex_ = false;

        /**
         * Feature for displaying the visible extent
         * @type {module:ol/Feature}
         * @private
         */
        this.extentFeature_ = null;

        /**
         * Feature for displaying the visible pointer
         * @type {module:ol/Feature}
         * @private
         */
        this.vertexFeature_ = null;

        if (!opt_options) {
          opt_options = {};
        }

        /**
         * Layer for the extentFeature
         * @type {module:ol/layer/Vector}
         * @private
         */
        this.extentOverlay_ = new VectorLayer({
          source: new VectorSource({
            useSpatialIndex: false,
            wrapX: !!opt_options.wrapX
          }),
          style: opt_options.boxStyle ? opt_options.boxStyle : getDefaultExtentStyleFunction(),
          updateWhileAnimating: true,
          updateWhileInteracting: true
        });

        /**
         * Layer for the vertexFeature
         * @type {module:ol/layer/Vector}
         * @private
         */
        this.vertexOverlay_ = new VectorLayer({
          source: new VectorSource({
            useSpatialIndex: false,
            wrapX: !!opt_options.wrapX
          }),
          style: opt_options.pointerStyle ? opt_options.pointerStyle : getDefaultPointerStyleFunction(),
          updateWhileAnimating: true,
          updateWhileInteracting: true
        });

        if (opt_options.extent) {
          this.setExtent(opt_options.extent);
        }
      }

      if ( PointerInteraction$$1 ) ExtentInteraction.__proto__ = PointerInteraction$$1;
      ExtentInteraction.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      ExtentInteraction.prototype.constructor = ExtentInteraction;

      /**
       * @param {module:ol/pixel~Pixel} pixel cursor location
       * @param {module:ol/PluggableMap} map map
       * @returns {module:ol/coordinate~Coordinate|null} snapped vertex on extent
       * @private
       */
      ExtentInteraction.prototype.snapToVertex_ = function snapToVertex_ (pixel, map) {
        var pixelCoordinate = map.getCoordinateFromPixel(pixel);
        var sortByDistance = function(a, b) {
          return squaredDistanceToSegment(pixelCoordinate, a) -
              squaredDistanceToSegment(pixelCoordinate, b);
        };
        var extent = this.getExtent();
        if (extent) {
          //convert extents to line segments and find the segment closest to pixelCoordinate
          var segments = getSegments(extent);
          segments.sort(sortByDistance);
          var closestSegment = segments[0];

          var vertex = (closestOnSegment(pixelCoordinate,
            closestSegment));
          var vertexPixel = map.getPixelFromCoordinate(vertex);

          //if the distance is within tolerance, snap to the segment
          if (distance(pixel, vertexPixel) <= this.pixelTolerance_) {
            //test if we should further snap to a vertex
            var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
            var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
            var dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            this.snappedToVertex_ = dist <= this.pixelTolerance_;
            if (this.snappedToVertex_) {
              vertex = squaredDist1 > squaredDist2 ?
                closestSegment[1] : closestSegment[0];
            }
            return vertex;
          }
        }
        return null;
      };

      /**
       * @param {module:ol/MapBrowserEvent} mapBrowserEvent pointer move event
       * @private
       */
      ExtentInteraction.prototype.handlePointerMove_ = function handlePointerMove_ (mapBrowserEvent) {
        var pixel = mapBrowserEvent.pixel;
        var map = mapBrowserEvent.map;

        var vertex = this.snapToVertex_(pixel, map);
        if (!vertex) {
          vertex = map.getCoordinateFromPixel(pixel);
        }
        this.createOrUpdatePointerFeature_(vertex);
      };

      /**
       * @param {module:ol/extent~Extent} extent extent
       * @returns {module:ol/Feature} extent as featrue
       * @private
       */
      ExtentInteraction.prototype.createOrUpdateExtentFeature_ = function createOrUpdateExtentFeature_ (extent) {
        var extentFeature = this.extentFeature_;

        if (!extentFeature) {
          if (!extent) {
            extentFeature = new Feature({});
          } else {
            extentFeature = new Feature(fromExtent(extent));
          }
          this.extentFeature_ = extentFeature;
          this.extentOverlay_.getSource().addFeature(extentFeature);
        } else {
          if (!extent) {
            extentFeature.setGeometry(undefined);
          } else {
            extentFeature.setGeometry(fromExtent(extent));
          }
        }
        return extentFeature;
      };

      /**
       * @param {module:ol/coordinate~Coordinate} vertex location of feature
       * @returns {module:ol/Feature} vertex as feature
       * @private
       */
      ExtentInteraction.prototype.createOrUpdatePointerFeature_ = function createOrUpdatePointerFeature_ (vertex) {
        var vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
          vertexFeature = new Feature(new Point(vertex));
          this.vertexFeature_ = vertexFeature;
          this.vertexOverlay_.getSource().addFeature(vertexFeature);
        } else {
          var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
          geometry.setCoordinates(vertex);
        }
        return vertexFeature;
      };

      /**
       * @inheritDoc
       */
      ExtentInteraction.prototype.setMap = function setMap (map) {
        this.extentOverlay_.setMap(map);
        this.vertexOverlay_.setMap(map);
        PointerInteraction$$1.prototype.setMap.call(this, map);
      };

      /**
       * Returns the current drawn extent in the view projection
       *
       * @return {module:ol/extent~Extent} Drawn extent in the view projection.
       * @api
       */
      ExtentInteraction.prototype.getExtent = function getExtent () {
        return this.extent_;
      };

      /**
       * Manually sets the drawn extent, using the view projection.
       *
       * @param {module:ol/extent~Extent} extent Extent
       * @api
       */
      ExtentInteraction.prototype.setExtent = function setExtent (extent) {
        //Null extent means no bbox
        this.extent_ = extent ? extent : null;
        this.createOrUpdateExtentFeature_(extent);
        this.dispatchEvent(new ExtentInteractionEvent(this.extent_));
      };

      return ExtentInteraction;
    }(PointerInteraction));

    /**
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Event.
     * @return {boolean} Propagate event?
     * @this {module:ol/interaction/Extent~Extent}
     */
    function handleEvent$6(mapBrowserEvent) {
      if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {
        return true;
      }
      //display pointer (if not dragging)
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE && !this.handlingDownUpSequence) {
        this.handlePointerMove_(mapBrowserEvent);
      }
      //call pointer to determine up/down/drag
      handleEvent$1.call(this, mapBrowserEvent);
      //return false to stop propagation
      return false;
    }

    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Event handled?
     * @this {module:ol/interaction/Extent~Extent}
     */
    function handleDownEvent$8(mapBrowserEvent) {
      var pixel = mapBrowserEvent.pixel;
      var map = mapBrowserEvent.map;

      var extent = this.getExtent();
      var vertex = this.snapToVertex_(pixel, map);

      //find the extent corner opposite the passed corner
      var getOpposingPoint = function(point) {
        var x_ = null;
        var y_ = null;
        if (point[0] == extent[0]) {
          x_ = extent[2];
        } else if (point[0] == extent[2]) {
          x_ = extent[0];
        }
        if (point[1] == extent[1]) {
          y_ = extent[3];
        } else if (point[1] == extent[3]) {
          y_ = extent[1];
        }
        if (x_ !== null && y_ !== null) {
          return [x_, y_];
        }
        return null;
      };
      if (vertex && extent) {
        var x = (vertex[0] == extent[0] || vertex[0] == extent[2]) ? vertex[0] : null;
        var y = (vertex[1] == extent[1] || vertex[1] == extent[3]) ? vertex[1] : null;

        //snap to point
        if (x !== null && y !== null) {
          this.pointerHandler_ = getPointHandler(getOpposingPoint(vertex));
        //snap to edge
        } else if (x !== null) {
          this.pointerHandler_ = getEdgeHandler(
            getOpposingPoint([x, extent[1]]),
            getOpposingPoint([x, extent[3]])
          );
        } else if (y !== null) {
          this.pointerHandler_ = getEdgeHandler(
            getOpposingPoint([extent[0], y]),
            getOpposingPoint([extent[2], y])
          );
        }
      //no snap - new bbox
      } else {
        vertex = map.getCoordinateFromPixel(pixel);
        this.setExtent([vertex[0], vertex[1], vertex[0], vertex[1]]);
        this.pointerHandler_ = getPointHandler(vertex);
      }
      return true; //event handled; start downup sequence
    }

    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Event handled?
     * @this {module:ol/interaction/Extent~Extent}
     */
    function handleDragEvent$7(mapBrowserEvent) {
      if (this.pointerHandler_) {
        var pixelCoordinate = mapBrowserEvent.coordinate;
        this.setExtent(this.pointerHandler_(pixelCoordinate));
        this.createOrUpdatePointerFeature_(pixelCoordinate);
      }
      return true;
    }

    /**
     * @param {module:ol/MapBrowserPointerEvent} mapBrowserEvent Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/Extent~Extent}
     */
    function handleUpEvent$8(mapBrowserEvent) {
      this.pointerHandler_ = null;
      //If bbox is zero area, set to null;
      var extent = this.getExtent();
      if (!extent || getArea(extent) === 0) {
        this.setExtent(null);
      }
      return false; //Stop handling downup sequence
    }

    /**
     * Returns the default style for the drawn bbox
     *
     * @return {module:ol/style/Style~StyleFunction} Default Extent style
     */
    function getDefaultExtentStyleFunction() {
      var style = createEditingStyle();
      return function(feature, resolution) {
        return style[GeometryType.POLYGON];
      };
    }

    /**
     * Returns the default style for the pointer
     *
     * @return {module:ol/style/Style~StyleFunction} Default pointer style
     */
    function getDefaultPointerStyleFunction() {
      var style = createEditingStyle();
      return function(feature, resolution) {
        return style[GeometryType.POINT];
      };
    }

    /**
     * @param {module:ol/coordinate~Coordinate} fixedPoint corner that will be unchanged in the new extent
     * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent} event handler
     */
    function getPointHandler(fixedPoint) {
      return function(point) {
        return boundingExtent([fixedPoint, point]);
      };
    }

    /**
     * @param {module:ol/coordinate~Coordinate} fixedP1 first corner that will be unchanged in the new extent
     * @param {module:ol/coordinate~Coordinate} fixedP2 second corner that will be unchanged in the new extent
     * @returns {function (module:ol/coordinate~Coordinate): module:ol/extent~Extent|null} event handler
     */
    function getEdgeHandler(fixedP1, fixedP2) {
      if (fixedP1[0] == fixedP2[0]) {
        return function(point) {
          return boundingExtent([fixedP1, [point[0], fixedP2[1]]]);
        };
      } else if (fixedP1[1] == fixedP2[1]) {
        return function(point) {
          return boundingExtent([fixedP1, [fixedP2[0], point[1]]]);
        };
      } else {
        return null;
      }
    }

    /**
     * @param {module:ol/extent~Extent} extent extent
     * @returns {Array<Array<module:ol/coordinate~Coordinate>>} extent line segments
     */
    function getSegments(extent) {
      return [
        [[extent[0], extent[1]], [extent[0], extent[3]]],
        [[extent[0], extent[3]], [extent[2], extent[3]]],
        [[extent[2], extent[3]], [extent[2], extent[1]]],
        [[extent[2], extent[1]], [extent[0], extent[1]]]
      ];
    }

    /**
     * @module ol/interaction/Modify
     */


    /**
     * The segment index assigned to a circle's center when
     * breaking up a circle into ModifySegmentDataType segments.
     * @type {number}
     */
    var CIRCLE_CENTER_INDEX = 0;

    /**
     * The segment index assigned to a circle's circumference when
     * breaking up a circle into ModifySegmentDataType segments.
     * @type {number}
     */
    var CIRCLE_CIRCUMFERENCE_INDEX = 1;


    /**
     * @enum {string}
     */
    var ModifyEventType = {
      /**
       * Triggered upon feature modification start
       * @event ModifyEvent#modifystart
       * @api
       */
      MODIFYSTART: 'modifystart',
      /**
       * Triggered upon feature modification end
       * @event ModifyEvent#modifyend
       * @api
       */
      MODIFYEND: 'modifyend'
    };


    /**
     * @typedef {Object} SegmentData
     * @property {Array.<number>} [depth]
     * @property {module:ol/Feature} feature
     * @property {module:ol/geom/SimpleGeometry} geometry
     * @property {number} index
     * @property {Array.<module:ol/extent~Extent>} segment
     * @property {Array.<module:ol/interaction/Modify~SegmentData>} [featureSegments]
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event will be considered to add or move a
     * vertex to the sketch. Default is
     * {@link module:ol/events/condition~primaryAction}.
     * @property {module:ol/events/condition~Condition} [deleteCondition] A function
     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. By default,
     * {@link module:ol/events/condition~singleClick} with
     * {@link module:ol/events/condition~altKeyOnly} results in a vertex deletion.
     * @property {module:ol/events/condition~Condition} [insertVertexCondition] A
     * function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and
     * returns a boolean to indicate whether a new vertex can be added to the sketch
     * features. Default is {@link module:ol/events/condition~always}.
     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the
     * pointer close enough to a segment or vertex for editing.
     * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
     * Style used for the features being modified. By default the default edit
     * style is used (see {@link module:ol/style}).
     * @property {module:ol/source/Vector} [source] The vector source with
     * features to modify.  If a vector source is not provided, a feature collection
     * must be provided with the features option.
     * @property {module:ol/Collection.<module:ol/Feature>} [features]
     * The features the interaction works on.  If a feature collection is not
     * provided, a vector source must be provided with the source option.
     * @property {boolean} [wrapX=false] Wrap the world horizontally on the sketch
     * overlay.
     */


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/Modify~Modify} instances are
     * instances of this type.
     */
    var ModifyEvent = (function (Event$$1) {
      function ModifyEvent(type, features, mapBrowserPointerEvent) {
        Event$$1.call(this, type);

        /**
         * The features being modified.
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @api
         */
        this.features = features;

        /**
         * Associated {@link module:ol/MapBrowserEvent}.
         * @type {module:ol/MapBrowserEvent}
         * @api
         */
        this.mapBrowserEvent = mapBrowserPointerEvent;

      }

      if ( Event$$1 ) ModifyEvent.__proto__ = Event$$1;
      ModifyEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      ModifyEvent.prototype.constructor = ModifyEvent;

      return ModifyEvent;
    }(Event));


    /**
     * @classdesc
     * Interaction for modifying feature geometries.  To modify features that have
     * been added to an existing source, construct the modify interaction with the
     * `source` option.  If you want to modify features in a collection (for example,
     * the collection used by a select interaction), construct the interaction with
     * the `features` option.  The interaction must be constructed with either a
     * `source` or `features` option.
     *
     * By default, the interaction will allow deletion of vertices when the `alt`
     * key is pressed.  To configure the interaction with a different condition
     * for deletion, use the `deleteCondition` option.
     * @fires module:ol/interaction/Modify~ModifyEvent
     * @api
     */
    var Modify = (function (PointerInteraction$$1) {
      function Modify(options) {

        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$9,
          handleDragEvent: handleDragEvent$8,
          handleEvent: handleEvent$7,
          handleUpEvent: handleUpEvent$9
        });

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : primaryAction;


        /**
         * @private
         * @param {module:ol/MapBrowserEvent} mapBrowserEvent Browser event.
         * @return {boolean} Combined condition result.
         */
        this.defaultDeleteCondition_ = function(mapBrowserEvent) {
          return altKeyOnly(mapBrowserEvent) && singleClick(mapBrowserEvent);
        };

        /**
         * @type {module:ol/events/condition~Condition}
         * @private
         */
        this.deleteCondition_ = options.deleteCondition ?
          options.deleteCondition : this.defaultDeleteCondition_;

        /**
         * @type {module:ol/events/condition~Condition}
         * @private
         */
        this.insertVertexCondition_ = options.insertVertexCondition ?
          options.insertVertexCondition : always;

        /**
         * Editing vertex.
         * @type {module:ol/Feature}
         * @private
         */
        this.vertexFeature_ = null;

        /**
         * Segments intersecting {@link this.vertexFeature_} by segment uid.
         * @type {Object.<string, boolean>}
         * @private
         */
        this.vertexSegments_ = null;

        /**
         * @type {module:ol/pixel~Pixel}
         * @private
         */
        this.lastPixel_ = [0, 0];

        /**
         * Tracks if the next `singleclick` event should be ignored to prevent
         * accidental deletion right after vertex creation.
         * @type {boolean}
         * @private
         */
        this.ignoreNextSingleClick_ = false;

        /**
         * @type {boolean}
         * @private
         */
        this.modified_ = false;

        /**
         * Segment RTree for each layer
         * @type {module:ol/structs/RBush.<module:ol/interaction/Modify~SegmentData>}
         * @private
         */
        this.rBush_ = new RBush();

        /**
         * @type {number}
         * @private
         */
        this.pixelTolerance_ = options.pixelTolerance !== undefined ?
          options.pixelTolerance : 10;

        /**
         * @type {boolean}
         * @private
         */
        this.snappedToVertex_ = false;

        /**
         * Indicate whether the interaction is currently changing a feature's
         * coordinates.
         * @type {boolean}
         * @private
         */
        this.changingFeature_ = false;

        /**
         * @type {Array}
         * @private
         */
        this.dragSegments_ = [];

        /**
         * Draw overlay where sketch features are drawn.
         * @type {module:ol/layer/Vector}
         * @private
         */
        this.overlay_ = new VectorLayer({
          source: new VectorSource({
            useSpatialIndex: false,
            wrapX: !!options.wrapX
          }),
          style: options.style ? options.style :
            getDefaultStyleFunction$1(),
          updateWhileAnimating: true,
          updateWhileInteracting: true
        });

        /**
         * @const
         * @private
         * @type {!Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}
         */
        this.SEGMENT_WRITERS_ = {
          'Point': this.writePointGeometry_,
          'LineString': this.writeLineStringGeometry_,
          'LinearRing': this.writeLineStringGeometry_,
          'Polygon': this.writePolygonGeometry_,
          'MultiPoint': this.writeMultiPointGeometry_,
          'MultiLineString': this.writeMultiLineStringGeometry_,
          'MultiPolygon': this.writeMultiPolygonGeometry_,
          'Circle': this.writeCircleGeometry_,
          'GeometryCollection': this.writeGeometryCollectionGeometry_
        };


        /**
         * @type {module:ol/source/Vector}
         * @private
         */
        this.source_ = null;

        var features;
        if (options.source) {
          this.source_ = options.source;
          features = new Collection(this.source_.getFeatures());
          listen(this.source_, VectorEventType.ADDFEATURE,
            this.handleSourceAdd_, this);
          listen(this.source_, VectorEventType.REMOVEFEATURE,
            this.handleSourceRemove_, this);
        } else {
          features = options.features;
        }
        if (!features) {
          throw new Error('The modify interaction requires features or a source');
        }

        /**
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @private
         */
        this.features_ = features;

        this.features_.forEach(this.addFeature_.bind(this));
        listen(this.features_, CollectionEventType.ADD,
          this.handleFeatureAdd_, this);
        listen(this.features_, CollectionEventType.REMOVE,
          this.handleFeatureRemove_, this);

        /**
         * @type {module:ol/MapBrowserPointerEvent}
         * @private
         */
        this.lastPointerEvent_ = null;

      }

      if ( PointerInteraction$$1 ) Modify.__proto__ = PointerInteraction$$1;
      Modify.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      Modify.prototype.constructor = Modify;

      /**
       * @param {module:ol/Feature} feature Feature.
       * @private
       */
      Modify.prototype.addFeature_ = function addFeature_ (feature) {
        var geometry = feature.getGeometry();
        if (geometry && geometry.getType() in this.SEGMENT_WRITERS_) {
          this.SEGMENT_WRITERS_[geometry.getType()].call(this, feature, geometry);
        }
        var map = this.getMap();
        if (map && map.isRendered() && this.getActive()) {
          this.handlePointerAtPixel_(this.lastPixel_, map);
        }
        listen(feature, EventType.CHANGE,
          this.handleFeatureChange_, this);
      };

      /**
       * @param {module:ol/MapBrowserPointerEvent} evt Map browser event
       * @private
       */
      Modify.prototype.willModifyFeatures_ = function willModifyFeatures_ (evt) {
        if (!this.modified_) {
          this.modified_ = true;
          this.dispatchEvent(new ModifyEvent(
            ModifyEventType.MODIFYSTART, this.features_, evt));
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       * @private
       */
      Modify.prototype.removeFeature_ = function removeFeature_ (feature) {
        this.removeFeatureSegmentData_(feature);
        // Remove the vertex feature if the collection of canditate features
        // is empty.
        if (this.vertexFeature_ && this.features_.getLength() === 0) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        unlisten(feature, EventType.CHANGE,
          this.handleFeatureChange_, this);
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       * @private
       */
      Modify.prototype.removeFeatureSegmentData_ = function removeFeatureSegmentData_ (feature) {
        var rBush = this.rBush_;
        var /** @type {Array.<module:ol/interaction/Modify~SegmentData>} */ nodesToRemove = [];
        rBush.forEach(
          /**
           * @param {module:ol/interaction/Modify~SegmentData} node RTree node.
           */
          function(node) {
            if (feature === node.feature) {
              nodesToRemove.push(node);
            }
          });
        for (var i = nodesToRemove.length - 1; i >= 0; --i) {
          rBush.remove(nodesToRemove[i]);
        }
      };

      /**
       * @inheritDoc
       */
      Modify.prototype.setActive = function setActive (active) {
        if (this.vertexFeature_ && !active) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
        PointerInteraction$$1.prototype.setActive.call(this, active);
      };

      /**
       * @inheritDoc
       */
      Modify.prototype.setMap = function setMap (map) {
        this.overlay_.setMap(map);
        PointerInteraction$$1.prototype.setMap.call(this, map);
      };

      /**
       * @param {module:ol/source/Vector~VectorSourceEvent} event Event.
       * @private
       */
      Modify.prototype.handleSourceAdd_ = function handleSourceAdd_ (event) {
        if (event.feature) {
          this.features_.push(event.feature);
        }
      };

      /**
       * @param {module:ol/source/Vector~VectorSourceEvent} event Event.
       * @private
       */
      Modify.prototype.handleSourceRemove_ = function handleSourceRemove_ (event) {
        if (event.feature) {
          this.features_.remove(event.feature);
        }
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
        this.addFeature_(/** @type {module:ol/Feature} */ (evt.element));
      };

      /**
       * @param {module:ol/events/Event} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
        if (!this.changingFeature_) {
          var feature = /** @type {module:ol/Feature} */ (evt.target);
          this.removeFeature_(feature);
          this.addFeature_(feature);
        }
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Modify.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
        var feature = /** @type {module:ol/Feature} */ (evt.element);
        this.removeFeature_(feature);
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/Point} geometry Geometry.
       * @private
       */
      Modify.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
        var coordinates = geometry.getCoordinates();
        var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          segment: [coordinates, coordinates]
        });
        this.rBush_.insert(geometry.getExtent(), segmentData);
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiPoint} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
        var this$1 = this;

        var points = geometry.getCoordinates();
        for (var i = 0, ii = points.length; i < ii; ++i) {
          var coordinates = points[i];
          var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
            feature: feature,
            geometry: geometry,
            depth: [i],
            index: i,
            segment: [coordinates, coordinates]
          });
          this$1.rBush_.insert(geometry.getExtent(), segmentData);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/LineString} geometry Geometry.
       * @private
       */
      Modify.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
        var this$1 = this;

        var coordinates = geometry.getCoordinates();
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
            feature: feature,
            geometry: geometry,
            index: i,
            segment: segment
          });
          this$1.rBush_.insert(boundingExtent(segment), segmentData);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiLineString} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
        var this$1 = this;

        var lines = geometry.getCoordinates();
        for (var j = 0, jj = lines.length; j < jj; ++j) {
          var coordinates = lines[j];
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var segment = coordinates.slice(i, i + 2);
            var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
              feature: feature,
              geometry: geometry,
              depth: [j],
              index: i,
              segment: segment
            });
            this$1.rBush_.insert(boundingExtent(segment), segmentData);
          }
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/Polygon} geometry Geometry.
       * @private
       */
      Modify.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
        var this$1 = this;

        var rings = geometry.getCoordinates();
        for (var j = 0, jj = rings.length; j < jj; ++j) {
          var coordinates = rings[j];
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var segment = coordinates.slice(i, i + 2);
            var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
              feature: feature,
              geometry: geometry,
              depth: [j],
              index: i,
              segment: segment
            });
            this$1.rBush_.insert(boundingExtent(segment), segmentData);
          }
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiPolygon} geometry Geometry.
       * @private
       */
      Modify.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
        var this$1 = this;

        var polygons = geometry.getCoordinates();
        for (var k = 0, kk = polygons.length; k < kk; ++k) {
          var rings = polygons[k];
          for (var j = 0, jj = rings.length; j < jj; ++j) {
            var coordinates = rings[j];
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
                feature: feature,
                geometry: geometry,
                depth: [j, k],
                index: i,
                segment: segment
              });
              this$1.rBush_.insert(boundingExtent(segment), segmentData);
            }
          }
        }
      };

      /**
       * We convert a circle into two segments.  The segment at index
       * {@link CIRCLE_CENTER_INDEX} is the
       * circle's center (a point).  The segment at index
       * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
       * the circumference, and is not a line segment.
       *
       * @param {module:ol/Feature} feature Feature.
       * @param {module:ol/geom/Circle} geometry Geometry.
       * @private
       */
      Modify.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
        var coordinates = geometry.getCenter();
        var centerSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          index: CIRCLE_CENTER_INDEX,
          segment: [coordinates, coordinates]
        });
        var circumferenceSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          feature: feature,
          geometry: geometry,
          index: CIRCLE_CIRCUMFERENCE_INDEX,
          segment: [coordinates, coordinates]
        });
        var featureSegments = [centerSegmentData, circumferenceSegmentData];
        centerSegmentData.featureSegments = circumferenceSegmentData.featureSegments = featureSegments;
        this.rBush_.insert(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
        this.rBush_.insert(geometry.getExtent(), circumferenceSegmentData);
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/GeometryCollection} geometry Geometry.
       * @private
       */
      Modify.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
        var this$1 = this;

        var geometries = geometry.getGeometriesArray();
        for (var i = 0; i < geometries.length; ++i) {
          this$1.SEGMENT_WRITERS_[geometries[i].getType()].call(this$1, feature, geometries[i]);
        }
      };

      /**
       * @param {module:ol/coordinate~Coordinate} coordinates Coordinates.
       * @return {module:ol/Feature} Vertex feature.
       * @private
       */
      Modify.prototype.createOrUpdateVertexFeature_ = function createOrUpdateVertexFeature_ (coordinates) {
        var vertexFeature = this.vertexFeature_;
        if (!vertexFeature) {
          vertexFeature = new Feature(new Point(coordinates));
          this.vertexFeature_ = vertexFeature;
          this.overlay_.getSource().addFeature(vertexFeature);
        } else {
          var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
          geometry.setCoordinates(coordinates);
        }
        return vertexFeature;
      };

      /**
       * @param {module:ol/MapBrowserEvent} evt Event.
       * @private
       */
      Modify.prototype.handlePointerMove_ = function handlePointerMove_ (evt) {
        this.lastPixel_ = evt.pixel;
        this.handlePointerAtPixel_(evt.pixel, evt.map);
      };

      /**
       * @param {module:ol/pixel~Pixel} pixel Pixel
       * @param {module:ol/PluggableMap} map Map.
       * @private
       */
      Modify.prototype.handlePointerAtPixel_ = function handlePointerAtPixel_ (pixel, map) {
        var pixelCoordinate = map.getCoordinateFromPixel(pixel);
        var sortByDistance = function(a, b) {
          return pointDistanceToSegmentDataSquared(pixelCoordinate, a) -
              pointDistanceToSegmentDataSquared(pixelCoordinate, b);
        };

        var box = buffer(createOrUpdateFromCoordinate(pixelCoordinate),
          map.getView().getResolution() * this.pixelTolerance_);

        var rBush = this.rBush_;
        var nodes = rBush.getInExtent(box);
        if (nodes.length > 0) {
          nodes.sort(sortByDistance);
          var node = nodes[0];
          var closestSegment = node.segment;
          var vertex = closestOnSegmentData(pixelCoordinate, node);
          var vertexPixel = map.getPixelFromCoordinate(vertex);
          var dist = distance(pixel, vertexPixel);
          if (dist <= this.pixelTolerance_) {
            var vertexSegments = {};

            if (node.geometry.getType() === GeometryType.CIRCLE &&
            node.index === CIRCLE_CIRCUMFERENCE_INDEX) {

              this.snappedToVertex_ = true;
              this.createOrUpdateVertexFeature_(vertex);
            } else {
              var pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
              var pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
              var squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
              var squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
              dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
              this.snappedToVertex_ = dist <= this.pixelTolerance_;
              if (this.snappedToVertex_) {
                vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              }
              this.createOrUpdateVertexFeature_(vertex);
              for (var i = 1, ii = nodes.length; i < ii; ++i) {
                var segment = nodes[i].segment;
                if ((equals$1(closestSegment[0], segment[0]) &&
                    equals$1(closestSegment[1], segment[1]) ||
                    (equals$1(closestSegment[0], segment[1]) &&
                    equals$1(closestSegment[1], segment[0])))) {
                  vertexSegments[getUid(segment)] = true;
                } else {
                  break;
                }
              }
            }

            vertexSegments[getUid(closestSegment)] = true;
            this.vertexSegments_ = vertexSegments;
            return;
          }
        }
        if (this.vertexFeature_) {
          this.overlay_.getSource().removeFeature(this.vertexFeature_);
          this.vertexFeature_ = null;
        }
      };

      /**
       * @param {module:ol/interaction/Modify~SegmentData} segmentData Segment data.
       * @param {module:ol/coordinate~Coordinate} vertex Vertex.
       * @private
       */
      Modify.prototype.insertVertex_ = function insertVertex_ (segmentData, vertex) {
        var segment = segmentData.segment;
        var feature = segmentData.feature;
        var geometry = segmentData.geometry;
        var depth = segmentData.depth;
        var index = /** @type {number} */ (segmentData.index);
        var coordinates;

        while (vertex.length < geometry.getStride()) {
          vertex.push(0);
        }

        switch (geometry.getType()) {
          case GeometryType.MULTI_LINE_STRING:
            coordinates = geometry.getCoordinates();
            coordinates[depth[0]].splice(index + 1, 0, vertex);
            break;
          case GeometryType.POLYGON:
            coordinates = geometry.getCoordinates();
            coordinates[depth[0]].splice(index + 1, 0, vertex);
            break;
          case GeometryType.MULTI_POLYGON:
            coordinates = geometry.getCoordinates();
            coordinates[depth[1]][depth[0]].splice(index + 1, 0, vertex);
            break;
          case GeometryType.LINE_STRING:
            coordinates = geometry.getCoordinates();
            coordinates.splice(index + 1, 0, vertex);
            break;
          default:
            return;
        }

        this.setGeometryCoordinates_(geometry, coordinates);
        var rTree = this.rBush_;
        rTree.remove(segmentData);
        this.updateSegmentIndices_(geometry, index, depth, 1);
        var newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          segment: [segment[0], vertex],
          feature: feature,
          geometry: geometry,
          depth: depth,
          index: index
        });
        rTree.insert(boundingExtent(newSegmentData.segment),
          newSegmentData);
        this.dragSegments_.push([newSegmentData, 1]);

        var newSegmentData2 = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
          segment: [vertex, segment[1]],
          feature: feature,
          geometry: geometry,
          depth: depth,
          index: index + 1
        });
        rTree.insert(boundingExtent(newSegmentData2.segment), newSegmentData2);
        this.dragSegments_.push([newSegmentData2, 0]);
        this.ignoreNextSingleClick_ = true;
      };

      /**
       * Removes the vertex currently being pointed.
       * @return {boolean} True when a vertex was removed.
       * @api
       */
      Modify.prototype.removePoint = function removePoint () {
        if (this.lastPointerEvent_ && this.lastPointerEvent_.type != MapBrowserEventType.POINTERDRAG) {
          var evt = this.lastPointerEvent_;
          this.willModifyFeatures_(evt);
          this.removeVertex_();
          this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
          this.modified_ = false;
          return true;
        }
        return false;
      };

      /**
       * Removes a vertex from all matching features.
       * @return {boolean} True when a vertex was removed.
       * @private
       */
      Modify.prototype.removeVertex_ = function removeVertex_ () {
        var this$1 = this;

        var dragSegments = this.dragSegments_;
        var segmentsByFeature = {};
        var deleted = false;
        var component, coordinates, dragSegment, geometry, i, index, left;
        var newIndex, right, segmentData, uid;
        for (i = dragSegments.length - 1; i >= 0; --i) {
          dragSegment = dragSegments[i];
          segmentData = dragSegment[0];
          uid = getUid(segmentData.feature);
          if (segmentData.depth) {
            // separate feature components
            uid += '-' + segmentData.depth.join('-');
          }
          if (!(uid in segmentsByFeature)) {
            segmentsByFeature[uid] = {};
          }
          if (dragSegment[1] === 0) {
            segmentsByFeature[uid].right = segmentData;
            segmentsByFeature[uid].index = segmentData.index;
          } else if (dragSegment[1] == 1) {
            segmentsByFeature[uid].left = segmentData;
            segmentsByFeature[uid].index = segmentData.index + 1;
          }

        }
        for (uid in segmentsByFeature) {
          right = segmentsByFeature[uid].right;
          left = segmentsByFeature[uid].left;
          index = segmentsByFeature[uid].index;
          newIndex = index - 1;
          if (left !== undefined) {
            segmentData = left;
          } else {
            segmentData = right;
          }
          if (newIndex < 0) {
            newIndex = 0;
          }
          geometry = segmentData.geometry;
          coordinates = geometry.getCoordinates();
          component = coordinates;
          deleted = false;
          switch (geometry.getType()) {
            case GeometryType.MULTI_LINE_STRING:
              if (coordinates[segmentData.depth[0]].length > 2) {
                coordinates[segmentData.depth[0]].splice(index, 1);
                deleted = true;
              }
              break;
            case GeometryType.LINE_STRING:
              if (coordinates.length > 2) {
                coordinates.splice(index, 1);
                deleted = true;
              }
              break;
            case GeometryType.MULTI_POLYGON:
              component = component[segmentData.depth[1]];
              /* falls through */
            case GeometryType.POLYGON:
              component = component[segmentData.depth[0]];
              if (component.length > 4) {
                if (index == component.length - 1) {
                  index = 0;
                }
                component.splice(index, 1);
                deleted = true;
                if (index === 0) {
                  // close the ring again
                  component.pop();
                  component.push(component[0]);
                  newIndex = component.length - 1;
                }
              }
              break;
            default:
              // pass
          }

          if (deleted) {
            this$1.setGeometryCoordinates_(geometry, coordinates);
            var segments = [];
            if (left !== undefined) {
              this$1.rBush_.remove(left);
              segments.push(left.segment[0]);
            }
            if (right !== undefined) {
              this$1.rBush_.remove(right);
              segments.push(right.segment[1]);
            }
            if (left !== undefined && right !== undefined) {
              var newSegmentData = /** @type {module:ol/interaction/Modify~SegmentData} */ ({
                depth: segmentData.depth,
                feature: segmentData.feature,
                geometry: segmentData.geometry,
                index: newIndex,
                segment: segments
              });
              this$1.rBush_.insert(boundingExtent(newSegmentData.segment),
                newSegmentData);
            }
            this$1.updateSegmentIndices_(geometry, index, segmentData.depth, -1);
            if (this$1.vertexFeature_) {
              this$1.overlay_.getSource().removeFeature(this$1.vertexFeature_);
              this$1.vertexFeature_ = null;
            }
            dragSegments.length = 0;
          }

        }
        return deleted;
      };

      /**
       * @param {module:ol/geom/SimpleGeometry} geometry Geometry.
       * @param {Array} coordinates Coordinates.
       * @private
       */
      Modify.prototype.setGeometryCoordinates_ = function setGeometryCoordinates_ (geometry, coordinates) {
        this.changingFeature_ = true;
        geometry.setCoordinates(coordinates);
        this.changingFeature_ = false;
      };

      /**
       * @param {module:ol/geom/SimpleGeometry} geometry Geometry.
       * @param {number} index Index.
       * @param {Array.<number>|undefined} depth Depth.
       * @param {number} delta Delta (1 or -1).
       * @private
       */
      Modify.prototype.updateSegmentIndices_ = function updateSegmentIndices_ (geometry, index, depth, delta) {
        this.rBush_.forEachInExtent(geometry.getExtent(), function(segmentDataMatch) {
          if (segmentDataMatch.geometry === geometry &&
              (depth === undefined || segmentDataMatch.depth === undefined ||
              equals(segmentDataMatch.depth, depth)) &&
              segmentDataMatch.index > index) {
            segmentDataMatch.index += delta;
          }
        });
      };

      return Modify;
    }(PointerInteraction));


    /**
     * @param {module:ol/interaction/Modify~SegmentData} a The first segment data.
     * @param {module:ol/interaction/Modify~SegmentData} b The second segment data.
     * @return {number} The difference in indexes.
     */
    function compareIndexes(a, b) {
      return a.index - b.index;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} evt Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/Modify}
     */
    function handleDownEvent$9(evt) {
      var this$1 = this;

      if (!this.condition_(evt)) {
        return false;
      }
      this.handlePointerAtPixel_(evt.pixel, evt.map);
      var pixelCoordinate = evt.map.getCoordinateFromPixel(evt.pixel);
      this.dragSegments_.length = 0;
      this.modified_ = false;
      var vertexFeature = this.vertexFeature_;
      if (vertexFeature) {
        var insertVertices = [];
        var geometry = /** @type {module:ol/geom/Point} */ (vertexFeature.getGeometry());
        var vertex = geometry.getCoordinates();
        var vertexExtent = boundingExtent([vertex]);
        var segmentDataMatches = this.rBush_.getInExtent(vertexExtent);
        var componentSegments = {};
        segmentDataMatches.sort(compareIndexes);
        for (var i = 0, ii = segmentDataMatches.length; i < ii; ++i) {
          var segmentDataMatch = segmentDataMatches[i];
          var segment = segmentDataMatch.segment;
          var uid = getUid(segmentDataMatch.feature);
          var depth = segmentDataMatch.depth;
          if (depth) {
            uid += '-' + depth.join('-'); // separate feature components
          }
          if (!componentSegments[uid]) {
            componentSegments[uid] = new Array(2);
          }
          if (segmentDataMatch.geometry.getType() === GeometryType.CIRCLE &&
          segmentDataMatch.index === CIRCLE_CIRCUMFERENCE_INDEX) {

            var closestVertex = closestOnSegmentData(pixelCoordinate, segmentDataMatch);
            if (equals$1(closestVertex, vertex) && !componentSegments[uid][0]) {
              this$1.dragSegments_.push([segmentDataMatch, 0]);
              componentSegments[uid][0] = segmentDataMatch;
            }
          } else if (equals$1(segment[0], vertex) &&
              !componentSegments[uid][0]) {
            this$1.dragSegments_.push([segmentDataMatch, 0]);
            componentSegments[uid][0] = segmentDataMatch;
          } else if (equals$1(segment[1], vertex) &&
              !componentSegments[uid][1]) {

            // prevent dragging closed linestrings by the connecting node
            if ((segmentDataMatch.geometry.getType() ===
                GeometryType.LINE_STRING ||
                segmentDataMatch.geometry.getType() ===
                GeometryType.MULTI_LINE_STRING) &&
                componentSegments[uid][0] &&
                componentSegments[uid][0].index === 0) {
              continue;
            }

            this$1.dragSegments_.push([segmentDataMatch, 1]);
            componentSegments[uid][1] = segmentDataMatch;
          } else if (this$1.insertVertexCondition_(evt) && getUid(segment) in this$1.vertexSegments_ &&
              (!componentSegments[uid][0] && !componentSegments[uid][1])) {
            insertVertices.push([segmentDataMatch, vertex]);
          }
        }
        if (insertVertices.length) {
          this.willModifyFeatures_(evt);
        }
        for (var j = insertVertices.length - 1; j >= 0; --j) {
          this$1.insertVertex_.apply(this$1, insertVertices[j]);
        }
      }
      return !!this.vertexFeature_;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} evt Event.
     * @this {module:ol/interaction/Modify}
     */
    function handleDragEvent$8(evt) {
      var this$1 = this;

      this.ignoreNextSingleClick_ = false;
      this.willModifyFeatures_(evt);

      var vertex = evt.coordinate;
      for (var i = 0, ii = this.dragSegments_.length; i < ii; ++i) {
        var dragSegment = this$1.dragSegments_[i];
        var segmentData = dragSegment[0];
        var depth = segmentData.depth;
        var geometry = segmentData.geometry;
        var coordinates = (void 0);
        var segment = segmentData.segment;
        var index = dragSegment[1];

        while (vertex.length < geometry.getStride()) {
          vertex.push(segment[index][vertex.length]);
        }

        switch (geometry.getType()) {
          case GeometryType.POINT:
            coordinates = vertex;
            segment[0] = segment[1] = vertex;
            break;
          case GeometryType.MULTI_POINT:
            coordinates = geometry.getCoordinates();
            coordinates[segmentData.index] = vertex;
            segment[0] = segment[1] = vertex;
            break;
          case GeometryType.LINE_STRING:
            coordinates = geometry.getCoordinates();
            coordinates[segmentData.index + index] = vertex;
            segment[index] = vertex;
            break;
          case GeometryType.MULTI_LINE_STRING:
            coordinates = geometry.getCoordinates();
            coordinates[depth[0]][segmentData.index + index] = vertex;
            segment[index] = vertex;
            break;
          case GeometryType.POLYGON:
            coordinates = geometry.getCoordinates();
            coordinates[depth[0]][segmentData.index + index] = vertex;
            segment[index] = vertex;
            break;
          case GeometryType.MULTI_POLYGON:
            coordinates = geometry.getCoordinates();
            coordinates[depth[1]][depth[0]][segmentData.index + index] = vertex;
            segment[index] = vertex;
            break;
          case GeometryType.CIRCLE:
            segment[0] = segment[1] = vertex;
            if (segmentData.index === CIRCLE_CENTER_INDEX) {
              this$1.changingFeature_ = true;
              geometry.setCenter(vertex);
              this$1.changingFeature_ = false;
            } else { // We're dragging the circle's circumference:
              this$1.changingFeature_ = true;
              geometry.setRadius(distance(geometry.getCenter(), vertex));
              this$1.changingFeature_ = false;
            }
            break;
          default:
            // pass
        }

        if (coordinates) {
          this$1.setGeometryCoordinates_(geometry, coordinates);
        }
      }
      this.createOrUpdateVertexFeature_(vertex);
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} evt Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/Modify}
     */
    function handleUpEvent$9(evt) {
      var this$1 = this;

      for (var i = this.dragSegments_.length - 1; i >= 0; --i) {
        var segmentData = this$1.dragSegments_[i][0];
        var geometry = segmentData.geometry;
        if (geometry.getType() === GeometryType.CIRCLE) {
          // Update a circle object in the R* bush:
          var coordinates = geometry.getCenter();
          var centerSegmentData = segmentData.featureSegments[0];
          var circumferenceSegmentData = segmentData.featureSegments[1];
          centerSegmentData.segment[0] = centerSegmentData.segment[1] = coordinates;
          circumferenceSegmentData.segment[0] = circumferenceSegmentData.segment[1] = coordinates;
          this$1.rBush_.update(createOrUpdateFromCoordinate(coordinates), centerSegmentData);
          this$1.rBush_.update(geometry.getExtent(), circumferenceSegmentData);
        } else {
          this$1.rBush_.update(boundingExtent(segmentData.segment), segmentData);
        }
      }
      if (this.modified_) {
        this.dispatchEvent(new ModifyEvent(ModifyEventType.MODIFYEND, this.features_, evt));
        this.modified_ = false;
      }
      return false;
    }


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may modify the
     * geometry.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/Modify}
     */
    function handleEvent$7(mapBrowserEvent) {
      if (!(mapBrowserEvent instanceof MapBrowserPointerEvent)) {
        return true;
      }
      this.lastPointerEvent_ = mapBrowserEvent;

      var handled;
      if (!mapBrowserEvent.map.getView().getInteracting() &&
          mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE &&
          !this.handlingDownUpSequence) {
        this.handlePointerMove_(mapBrowserEvent);
      }
      if (this.vertexFeature_ && this.deleteCondition_(mapBrowserEvent)) {
        if (mapBrowserEvent.type != MapBrowserEventType.SINGLECLICK || !this.ignoreNextSingleClick_) {
          handled = this.removePoint();
        } else {
          handled = true;
        }
      }

      if (mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK) {
        this.ignoreNextSingleClick_ = false;
      }

      return handleEvent$1.call(this, mapBrowserEvent) && !handled;
    }


    /**
     * Returns the distance from a point to a line segment.
     *
     * @param {module:ol/coordinate~Coordinate} pointCoordinates The coordinates of the point from
     *        which to calculate the distance.
     * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line
     *        segment we are calculating the distance to.
     * @return {number} The square of the distance between a point and a line segment.
     */
    function pointDistanceToSegmentDataSquared(pointCoordinates, segmentData) {
      var geometry = segmentData.geometry;

      if (geometry.getType() === GeometryType.CIRCLE) {
        var circleGeometry = /** @type {module:ol/geom/Circle} */ (geometry);

        if (segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
          var distanceToCenterSquared =
                squaredDistance$1(circleGeometry.getCenter(), pointCoordinates);
          var distanceToCircumference =
                Math.sqrt(distanceToCenterSquared) - circleGeometry.getRadius();
          return distanceToCircumference * distanceToCircumference;
        }
      }
      return squaredDistanceToSegment(pointCoordinates, segmentData.segment);
    }

    /**
     * Returns the point closest to a given line segment.
     *
     * @param {module:ol/coordinate~Coordinate} pointCoordinates The point to which a closest point
     *        should be found.
     * @param {module:ol/interaction/Modify~SegmentData} segmentData The object describing the line
     *        segment which should contain the closest point.
     * @return {module:ol/coordinate~Coordinate} The point closest to the specified line segment.
     */
    function closestOnSegmentData(pointCoordinates, segmentData) {
      var geometry = segmentData.geometry;

      if (geometry.getType() === GeometryType.CIRCLE &&
      segmentData.index === CIRCLE_CIRCUMFERENCE_INDEX) {
        return geometry.getClosestPoint(pointCoordinates);
      }
      return closestOnSegment(pointCoordinates, segmentData.segment);
    }


    /**
     * @return {module:ol/style/Style~StyleFunction} Styles.
     */
    function getDefaultStyleFunction$1() {
      var style = createEditingStyle();
      return function(feature, resolution) {
        return style[GeometryType.POINT];
      };
    }

    /**
     * @module ol/interaction/Select
     */


    /**
     * @enum {string}
     */
    var SelectEventType = {
      /**
       * Triggered when feature(s) has been (de)selected.
       * @event SelectEvent#select
       * @api
       */
      SELECT: 'select'
    };


    /**
     * A function that takes an {@link module:ol/Feature} or
     * {@link module:ol/render/Feature} and an
     * {@link module:ol/layer/Layer} and returns `true` if the feature may be
     * selected or `false` otherwise.
     * @typedef {function((module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer):
     *     boolean} FilterFunction
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/events/condition~Condition} [addCondition] A function
     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default, this is {@link module:ol/events/condition~never}. Use this if you
     * want to use different events for add and remove instead of `toggle`.
     * @property {module:ol/events/condition~Condition} [condition] A function that
     * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. This is the event
     * for the selected features as a whole. By default, this is
     * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
     * feature and removes any that were in the selection. Clicking outside any
     * feature removes all from the selection.
     * See `toggle`, `add`, `remove` options for adding/removing extra features to/
     * from the selection.
     * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers]
     * A list of layers from which features should be selected. Alternatively, a
     * filter function can be provided. The function will be called for each layer
     * in the map and should return `true` for layers that you want to be
     * selectable. If the option is absent, all visible layers will be considered
     * selectable.
     * @property {module:ol/style/Style|Array.<module:ol/style/Style>|module:ol/style/Style~StyleFunction} [style]
     * Style for the selected features. By default the default edit style is used
     * (see {@link module:ol/style}).
     * @property {module:ol/events/condition~Condition} [removeCondition] A function
     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled.
     * By default, this is {@link module:ol/events/condition~never}. Use this if you
     * want to use different events for add and remove instead of `toggle`.
     * @property {module:ol/events/condition~Condition} [toggleCondition] A function
     * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
     * boolean to indicate whether that event should be handled. This is in addition
     * to the `condition` event. By default,
     * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
     * well as the `condition` event, adds that feature to the current selection if
     * it is not currently selected, and removes it if it is. See `add` and `remove`
     * if you want to use different events instead of a toggle.
     * @property {boolean} [multi=false] A boolean that determines if the default
     * behaviour should select only single features or all (overlapping) features at
     * the clicked map position. The default of `false` means single select.
     * @property {module:ol/Collection.<module:ol/Feature>} [features]
     * Collection where the interaction will place selected features. Optional. If
     * not set the interaction will create a collection. In any case the collection
     * used by the interaction is returned by
     * {@link module:ol/interaction/Select~Select#getFeatures}.
     * @property {module:ol/interaction/Select~FilterFunction} [filter] A function
     * that takes an {@link module:ol/Feature} and an
     * {@link module:ol/layer/Layer} and returns `true` if the feature may be
     * selected or `false` otherwise.
     * @property {boolean} [wrapX=true] Wrap the world horizontally on the selection
     * overlay.
     * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
     * the radius around the given position will be checked for features. This only
     * works for the canvas renderer and not for WebGL.
     */


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
     * this type.
     */
    var SelectEvent = (function (Event$$1) {
      function SelectEvent(type, selected, deselected, mapBrowserEvent) {
        Event$$1.call(this, type);

        /**
         * Selected features array.
         * @type {Array.<module:ol/Feature>}
         * @api
         */
        this.selected = selected;

        /**
         * Deselected features array.
         * @type {Array.<module:ol/Feature>}
         * @api
         */
        this.deselected = deselected;

        /**
         * Associated {@link module:ol/MapBrowserEvent}.
         * @type {module:ol/MapBrowserEvent}
         * @api
         */
        this.mapBrowserEvent = mapBrowserEvent;

      }

      if ( Event$$1 ) SelectEvent.__proto__ = Event$$1;
      SelectEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      SelectEvent.prototype.constructor = SelectEvent;

      return SelectEvent;
    }(Event));


    /**
     * @classdesc
     * Interaction for selecting vector features. By default, selected features are
     * styled differently, so this interaction can be used for visual highlighting,
     * as well as selecting features for other actions, such as modification or
     * output. There are three ways of controlling which features are selected:
     * using the browser event as defined by the `condition` and optionally the
     * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
     * further feature filter using the `filter` option.
     *
     * Selected features are added to an internal unmanaged layer.
     *
     * @fires SelectEvent
     * @api
     */
    var Select = (function (Interaction$$1) {
      function Select(opt_options) {

        Interaction$$1.call(this, {
          handleEvent: handleEvent$8
        });

        var options = opt_options ? opt_options : {};

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.condition_ = options.condition ? options.condition : singleClick;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.addCondition_ = options.addCondition ? options.addCondition : never;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.removeCondition_ = options.removeCondition ? options.removeCondition : never;

        /**
         * @private
         * @type {module:ol/events/condition~Condition}
         */
        this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : shiftKeyOnly;

        /**
         * @private
         * @type {boolean}
         */
        this.multi_ = options.multi ? options.multi : false;

        /**
         * @private
         * @type {module:ol/interaction/Select~FilterFunction}
         */
        this.filter_ = options.filter ? options.filter : TRUE;

        /**
         * @private
         * @type {number}
         */
        this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

        var featureOverlay = new VectorLayer({
          source: new VectorSource({
            useSpatialIndex: false,
            features: options.features,
            wrapX: options.wrapX
          }),
          style: options.style ? options.style :
            getDefaultStyleFunction$2(),
          updateWhileAnimating: true,
          updateWhileInteracting: true
        });

        /**
         * @private
         * @type {module:ol/layer/Vector}
         */
        this.featureOverlay_ = featureOverlay;

        /** @type {function(module:ol/layer/Layer): boolean} */
        var layerFilter;
        if (options.layers) {
          if (typeof options.layers === 'function') {
            layerFilter = options.layers;
          } else {
            var layers = options.layers;
            layerFilter = function(layer) {
              return includes(layers, layer);
            };
          }
        } else {
          layerFilter = TRUE;
        }

        /**
         * @private
         * @type {function(module:ol/layer/Layer): boolean}
         */
        this.layerFilter_ = layerFilter;

        /**
         * An association between selected feature (key)
         * and layer (value)
         * @private
         * @type {Object.<number, module:ol/layer/Layer>}
         */
        this.featureLayerAssociation_ = {};

        var features = this.featureOverlay_.getSource().getFeaturesCollection();
        listen(features, CollectionEventType.ADD,
          this.addFeature_, this);
        listen(features, CollectionEventType.REMOVE,
          this.removeFeature_, this);

      }

      if ( Interaction$$1 ) Select.__proto__ = Interaction$$1;
      Select.prototype = Object.create( Interaction$$1 && Interaction$$1.prototype );
      Select.prototype.constructor = Select;

      /**
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       * @param {module:ol/layer/Layer} layer Layer.
       * @private
       */
      Select.prototype.addFeatureLayerAssociation_ = function addFeatureLayerAssociation_ (feature, layer) {
        var key = getUid(feature);
        this.featureLayerAssociation_[key] = layer;
      };

      /**
       * Get the selected features.
       * @return {module:ol/Collection.<module:ol/Feature>} Features collection.
       * @api
       */
      Select.prototype.getFeatures = function getFeatures () {
        return this.featureOverlay_.getSource().getFeaturesCollection();
      };

      /**
       * Returns the Hit-detection tolerance.
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Select.prototype.getHitTolerance = function getHitTolerance () {
        return this.hitTolerance_;
      };

      /**
       * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
       * the (last) selected feature. Note that this will not work with any
       * programmatic method like pushing features to
       * {@link module:ol/interaction/Select~Select#getFeatures collection}.
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature
       * @return {module:ol/layer/Vector} Layer.
       * @api
       */
      Select.prototype.getLayer = function getLayer (feature) {
        var key = getUid(feature);
        return (
          /** @type {module:ol/layer/Vector} */ (this.featureLayerAssociation_[key])
        );
      };

      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features. This only works for the canvas renderer and
       * not for WebGL.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Select.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
        this.hitTolerance_ = hitTolerance;
      };

      /**
       * Remove the interaction from its current map, if any,  and attach it to a new
       * map, if any. Pass `null` to just remove the interaction from the current map.
       * @param {module:ol/PluggableMap} map Map.
       * @override
       * @api
       */
      Select.prototype.setMap = function setMap (map) {
        var currentMap = this.getMap();
        var selectedFeatures =
            this.featureOverlay_.getSource().getFeaturesCollection();
        if (currentMap) {
          selectedFeatures.forEach(currentMap.unskipFeature.bind(currentMap));
        }
        Interaction$$1.prototype.setMap.call(this, map);
        this.featureOverlay_.setMap(map);
        if (map) {
          selectedFeatures.forEach(map.skipFeature.bind(map));
        }
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.addFeature_ = function addFeature_ (evt) {
        var map = this.getMap();
        if (map) {
          map.skipFeature(/** @type {module:ol/Feature} */ (evt.element));
        }
      };

      /**
       * @param {module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.removeFeature_ = function removeFeature_ (evt) {
        var map = this.getMap();
        if (map) {
          map.unskipFeature(/** @type {module:ol/Feature} */ (evt.element));
        }
      };

      /**
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       * @private
       */
      Select.prototype.removeFeatureLayerAssociation_ = function removeFeatureLayerAssociation_ (feature) {
        var key = getUid(feature);
        delete this.featureLayerAssociation_[key];
      };

      return Select;
    }(Interaction));


    /**
     * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
     * selected state of features.
     * @param {module:ol/MapBrowserEvent} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @this {module:ol/interaction/Select}
     */
    function handleEvent$8(mapBrowserEvent) {
      if (!this.condition_(mapBrowserEvent)) {
        return true;
      }
      var add = this.addCondition_(mapBrowserEvent);
      var remove$$1 = this.removeCondition_(mapBrowserEvent);
      var toggle = this.toggleCondition_(mapBrowserEvent);
      var set = !add && !remove$$1 && !toggle;
      var map = mapBrowserEvent.map;
      var features = this.featureOverlay_.getSource().getFeaturesCollection();
      var deselected = [];
      var selected = [];
      if (set) {
        // Replace the currently selected feature(s) with the feature(s) at the
        // pixel, or clear the selected feature(s) if there is no feature at
        // the pixel.
        clear(this.featureLayerAssociation_);
        map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
          (
            /**
             * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
             * @param {module:ol/layer/Layer} layer Layer.
             * @return {boolean|undefined} Continue to iterate over the features.
             */
            function(feature, layer) {
              if (this.filter_(feature, layer)) {
                selected.push(feature);
                this.addFeatureLayerAssociation_(feature, layer);
                return !this.multi_;
              }
            }).bind(this), {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
          });
        for (var i = features.getLength() - 1; i >= 0; --i) {
          var feature = features.item(i);
          var index = selected.indexOf(feature);
          if (index > -1) {
            // feature is already selected
            selected.splice(index, 1);
          } else {
            features.remove(feature);
            deselected.push(feature);
          }
        }
        if (selected.length !== 0) {
          features.extend(selected);
        }
      } else {
        // Modify the currently selected feature(s).
        map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
          (
            /**
             * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
             * @param {module:ol/layer/Layer} layer Layer.
             * @return {boolean|undefined} Continue to iterate over the features.
             */
            function(feature, layer) {
              if (this.filter_(feature, layer)) {
                if ((add || toggle) && !includes(features.getArray(), feature)) {
                  selected.push(feature);
                  this.addFeatureLayerAssociation_(feature, layer);
                } else if ((remove$$1 || toggle) && includes(features.getArray(), feature)) {
                  deselected.push(feature);
                  this.removeFeatureLayerAssociation_(feature);
                }
                return !this.multi_;
              }
            }).bind(this), {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
          });
        for (var j = deselected.length - 1; j >= 0; --j) {
          features.remove(deselected[j]);
        }
        features.extend(selected);
      }
      if (selected.length > 0 || deselected.length > 0) {
        this.dispatchEvent(
          new SelectEvent(SelectEventType.SELECT,
            selected, deselected, mapBrowserEvent));
      }
      return pointerMove$1(mapBrowserEvent);
    }


    /**
     * @return {module:ol/style/Style~StyleFunction} Styles.
     */
    function getDefaultStyleFunction$2() {
      var styles = createEditingStyle();
      extend(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);
      extend(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);

      return function(feature, resolution) {
        if (!feature.getGeometry()) {
          return null;
        }
        return styles[feature.getGeometry().getType()];
      };
    }

    /**
     * @module ol/interaction/Snap
     */


    /**
     * @typedef {Object} Result
     * @property {boolean} snapped
     * @property {module:ol/coordinate~Coordinate|null} vertex
     * @property {module:ol/pixel~Pixel|null} vertexPixel
     */


    /**
     * @typedef {Object} SegmentData
     * @property {module:ol/Feature} feature
     * @property {Array.<module:ol/coordinate~Coordinate>} segment
     */


    /**
     * @typedef {Object} Options
     * @property {module:ol/Collection.<module:ol/Feature>} [features] Snap to these features. Either this option or source should be provided.
     * @property {boolean} [edge=true] Snap to edges.
     * @property {boolean} [vertex=true] Snap to vertices.
     * @property {number} [pixelTolerance=10] Pixel tolerance for considering the pointer close enough to a segment or
     * vertex for snapping.
     * @property {module:ol/source/Vector} [source] Snap to features from this source. Either this option or features should be provided
     */


    /**
     * @classdesc
     * Handles snapping of vector features while modifying or drawing them.  The
     * features can come from a {@link module:ol/source/Vector} or {@link module:ol/Collection~Collection}
     * Any interaction object that allows the user to interact
     * with the features using the mouse can benefit from the snapping, as long
     * as it is added before.
     *
     * The snap interaction modifies map browser event `coordinate` and `pixel`
     * properties to force the snap to occur to any interaction that them.
     *
     * Example:
     *
     *     import Snap from 'ol/interaction/Snap';
     *
     *     var snap = new Snap({
     *       source: source
     *     });
     *
     * @api
     */
    var Snap = (function (PointerInteraction$$1) {
      function Snap(opt_options) {

        PointerInteraction$$1.call(this, {
          handleEvent: handleEvent$9,
          handleDownEvent: TRUE,
          handleUpEvent: handleUpEvent$a,
          stopDown: FALSE
        });

        var options = opt_options ? opt_options : {};

        /**
         * @type {module:ol/source/Vector}
         * @private
         */
        this.source_ = options.source ? options.source : null;

        /**
         * @private
         * @type {boolean}
         */
        this.vertex_ = options.vertex !== undefined ? options.vertex : true;

        /**
         * @private
         * @type {boolean}
         */
        this.edge_ = options.edge !== undefined ? options.edge : true;

        /**
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @private
         */
        this.features_ = options.features ? options.features : null;

        /**
         * @type {Array.<module:ol/events~EventsKey>}
         * @private
         */
        this.featuresListenerKeys_ = [];

        /**
         * @type {Object.<number, module:ol/events~EventsKey>}
         * @private
         */
        this.featureChangeListenerKeys_ = {};

        /**
         * Extents are preserved so indexed segment can be quickly removed
         * when its feature geometry changes
         * @type {Object.<number, module:ol/extent~Extent>}
         * @private
         */
        this.indexedFeaturesExtents_ = {};

        /**
         * If a feature geometry changes while a pointer drag|move event occurs, the
         * feature doesn't get updated right away.  It will be at the next 'pointerup'
         * event fired.
         * @type {!Object.<number, module:ol/Feature>}
         * @private
         */
        this.pendingFeatures_ = {};

        /**
         * Used for distance sorting in sortByDistance_
         * @type {module:ol/coordinate~Coordinate}
         * @private
         */
        this.pixelCoordinate_ = null;

        /**
         * @type {number}
         * @private
         */
        this.pixelTolerance_ = options.pixelTolerance !== undefined ?
          options.pixelTolerance : 10;

        /**
         * @type {function(module:ol/interaction/Snap~SegmentData, module:ol/interaction/Snap~SegmentData): number}
         * @private
         */
        this.sortByDistance_ = sortByDistance.bind(this);


        /**
        * Segment RTree for each layer
        * @type {module:ol/structs/RBush.<module:ol/interaction/Snap~SegmentData>}
        * @private
        */
        this.rBush_ = new RBush();


        /**
        * @const
        * @private
        * @type {Object.<string, function(module:ol/Feature, module:ol/geom/Geometry)>}
        */
        this.SEGMENT_WRITERS_ = {
          'Point': this.writePointGeometry_,
          'LineString': this.writeLineStringGeometry_,
          'LinearRing': this.writeLineStringGeometry_,
          'Polygon': this.writePolygonGeometry_,
          'MultiPoint': this.writeMultiPointGeometry_,
          'MultiLineString': this.writeMultiLineStringGeometry_,
          'MultiPolygon': this.writeMultiPolygonGeometry_,
          'GeometryCollection': this.writeGeometryCollectionGeometry_,
          'Circle': this.writeCircleGeometry_
        };
      }

      if ( PointerInteraction$$1 ) Snap.__proto__ = PointerInteraction$$1;
      Snap.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      Snap.prototype.constructor = Snap;

      /**
       * Add a feature to the collection of features that we may snap to.
       * @param {module:ol/Feature} feature Feature.
       * @param {boolean=} opt_listen Whether to listen to the feature change or not
       *     Defaults to `true`.
       * @api
       */
      Snap.prototype.addFeature = function addFeature (feature, opt_listen) {
        var register = opt_listen !== undefined ? opt_listen : true;
        var feature_uid = getUid(feature);
        var geometry = feature.getGeometry();
        if (geometry) {
          var segmentWriter = this.SEGMENT_WRITERS_[geometry.getType()];
          if (segmentWriter) {
            this.indexedFeaturesExtents_[feature_uid] = geometry.getExtent(createEmpty());
            segmentWriter.call(this, feature, geometry);
          }
        }

        if (register) {
          this.featureChangeListenerKeys_[feature_uid] = listen(
            feature,
            EventType.CHANGE,
            this.handleFeatureChange_, this);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       * @private
       */
      Snap.prototype.forEachFeatureAdd_ = function forEachFeatureAdd_ (feature) {
        this.addFeature(feature);
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       * @private
       */
      Snap.prototype.forEachFeatureRemove_ = function forEachFeatureRemove_ (feature) {
        this.removeFeature(feature);
      };

      /**
       * @return {module:ol/Collection.<module:ol/Feature>|Array.<module:ol/Feature>} Features.
       * @private
       */
      Snap.prototype.getFeatures_ = function getFeatures_ () {
        var features;
        if (this.features_) {
          features = this.features_;
        } else if (this.source_) {
          features = this.source_.getFeatures();
        }
        return (
          /** @type {!Array.<module:ol/Feature>|!module:ol/Collection.<module:ol/Feature>} */ (features)
        );
      };

      /**
       * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureAdd_ = function handleFeatureAdd_ (evt) {
        var feature;
        if (evt instanceof VectorSourceEvent) {
          feature = evt.feature;
        } else if (evt instanceof CollectionEvent) {
          feature = evt.element;
        }
        this.addFeature(/** @type {module:ol/Feature} */ (feature));
      };

      /**
       * @param {module:ol/source/Vector|module:ol/Collection~CollectionEvent} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureRemove_ = function handleFeatureRemove_ (evt) {
        var feature;
        if (evt instanceof VectorSourceEvent) {
          feature = evt.feature;
        } else if (evt instanceof CollectionEvent) {
          feature = evt.element;
        }
        this.removeFeature(/** @type {module:ol/Feature} */ (feature));
      };

      /**
       * @param {module:ol/events/Event} evt Event.
       * @private
       */
      Snap.prototype.handleFeatureChange_ = function handleFeatureChange_ (evt) {
        var feature = /** @type {module:ol/Feature} */ (evt.target);
        if (this.handlingDownUpSequence) {
          var uid = getUid(feature);
          if (!(uid in this.pendingFeatures_)) {
            this.pendingFeatures_[uid] = feature;
          }
        } else {
          this.updateFeature_(feature);
        }
      };

      /**
       * Remove a feature from the collection of features that we may snap to.
       * @param {module:ol/Feature} feature Feature
       * @param {boolean=} opt_unlisten Whether to unlisten to the feature change
       *     or not. Defaults to `true`.
       * @api
       */
      Snap.prototype.removeFeature = function removeFeature (feature, opt_unlisten) {
        var unregister = opt_unlisten !== undefined ? opt_unlisten : true;
        var feature_uid = getUid(feature);
        var extent = this.indexedFeaturesExtents_[feature_uid];
        if (extent) {
          var rBush = this.rBush_;
          var nodesToRemove = [];
          rBush.forEachInExtent(extent, function(node) {
            if (feature === node.feature) {
              nodesToRemove.push(node);
            }
          });
          for (var i = nodesToRemove.length - 1; i >= 0; --i) {
            rBush.remove(nodesToRemove[i]);
          }
        }

        if (unregister) {
          unlistenByKey(this.featureChangeListenerKeys_[feature_uid]);
          delete this.featureChangeListenerKeys_[feature_uid];
        }
      };

      /**
       * @inheritDoc
       */
      Snap.prototype.setMap = function setMap (map) {
        var currentMap = this.getMap();
        var keys = this.featuresListenerKeys_;
        var features = this.getFeatures_();

        if (currentMap) {
          keys.forEach(unlistenByKey);
          keys.length = 0;
          features.forEach(this.forEachFeatureRemove_.bind(this));
        }
        PointerInteraction$$1.prototype.setMap.call(this, map);

        if (map) {
          if (this.features_) {
            keys.push(
              listen(this.features_, CollectionEventType.ADD,
                this.handleFeatureAdd_, this),
              listen(this.features_, CollectionEventType.REMOVE,
                this.handleFeatureRemove_, this)
            );
          } else if (this.source_) {
            keys.push(
              listen(this.source_, VectorEventType.ADDFEATURE,
                this.handleFeatureAdd_, this),
              listen(this.source_, VectorEventType.REMOVEFEATURE,
                this.handleFeatureRemove_, this)
            );
          }
          features.forEach(this.forEachFeatureAdd_.bind(this));
        }
      };

      /**
       * @param {module:ol/pixel~Pixel} pixel Pixel
       * @param {module:ol/coordinate~Coordinate} pixelCoordinate Coordinate
       * @param {module:ol/PluggableMap} map Map.
       * @return {module:ol/interaction/Snap~Result} Snap result
       */
      Snap.prototype.snapTo = function snapTo (pixel, pixelCoordinate, map) {

        var lowerLeft = map.getCoordinateFromPixel(
          [pixel[0] - this.pixelTolerance_, pixel[1] + this.pixelTolerance_]);
        var upperRight = map.getCoordinateFromPixel(
          [pixel[0] + this.pixelTolerance_, pixel[1] - this.pixelTolerance_]);
        var box = boundingExtent([lowerLeft, upperRight]);

        var segments = this.rBush_.getInExtent(box);

        // If snapping on vertices only, don't consider circles
        if (this.vertex_ && !this.edge_) {
          segments = segments.filter(function(segment) {
            return segment.feature.getGeometry().getType() !==
                GeometryType.CIRCLE;
          });
        }

        var snappedToVertex = false;
        var snapped = false;
        var vertex = null;
        var vertexPixel = null;
        var dist, pixel1, pixel2, squaredDist1, squaredDist2;
        if (segments.length > 0) {
          this.pixelCoordinate_ = pixelCoordinate;
          segments.sort(this.sortByDistance_);
          var closestSegment = segments[0].segment;
          var isCircle = segments[0].feature.getGeometry().getType() ===
              GeometryType.CIRCLE;
          if (this.vertex_ && !this.edge_) {
            pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
            pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
            squaredDist1 = squaredDistance$1(pixel, pixel1);
            squaredDist2 = squaredDistance$1(pixel, pixel2);
            dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
            snappedToVertex = dist <= this.pixelTolerance_;
            if (snappedToVertex) {
              snapped = true;
              vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
              vertexPixel = map.getPixelFromCoordinate(vertex);
            }
          } else if (this.edge_) {
            if (isCircle) {
              vertex = closestOnCircle(pixelCoordinate,
                /** @type {module:ol/geom/Circle} */ (segments[0].feature.getGeometry()));
            } else {
              vertex = closestOnSegment(pixelCoordinate, closestSegment);
            }
            vertexPixel = map.getPixelFromCoordinate(vertex);
            if (distance(pixel, vertexPixel) <= this.pixelTolerance_) {
              snapped = true;
              if (this.vertex_ && !isCircle) {
                pixel1 = map.getPixelFromCoordinate(closestSegment[0]);
                pixel2 = map.getPixelFromCoordinate(closestSegment[1]);
                squaredDist1 = squaredDistance$1(vertexPixel, pixel1);
                squaredDist2 = squaredDistance$1(vertexPixel, pixel2);
                dist = Math.sqrt(Math.min(squaredDist1, squaredDist2));
                snappedToVertex = dist <= this.pixelTolerance_;
                if (snappedToVertex) {
                  vertex = squaredDist1 > squaredDist2 ? closestSegment[1] : closestSegment[0];
                  vertexPixel = map.getPixelFromCoordinate(vertex);
                }
              }
            }
          }
          if (snapped) {
            vertexPixel = [Math.round(vertexPixel[0]), Math.round(vertexPixel[1])];
          }
        }
        return (
          /** @type {module:ol/interaction/Snap~Result} */ ({
            snapped: snapped,
            vertex: vertex,
            vertexPixel: vertexPixel
          })
        );
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @private
       */
      Snap.prototype.updateFeature_ = function updateFeature_ (feature) {
        this.removeFeature(feature, false);
        this.addFeature(feature, false);
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/Circle} geometry Geometry.
       * @private
       */
      Snap.prototype.writeCircleGeometry_ = function writeCircleGeometry_ (feature, geometry) {
        var this$1 = this;

        var polygon = fromCircle(geometry);
        var coordinates = polygon.getCoordinates()[0];
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
            feature: feature,
            segment: segment
          });
          this$1.rBush_.insert(boundingExtent(segment), segmentData);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/GeometryCollection} geometry Geometry.
       * @private
       */
      Snap.prototype.writeGeometryCollectionGeometry_ = function writeGeometryCollectionGeometry_ (feature, geometry) {
        var this$1 = this;

        var geometries = geometry.getGeometriesArray();
        for (var i = 0; i < geometries.length; ++i) {
          var segmentWriter = this$1.SEGMENT_WRITERS_[geometries[i].getType()];
          if (segmentWriter) {
            segmentWriter.call(this$1, feature, geometries[i]);
          }
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/LineString} geometry Geometry.
       * @private
       */
      Snap.prototype.writeLineStringGeometry_ = function writeLineStringGeometry_ (feature, geometry) {
        var this$1 = this;

        var coordinates = geometry.getCoordinates();
        for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
          var segment = coordinates.slice(i, i + 2);
          var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
            feature: feature,
            segment: segment
          });
          this$1.rBush_.insert(boundingExtent(segment), segmentData);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiLineString} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiLineStringGeometry_ = function writeMultiLineStringGeometry_ (feature, geometry) {
        var this$1 = this;

        var lines = geometry.getCoordinates();
        for (var j = 0, jj = lines.length; j < jj; ++j) {
          var coordinates = lines[j];
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var segment = coordinates.slice(i, i + 2);
            var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
              feature: feature,
              segment: segment
            });
            this$1.rBush_.insert(boundingExtent(segment), segmentData);
          }
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiPoint} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiPointGeometry_ = function writeMultiPointGeometry_ (feature, geometry) {
        var this$1 = this;

        var points = geometry.getCoordinates();
        for (var i = 0, ii = points.length; i < ii; ++i) {
          var coordinates = points[i];
          var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
            feature: feature,
            segment: [coordinates, coordinates]
          });
          this$1.rBush_.insert(geometry.getExtent(), segmentData);
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/MultiPolygon} geometry Geometry.
       * @private
       */
      Snap.prototype.writeMultiPolygonGeometry_ = function writeMultiPolygonGeometry_ (feature, geometry) {
        var this$1 = this;

        var polygons = geometry.getCoordinates();
        for (var k = 0, kk = polygons.length; k < kk; ++k) {
          var rings = polygons[k];
          for (var j = 0, jj = rings.length; j < jj; ++j) {
            var coordinates = rings[j];
            for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
              var segment = coordinates.slice(i, i + 2);
              var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
                feature: feature,
                segment: segment
              });
              this$1.rBush_.insert(boundingExtent(segment), segmentData);
            }
          }
        }
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/Point} geometry Geometry.
       * @private
       */
      Snap.prototype.writePointGeometry_ = function writePointGeometry_ (feature, geometry) {
        var coordinates = geometry.getCoordinates();
        var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
          feature: feature,
          segment: [coordinates, coordinates]
        });
        this.rBush_.insert(geometry.getExtent(), segmentData);
      };

      /**
       * @param {module:ol/Feature} feature Feature
       * @param {module:ol/geom/Polygon} geometry Geometry.
       * @private
       */
      Snap.prototype.writePolygonGeometry_ = function writePolygonGeometry_ (feature, geometry) {
        var this$1 = this;

        var rings = geometry.getCoordinates();
        for (var j = 0, jj = rings.length; j < jj; ++j) {
          var coordinates = rings[j];
          for (var i = 0, ii = coordinates.length - 1; i < ii; ++i) {
            var segment = coordinates.slice(i, i + 2);
            var segmentData = /** @type {module:ol/interaction/Snap~SegmentData} */ ({
              feature: feature,
              segment: segment
            });
            this$1.rBush_.insert(boundingExtent(segment), segmentData);
          }
        }
      };

      return Snap;
    }(PointerInteraction));


    /**
     * Handle all pointer events events.
     * @param {module:ol/MapBrowserEvent} evt A move event.
     * @return {boolean} Pass the event to other interactions.
     * @this {module:ol/interaction/Snap}
     */
    function handleEvent$9(evt) {
      var result = this.snapTo(evt.pixel, evt.coordinate, evt.map);
      if (result.snapped) {
        evt.coordinate = result.vertex.slice(0, 2);
        evt.pixel = result.vertexPixel;
      }
      return handleEvent$1.call(this, evt);
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} evt Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/Snap}
     */
    function handleUpEvent$a(evt) {
      var featuresToUpdate = getValues(this.pendingFeatures_);
      if (featuresToUpdate.length) {
        featuresToUpdate.forEach(this.updateFeature_.bind(this));
        this.pendingFeatures_ = {};
      }
      return false;
    }


    /**
     * Sort segments by distance, helper function
     * @param {module:ol/interaction/Snap~SegmentData} a The first segment data.
     * @param {module:ol/interaction/Snap~SegmentData} b The second segment data.
     * @return {number} The difference in distance.
     * @this {module:ol/interaction/Snap}
     */
    function sortByDistance(a, b) {
      var deltaA = squaredDistanceToSegment(this.pixelCoordinate_, a.segment);
      var deltaB = squaredDistanceToSegment(this.pixelCoordinate_, b.segment);
      return deltaA - deltaB;
    }

    /**
     * @module ol/interaction/Translate
     */


    /**
     * @enum {string}
     */
    var TranslateEventType = {
      /**
       * Triggered upon feature translation start.
       * @event TranslateEvent#translatestart
       * @api
       */
      TRANSLATESTART: 'translatestart',
      /**
       * Triggered upon feature translation.
       * @event TranslateEvent#translating
       * @api
       */
      TRANSLATING: 'translating',
      /**
       * Triggered upon feature translation end.
       * @event TranslateEvent#translateend
       * @api
       */
      TRANSLATEEND: 'translateend'
    };


    /**
     * @typedef {Object} Options
     * @property {module:ol/Collection.<module:ol/Feature>} [features] Only features contained in this collection will be able to be translated. If
     * not specified, all features on the map will be able to be translated.
     * @property {Array.<module:ol/layer/Layer>|function(module:ol/layer/Layer): boolean} [layers] A list of layers from which features should be
     * translated. Alternatively, a filter function can be provided. The
     * function will be called for each layer in the map and should return
     * `true` for layers that you want to be translatable. If the option is
     * absent, all visible layers will be considered translatable.
     * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside the radius around the given position
     * will be checked for features. This only works for the canvas renderer and
     * not for WebGL.
     */


    /**
     * @classdesc
     * Events emitted by {@link module:ol/interaction/Translate~Translate} instances
     * are instances of this type.
     */
    var TranslateEvent = (function (Event$$1) {
      function TranslateEvent(type, features, coordinate) {

        Event$$1.call(this, type);

        /**
         * The features being translated.
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @api
         */
        this.features = features;

        /**
         * The coordinate of the drag event.
         * @const
         * @type {module:ol/coordinate~Coordinate}
         * @api
         */
        this.coordinate = coordinate;

      }

      if ( Event$$1 ) TranslateEvent.__proto__ = Event$$1;
      TranslateEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      TranslateEvent.prototype.constructor = TranslateEvent;

      return TranslateEvent;
    }(Event));


    /**
     * @classdesc
     * Interaction for translating (moving) features.
     *
     * @fires module:ol/interaction/Translate~TranslateEvent
     * @api
     */
    var Translate = (function (PointerInteraction$$1) {
      function Translate(opt_options) {
        PointerInteraction$$1.call(this, {
          handleDownEvent: handleDownEvent$a,
          handleDragEvent: handleDragEvent$9,
          handleMoveEvent: handleMoveEvent$1,
          handleUpEvent: handleUpEvent$b
        });

        var options = opt_options ? opt_options : {};

        /**
         * The last position we translated to.
         * @type {module:ol/coordinate~Coordinate}
         * @private
         */
        this.lastCoordinate_ = null;


        /**
         * @type {module:ol/Collection.<module:ol/Feature>}
         * @private
         */
        this.features_ = options.features !== undefined ? options.features : null;

        /** @type {function(module:ol/layer/Layer): boolean} */
        var layerFilter;
        if (options.layers) {
          if (typeof options.layers === 'function') {
            layerFilter = options.layers;
          } else {
            var layers = options.layers;
            layerFilter = function(layer) {
              return includes(layers, layer);
            };
          }
        } else {
          layerFilter = TRUE;
        }

        /**
         * @private
         * @type {function(module:ol/layer/Layer): boolean}
         */
        this.layerFilter_ = layerFilter;

        /**
         * @private
         * @type {number}
         */
        this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

        /**
         * @type {module:ol/Feature}
         * @private
         */
        this.lastFeature_ = null;

        listen(this,
          getChangeEventType(InteractionProperty.ACTIVE),
          this.handleActiveChanged_, this);

      }

      if ( PointerInteraction$$1 ) Translate.__proto__ = PointerInteraction$$1;
      Translate.prototype = Object.create( PointerInteraction$$1 && PointerInteraction$$1.prototype );
      Translate.prototype.constructor = Translate;

      /**
       * Tests to see if the given coordinates intersects any of our selected
       * features.
       * @param {module:ol/pixel~Pixel} pixel Pixel coordinate to test for intersection.
       * @param {module:ol/PluggableMap} map Map to test the intersection on.
       * @return {module:ol/Feature} Returns the feature found at the specified pixel
       * coordinates.
       * @private
       */
      Translate.prototype.featuresAtPixel_ = function featuresAtPixel_ (pixel, map) {
        return map.forEachFeatureAtPixel(pixel,
          function(feature) {
            if (!this.features_ || includes(this.features_.getArray(), feature)) {
              return feature;
            }
          }.bind(this), {
            layerFilter: this.layerFilter_,
            hitTolerance: this.hitTolerance_
          });
      };

      /**
       * Returns the Hit-detection tolerance.
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Translate.prototype.getHitTolerance = function getHitTolerance () {
        return this.hitTolerance_;
      };

      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features. This only works for the canvas renderer and
       * not for WebGL.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Translate.prototype.setHitTolerance = function setHitTolerance (hitTolerance) {
        this.hitTolerance_ = hitTolerance;
      };

      /**
       * @inheritDoc
       */
      Translate.prototype.setMap = function setMap (map) {
        var oldMap = this.getMap();
        PointerInteraction$$1.prototype.setMap.call(this, map);
        this.updateState_(oldMap);
      };

      /**
       * @private
       */
      Translate.prototype.handleActiveChanged_ = function handleActiveChanged_ () {
        this.updateState_(null);
      };

      /**
       * @param {module:ol/PluggableMap} oldMap Old map.
       * @private
       */
      Translate.prototype.updateState_ = function updateState_ (oldMap) {
        var map = this.getMap();
        var active = this.getActive();
        if (!map || !active) {
          map = map || oldMap;
          if (map) {
            var elem = map.getViewport();
            elem.classList.remove('ol-grab', 'ol-grabbing');
          }
        }
      };

      return Translate;
    }(PointerInteraction));


    /**
     * @param {module:ol/MapBrowserPointerEvent} event Event.
     * @return {boolean} Start drag sequence?
     * @this {module:ol/interaction/Translate}
     */
    function handleDownEvent$a(event) {
      this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
      if (!this.lastCoordinate_ && this.lastFeature_) {
        this.lastCoordinate_ = event.coordinate;
        handleMoveEvent$1.call(this, event);

        var features = this.features_ || new Collection([this.lastFeature_]);

        this.dispatchEvent(
          new TranslateEvent(
            TranslateEventType.TRANSLATESTART, features,
            event.coordinate));
        return true;
      }
      return false;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} event Event.
     * @return {boolean} Stop drag sequence?
     * @this {module:ol/interaction/Translate}
     */
    function handleUpEvent$b(event) {
      if (this.lastCoordinate_) {
        this.lastCoordinate_ = null;
        handleMoveEvent$1.call(this, event);

        var features = this.features_ || new Collection([this.lastFeature_]);

        this.dispatchEvent(
          new TranslateEvent(
            TranslateEventType.TRANSLATEEND, features,
            event.coordinate));
        return true;
      }
      return false;
    }


    /**
     * @param {module:ol/MapBrowserPointerEvent} event Event.
     * @this {module:ol/interaction/Translate}
     */
    function handleDragEvent$9(event) {
      if (this.lastCoordinate_) {
        var newCoordinate = event.coordinate;
        var deltaX = newCoordinate[0] - this.lastCoordinate_[0];
        var deltaY = newCoordinate[1] - this.lastCoordinate_[1];

        var features = this.features_ || new Collection([this.lastFeature_]);

        features.forEach(function(feature) {
          var geom = feature.getGeometry();
          geom.translate(deltaX, deltaY);
          feature.setGeometry(geom);
        });

        this.lastCoordinate_ = newCoordinate;
        this.dispatchEvent(
          new TranslateEvent(
            TranslateEventType.TRANSLATING, features,
            newCoordinate));
      }
    }


    /**
     * @param {module:ol/MapBrowserEvent} event Event.
     * @this {module:ol/interaction/Translate}
     */
    function handleMoveEvent$1(event) {
      var elem = event.map.getViewport();

      // Change the cursor to grab/grabbing if hovering any of the features managed
      // by the interaction
      if (this.featuresAtPixel_(event.pixel, event.map)) {
        elem.classList.remove(this.lastCoordinate_ ? 'ol-grab' : 'ol-grabbing');
        elem.classList.add(this.lastCoordinate_ ? 'ol-grabbing' : 'ol-grab');
      } else {
        elem.classList.remove('ol-grab', 'ol-grabbing');
      }
    }

    /**
     * @module ol/interaction
     */


    /**
     * @typedef {Object} DefaultsOptions
     * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
     * desired.
     * @property {boolean} [constrainResolution=false] Zoom to the closest integer
     * zoom level after the wheel/trackpad or pinch gesture ends.
     * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
     * desired.
     * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
     * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
     * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
     * @property {boolean} [dragPan=true] Whether drag pan is desired.
     * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
     * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
     * @property {number} [zoomDelta] Zoom level delta when using keyboard or
     * mousewheel zoom.
     * @property {number} [zoomDuration] Duration of the zoom animation in
     * milliseconds.
     */


    /**
     * Set of interactions included in maps by default. Specific interactions can be
     * excluded by setting the appropriate option to false in the constructor
     * options, but the order of the interactions is fixed.  If you want to specify
     * a different order for interactions, you will need to create your own
     * {@link module:ol/interaction/Interaction} instances and insert
     * them into a {@link module:ol/Collection} in the order you want
     * before creating your {@link module:ol/Map~Map} instance. The default set of
     * interactions, in sequence, is:
     * * {@link module:ol/interaction/DragRotate~DragRotate}
     * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
     * * {@link module:ol/interaction/DragPan~DragPan}
     * * {@link module:ol/interaction/PinchRotate~PinchRotate}
     * * {@link module:ol/interaction/PinchZoom~PinchZoom}
     * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
     * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
     * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
     * * {@link module:ol/interaction/DragZoom~DragZoom}
     *
     * @param {module:ol/interaction/Interaction~DefaultsOptions=} opt_options
     * Defaults options.
     * @return {module:ol/Collection.<module:ol/interaction/Interaction>}
     * A collection of interactions to be used with the {@link module:ol/Map~Map}
     * constructor's `interactions` option.
     * @api
     */
    function defaults$1(opt_options) {

      var options = opt_options ? opt_options : {};

      var interactions = new Collection();

      var kinetic = new Kinetic(-0.005, 0.05, 100);

      var altShiftDragRotate = options.altShiftDragRotate !== undefined ?
        options.altShiftDragRotate : true;
      if (altShiftDragRotate) {
        interactions.push(new DragRotate());
      }

      var doubleClickZoom = options.doubleClickZoom !== undefined ?
        options.doubleClickZoom : true;
      if (doubleClickZoom) {
        interactions.push(new DoubleClickZoom({
          delta: options.zoomDelta,
          duration: options.zoomDuration
        }));
      }

      var dragPan = options.dragPan !== undefined ? options.dragPan : true;
      if (dragPan) {
        interactions.push(new DragPan({
          kinetic: kinetic
        }));
      }

      var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate :
        true;
      if (pinchRotate) {
        interactions.push(new PinchRotate());
      }

      var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
      if (pinchZoom) {
        interactions.push(new PinchZoom({
          constrainResolution: options.constrainResolution,
          duration: options.zoomDuration
        }));
      }

      var keyboard = options.keyboard !== undefined ? options.keyboard : true;
      if (keyboard) {
        interactions.push(new KeyboardPan());
        interactions.push(new KeyboardZoom({
          delta: options.zoomDelta,
          duration: options.zoomDuration
        }));
      }

      var mouseWheelZoom = options.mouseWheelZoom !== undefined ?
        options.mouseWheelZoom : true;
      if (mouseWheelZoom) {
        interactions.push(new MouseWheelZoom({
          constrainResolution: options.constrainResolution,
          duration: options.zoomDuration
        }));
      }

      var shiftDragZoom = options.shiftDragZoom !== undefined ?
        options.shiftDragZoom : true;
      if (shiftDragZoom) {
        interactions.push(new DragZoom({
          duration: options.zoomDuration
        }));
      }

      return interactions;

    }

    /**
     * Default maximum allowed threshold  (in pixels) for reprojection
     * triangulation.
     * @type {number}
     */
    var ERROR_THRESHOLD = 0.5;

    /**
     * @module ol/ImageBase
     */

    /**
     * @abstract
     */
    var ImageBase = (function (EventTarget$$1) {
      function ImageBase(extent, resolution, pixelRatio, state) {

        EventTarget$$1.call(this);

        /**
         * @protected
         * @type {module:ol/extent~Extent}
         */
        this.extent = extent;

        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;

        /**
         * @protected
         * @type {number|undefined}
         */
        this.resolution = resolution;

        /**
         * @protected
         * @type {module:ol/ImageState}
         */
        this.state = state;

      }

      if ( EventTarget$$1 ) ImageBase.__proto__ = EventTarget$$1;
      ImageBase.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      ImageBase.prototype.constructor = ImageBase;

      /**
       * @protected
       */
      ImageBase.prototype.changed = function changed () {
        this.dispatchEvent(EventType.CHANGE);
      };

      /**
       * @return {module:ol/extent~Extent} Extent.
       */
      ImageBase.prototype.getExtent = function getExtent () {
        return this.extent;
      };

      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       */
      ImageBase.prototype.getImage = function getImage () {};

      /**
       * @return {number} PixelRatio.
       */
      ImageBase.prototype.getPixelRatio = function getPixelRatio () {
        return this.pixelRatio_;
      };

      /**
       * @return {number} Resolution.
       */
      ImageBase.prototype.getResolution = function getResolution () {
        return /** @type {number} */ (this.resolution);
      };

      /**
       * @return {module:ol/ImageState} State.
       */
      ImageBase.prototype.getState = function getState () {
        return this.state;
      };

      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageBase.prototype.load = function load () {};

      return ImageBase;
    }(EventTarget));

    /**
     * @module ol/ImageCanvas
     */


    /**
     * A function that is called to trigger asynchronous canvas drawing.  It is
     * called with a "done" callback that should be called when drawing is done.
     * If any error occurs during drawing, the "done" callback should be called with
     * that error.
     *
     * @typedef {function(function(Error))} Loader
     */


    var ImageCanvas = (function (ImageBase$$1) {
      function ImageCanvas(extent, resolution, pixelRatio, canvas, opt_loader) {

        var state = opt_loader !== undefined ? ImageState.IDLE : ImageState.LOADED;

        ImageBase$$1.call(this, extent, resolution, pixelRatio, state);

        /**
         * Optional canvas loader function.
         * @type {?module:ol/ImageCanvas~Loader}
         * @private
         */
        this.loader_ = opt_loader !== undefined ? opt_loader : null;

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.canvas_ = canvas;

        /**
         * @private
         * @type {Error}
         */
        this.error_ = null;

      }

      if ( ImageBase$$1 ) ImageCanvas.__proto__ = ImageBase$$1;
      ImageCanvas.prototype = Object.create( ImageBase$$1 && ImageBase$$1.prototype );
      ImageCanvas.prototype.constructor = ImageCanvas;

      /**
       * Get any error associated with asynchronous rendering.
       * @return {Error} Any error that occurred during rendering.
       */
      ImageCanvas.prototype.getError = function getError () {
        return this.error_;
      };

      /**
       * Handle async drawing complete.
       * @param {Error} err Any error during drawing.
       * @private
       */
      ImageCanvas.prototype.handleLoad_ = function handleLoad_ (err) {
        if (err) {
          this.error_ = err;
          this.state = ImageState.ERROR;
        } else {
          this.state = ImageState.LOADED;
        }
        this.changed();
      };

      /**
       * @inheritDoc
       */
      ImageCanvas.prototype.load = function load () {
        if (this.state == ImageState.IDLE) {
          this.state = ImageState.LOADING;
          this.changed();
          this.loader_(this.handleLoad_.bind(this));
        }
      };

      /**
       * @return {HTMLCanvasElement} Canvas element.
       */
      ImageCanvas.prototype.getImage = function getImage () {
        return this.canvas_;
      };

      return ImageCanvas;
    }(ImageBase));

    /**
     * @module ol/render/Event
     */

    var RenderEvent = (function (Event$$1) {
      function RenderEvent(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

        Event$$1.call(this, type);

        /**
         * For canvas, this is an instance of {@link module:ol/render/canvas/Immediate}.
         * @type {module:ol/render/VectorContext|undefined}
         * @api
         */
        this.vectorContext = opt_vectorContext;

        /**
         * An object representing the current render frame state.
         * @type {module:ol/PluggableMap~FrameState|undefined}
         * @api
         */
        this.frameState = opt_frameState;

        /**
         * Canvas context. Only available when a Canvas renderer is used, null
         * otherwise.
         * @type {CanvasRenderingContext2D|null|undefined}
         * @api
         */
        this.context = opt_context;

        /**
         * WebGL context. Only available when a WebGL renderer is used, null
         * otherwise.
         * @type {module:ol/webgl/Context|null|undefined}
         * @api
         */
        this.glContext = opt_glContext;

      }

      if ( Event$$1 ) RenderEvent.__proto__ = Event$$1;
      RenderEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      RenderEvent.prototype.constructor = RenderEvent;

      return RenderEvent;
    }(Event));

    /**
     * @module ol/render/VectorContext
     */

    /**
     * @classdesc
     * Context for drawing geometries.  A vector context is available on render
     * events and does not need to be constructed directly.
     * @api
     */
    var VectorContext = function VectorContext () {};

    VectorContext.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {};

    /**
     * Render a geometry.
     *
     * @param {module:ol/geom/Geometry} geometry The geometry to render.
     */
    VectorContext.prototype.drawGeometry = function drawGeometry (geometry) {};

    /**
     * Set the rendering style.
     *
     * @param {module:ol/style/Style} style The rendering style.
     */
    VectorContext.prototype.setStyle = function setStyle (style) {};

    /**
     * @param {module:ol/geom/Circle} circleGeometry Circle geometry.
     * @param {module:ol/Feature} feature Feature.
     */
    VectorContext.prototype.drawCircle = function drawCircle (circleGeometry, feature) {};

    /**
     * @param {module:ol/Feature} feature Feature.
     * @param {module:ol/style/Style} style Style.
     */
    VectorContext.prototype.drawFeature = function drawFeature (feature, style) {};

    /**
     * @param {module:ol/geom/GeometryCollection} geometryCollectionGeometry Geometry collection.
     * @param {module:ol/Feature} feature Feature.
     */
    VectorContext.prototype.drawGeometryCollection = function drawGeometryCollection (geometryCollectionGeometry, feature) {};

    /**
     * @param {module:ol/geom/LineString|module:ol/render/Feature} lineStringGeometry Line string geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {};

    /**
     * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} multiLineStringGeometry MultiLineString geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {};

    /**
     * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} multiPointGeometry MultiPoint geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {};

    /**
     * @param {module:ol/geom/MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {};

    /**
     * @param {module:ol/geom/Point|module:ol/render/Feature} pointGeometry Point geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawPoint = function drawPoint (pointGeometry, feature) {};

    /**
     * @param {module:ol/geom/Polygon|module:ol/render/Feature} polygonGeometry Polygon geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {};

    /**
     * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    VectorContext.prototype.drawText = function drawText (geometry, feature) {};

    /**
     * @param {module:ol/style/Fill} fillStyle Fill style.
     * @param {module:ol/style/Stroke} strokeStyle Stroke style.
     */
    VectorContext.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {};

    /**
     * @param {module:ol/style/Image} imageStyle Image style.
     * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.
     */
    VectorContext.prototype.setImageStyle = function setImageStyle (imageStyle, opt_declutterGroup) {};

    /**
     * @param {module:ol/style/Text} textStyle Text style.
     * @param {module:ol/render/canvas~DeclutterGroup=} opt_declutterGroup Declutter.
     */
    VectorContext.prototype.setTextStyle = function setTextStyle (textStyle, opt_declutterGroup) {};

    /**
     * @module ol/render/canvas/Immediate
     */

    /**
     * @classdesc
     * A concrete subclass of {@link module:ol/render/VectorContext} that implements
     * direct rendering of features and geometries to an HTML5 Canvas context.
     * Instances of this class are created internally by the library and
     * provided to application code as vectorContext member of the
     * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
     * render events emitted by layers and maps.
     */
    var CanvasImmediateRenderer = (function (VectorContext$$1) {
      function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation) {
        VectorContext$$1.call(this);

        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        this.context_ = context;

        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.extent_ = extent;

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.transform_ = transform;

        /**
         * @private
         * @type {number}
         */
        this.viewRotation_ = viewRotation;

        /**
         * @private
         * @type {?module:ol/render/canvas~FillState}
         */
        this.contextFillState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~StrokeState}
         */
        this.contextStrokeState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~TextState}
         */
        this.contextTextState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~FillState}
         */
        this.fillState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~StrokeState}
         */
        this.strokeState_ = null;

        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        this.image_ = null;

        /**
         * @private
         * @type {number}
         */
        this.imageAnchorX_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageAnchorY_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageHeight_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageOpacity_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageOriginX_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageOriginY_ = 0;

        /**
         * @private
         * @type {boolean}
         */
        this.imageRotateWithView_ = false;

        /**
         * @private
         * @type {number}
         */
        this.imageRotation_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.imageScale_ = 0;

        /**
         * @private
         * @type {boolean}
         */
        this.imageSnapToPixel_ = false;

        /**
         * @private
         * @type {number}
         */
        this.imageWidth_ = 0;

        /**
         * @private
         * @type {string}
         */
        this.text_ = '';

        /**
         * @private
         * @type {number}
         */
        this.textOffsetX_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.textOffsetY_ = 0;

        /**
         * @private
         * @type {boolean}
         */
        this.textRotateWithView_ = false;

        /**
         * @private
         * @type {number}
         */
        this.textRotation_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.textScale_ = 0;

        /**
         * @private
         * @type {?module:ol/render/canvas~FillState}
         */
        this.textFillState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~StrokeState}
         */
        this.textStrokeState_ = null;

        /**
         * @private
         * @type {?module:ol/render/canvas~TextState}
         */
        this.textState_ = null;

        /**
         * @private
         * @type {Array.<number>}
         */
        this.pixelCoordinates_ = [];

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.tmpLocalTransform_ = create();

      }

      if ( VectorContext$$1 ) CanvasImmediateRenderer.__proto__ = VectorContext$$1;
      CanvasImmediateRenderer.prototype = Object.create( VectorContext$$1 && VectorContext$$1.prototype );
      CanvasImmediateRenderer.prototype.constructor = CanvasImmediateRenderer;

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawImages_ = function drawImages_ (flatCoordinates, offset, end, stride) {
        var this$1 = this;

        if (!this.image_) {
          return;
        }
        var pixelCoordinates = transform2D(
          flatCoordinates, offset, end, 2, this.transform_,
          this.pixelCoordinates_);
        var context = this.context_;
        var localTransform = this.tmpLocalTransform_;
        var alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha * this.imageOpacity_;
        }
        var rotation = this.imageRotation_;
        if (this.imageRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
          var x = pixelCoordinates[i] - this$1.imageAnchorX_;
          var y = pixelCoordinates[i + 1] - this$1.imageAnchorY_;
          if (this$1.imageSnapToPixel_) {
            x = Math.round(x);
            y = Math.round(y);
          }
          if (rotation !== 0 || this$1.imageScale_ != 1) {
            var centerX = x + this$1.imageAnchorX_;
            var centerY = y + this$1.imageAnchorY_;
            compose(localTransform,
              centerX, centerY,
              this$1.imageScale_, this$1.imageScale_,
              rotation,
              -centerX, -centerY);
            context.setTransform.apply(context, localTransform);
          }
          context.drawImage(this$1.image_, this$1.imageOriginX_, this$1.imageOriginY_,
            this$1.imageWidth_, this$1.imageHeight_, x, y,
            this$1.imageWidth_, this$1.imageHeight_);
        }
        if (rotation !== 0 || this.imageScale_ != 1) {
          context.setTransform(1, 0, 0, 1, 0, 0);
        }
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha;
        }
      };

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawText_ = function drawText_ (flatCoordinates, offset, end, stride) {
        var this$1 = this;

        if (!this.textState_ || this.text_ === '') {
          return;
        }
        if (this.textFillState_) {
          this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
          this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        var pixelCoordinates = transform2D(
          flatCoordinates, offset, end, stride, this.transform_,
          this.pixelCoordinates_);
        var context = this.context_;
        var rotation = this.textRotation_;
        if (this.textRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (; offset < end; offset += stride) {
          var x = pixelCoordinates[offset] + this$1.textOffsetX_;
          var y = pixelCoordinates[offset + 1] + this$1.textOffsetY_;
          if (rotation !== 0 || this$1.textScale_ != 1) {
            var localTransform = compose(this$1.tmpLocalTransform_,
              x, y,
              this$1.textScale_, this$1.textScale_,
              rotation,
              -x, -y);
            context.setTransform.apply(context, localTransform);
          }
          if (this$1.textStrokeState_) {
            context.strokeText(this$1.text_, x, y);
          }
          if (this$1.textFillState_) {
            context.fillText(this$1.text_, x, y);
          }
        }
        if (rotation !== 0 || this.textScale_ != 1) {
          context.setTransform(1, 0, 0, 1, 0, 0);
        }
      };

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      CanvasImmediateRenderer.prototype.moveToLineTo_ = function moveToLineTo_ (flatCoordinates, offset, end, stride, close) {
        var context = this.context_;
        var pixelCoordinates = transform2D(
          flatCoordinates, offset, end, stride, this.transform_,
          this.pixelCoordinates_);
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        var length = pixelCoordinates.length;
        if (close) {
          length -= 2;
        }
        for (var i = 2; i < length; i += 2) {
          context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        }
        if (close) {
          context.closePath();
        }
        return end;
      };

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array.<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasImmediateRenderer.prototype.drawRings_ = function drawRings_ (flatCoordinates, offset, ends, stride) {
        var this$1 = this;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
        }
        return offset;
      };

      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {module:ol/geom/Circle} geometry Circle geometry.
       * @override
       * @api
       */
      CanvasImmediateRenderer.prototype.drawCircle = function drawCircle (geometry) {
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.fillState_ || this.strokeState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          var pixelCoordinates = transformGeom2D(
            geometry, this.transform_, this.pixelCoordinates_);
          var dx = pixelCoordinates[2] - pixelCoordinates[0];
          var dy = pixelCoordinates[3] - pixelCoordinates[1];
          var radius = Math.sqrt(dx * dx + dy * dy);
          var context = this.context_;
          context.beginPath();
          context.arc(
            pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== '') {
          this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
      };

      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {module:ol/style/Style} style The rendering style.
       * @override
       * @api
       */
      CanvasImmediateRenderer.prototype.setStyle = function setStyle (style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
      };

      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
       *
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry The geometry to render.
       * @override
       * @api
       */
      CanvasImmediateRenderer.prototype.drawGeometry = function drawGeometry (geometry) {
        var type = geometry.getType();
        switch (type) {
          case GeometryType.POINT:
            this.drawPoint(/** @type {module:ol/geom/Point} */ (geometry));
            break;
          case GeometryType.LINE_STRING:
            this.drawLineString(/** @type {module:ol/geom/LineString} */ (geometry));
            break;
          case GeometryType.POLYGON:
            this.drawPolygon(/** @type {module:ol/geom/Polygon} */ (geometry));
            break;
          case GeometryType.MULTI_POINT:
            this.drawMultiPoint(/** @type {module:ol/geom/MultiPoint} */ (geometry));
            break;
          case GeometryType.MULTI_LINE_STRING:
            this.drawMultiLineString(/** @type {module:ol/geom/MultiLineString} */ (geometry));
            break;
          case GeometryType.MULTI_POLYGON:
            this.drawMultiPolygon(/** @type {module:ol/geom/MultiPolygon} */ (geometry));
            break;
          case GeometryType.GEOMETRY_COLLECTION:
            this.drawGeometryCollection(/** @type {module:ol/geom/GeometryCollection} */ (geometry));
            break;
          case GeometryType.CIRCLE:
            this.drawCircle(/** @type {module:ol/geom/Circle} */ (geometry));
            break;
          default:
        }
      };

      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {module:ol/Feature} feature Feature.
       * @param {module:ol/style/Style} style Style.
       * @override
       * @api
       */
      CanvasImmediateRenderer.prototype.drawFeature = function drawFeature (feature, style) {
        var geometry = style.getGeometryFunction()(feature);
        if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
      };

      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {module:ol/geom/GeometryCollection} geometry Geometry collection.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawGeometryCollection = function drawGeometryCollection (geometry) {
        var this$1 = this;

        var geometries = geometry.getGeometriesArray();
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          this$1.drawGeometry(geometries[i]);
        }
      };

      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Point geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawPoint = function drawPoint (geometry) {
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== '') {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      };

      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry MultiPoint geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawMultiPoint = function drawMultiPoint (geometry) {
        var flatCoordinates = geometry.getFlatCoordinates();
        var stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== '') {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      };

      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry LineString geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawLineString = function drawLineString (geometry) {
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          var context = this.context_;
          var flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length,
            geometry.getStride(), false);
          context.stroke();
        }
        if (this.text_ !== '') {
          var flatMidpoint = geometry.getFlatMidpoint();
          this.drawText_(flatMidpoint, 0, 2, 2);
        }
      };

      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry MultiLineString geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawMultiLineString = function drawMultiLineString (geometry) {
        var this$1 = this;

        var geometryExtent = geometry.getExtent();
        if (!intersects(this.extent_, geometryExtent)) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          var context = this.context_;
          var flatCoordinates = geometry.getFlatCoordinates();
          var offset = 0;
          var ends = geometry.getEnds();
          var stride = geometry.getStride();
          context.beginPath();
          for (var i = 0, ii = ends.length; i < ii; ++i) {
            offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
          }
          context.stroke();
        }
        if (this.text_ !== '') {
          var flatMidpoints = geometry.getFlatMidpoints();
          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
      };

      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Polygon geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawPolygon = function drawPolygon (geometry) {
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          var context = this.context_;
          context.beginPath();
          this.drawRings_(geometry.getOrientedFlatCoordinates(),
            0, geometry.getEnds(), geometry.getStride());
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== '') {
          var flatInteriorPoint = geometry.getFlatInteriorPoint();
          this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
      };

      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {module:ol/geom/MultiPolygon} geometry MultiPolygon geometry.
       * @override
       */
      CanvasImmediateRenderer.prototype.drawMultiPolygon = function drawMultiPolygon (geometry) {
        var this$1 = this;

        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          var context = this.context_;
          var flatCoordinates = geometry.getOrientedFlatCoordinates();
          var offset = 0;
          var endss = geometry.getEndss();
          var stride = geometry.getStride();
          context.beginPath();
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var ends = endss[i];
            offset = this$1.drawRings_(flatCoordinates, offset, ends, stride);
          }
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== '') {
          var flatInteriorPoints = geometry.getFlatInteriorPoints();
          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
      };

      /**
       * @param {module:ol/render/canvas~FillState} fillState Fill state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextFillState_ = function setContextFillState_ (fillState) {
        var context = this.context_;
        var contextFillState = this.contextFillState_;
        if (!contextFillState) {
          context.fillStyle = fillState.fillStyle;
          this.contextFillState_ = {
            fillStyle: fillState.fillStyle
          };
        } else {
          if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
          }
        }
      };

      /**
       * @param {module:ol/render/canvas~StrokeState} strokeState Stroke state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextStrokeState_ = function setContextStrokeState_ (strokeState) {
        var context = this.context_;
        var contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
          context.lineCap = strokeState.lineCap;
          if (CANVAS_LINE_DASH) {
            context.setLineDash(strokeState.lineDash);
            context.lineDashOffset = strokeState.lineDashOffset;
          }
          context.lineJoin = strokeState.lineJoin;
          context.lineWidth = strokeState.lineWidth;
          context.miterLimit = strokeState.miterLimit;
          context.strokeStyle = strokeState.strokeStyle;
          this.contextStrokeState_ = {
            lineCap: strokeState.lineCap,
            lineDash: strokeState.lineDash,
            lineDashOffset: strokeState.lineDashOffset,
            lineJoin: strokeState.lineJoin,
            lineWidth: strokeState.lineWidth,
            miterLimit: strokeState.miterLimit,
            strokeStyle: strokeState.strokeStyle
          };
        } else {
          if (contextStrokeState.lineCap != strokeState.lineCap) {
            contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
          }
          if (CANVAS_LINE_DASH) {
            if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
              context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
            }
            if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
              contextStrokeState.lineDashOffset = context.lineDashOffset =
                  strokeState.lineDashOffset;
            }
          }
          if (contextStrokeState.lineJoin != strokeState.lineJoin) {
            contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
          }
          if (contextStrokeState.lineWidth != strokeState.lineWidth) {
            contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
          }
          if (contextStrokeState.miterLimit != strokeState.miterLimit) {
            contextStrokeState.miterLimit = context.miterLimit =
                strokeState.miterLimit;
          }
          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
            contextStrokeState.strokeStyle = context.strokeStyle =
                strokeState.strokeStyle;
          }
        }
      };

      /**
       * @param {module:ol/render/canvas~TextState} textState Text state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextTextState_ = function setContextTextState_ (textState) {
        var context = this.context_;
        var contextTextState = this.contextTextState_;
        var textAlign = textState.textAlign ?
          textState.textAlign : defaultTextAlign;
        if (!contextTextState) {
          context.font = textState.font;
          context.textAlign = textAlign;
          context.textBaseline = textState.textBaseline;
          this.contextTextState_ = {
            font: textState.font,
            textAlign: textAlign,
            textBaseline: textState.textBaseline
          };
        } else {
          if (contextTextState.font != textState.font) {
            contextTextState.font = context.font = textState.font;
          }
          if (contextTextState.textAlign != textAlign) {
            contextTextState.textAlign = context.textAlign = textAlign;
          }
          if (contextTextState.textBaseline != textState.textBaseline) {
            contextTextState.textBaseline = context.textBaseline =
                textState.textBaseline;
          }
        }
      };

      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {module:ol/style/Fill} fillStyle Fill style.
       * @param {module:ol/style/Stroke} strokeStyle Stroke style.
       * @override
       */
      CanvasImmediateRenderer.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
        if (!fillStyle) {
          this.fillState_ = null;
        } else {
          var fillStyleColor = fillStyle.getColor();
          this.fillState_ = {
            fillStyle: asColorLike(fillStyleColor ?
              fillStyleColor : defaultFillStyle)
          };
        }
        if (!strokeStyle) {
          this.strokeState_ = null;
        } else {
          var strokeStyleColor = strokeStyle.getColor();
          var strokeStyleLineCap = strokeStyle.getLineCap();
          var strokeStyleLineDash = strokeStyle.getLineDash();
          var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          var strokeStyleLineJoin = strokeStyle.getLineJoin();
          var strokeStyleWidth = strokeStyle.getWidth();
          var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          this.strokeState_ = {
            lineCap: strokeStyleLineCap !== undefined ?
              strokeStyleLineCap : defaultLineCap,
            lineDash: strokeStyleLineDash ?
              strokeStyleLineDash : defaultLineDash,
            lineDashOffset: strokeStyleLineDashOffset ?
              strokeStyleLineDashOffset : defaultLineDashOffset,
            lineJoin: strokeStyleLineJoin !== undefined ?
              strokeStyleLineJoin : defaultLineJoin,
            lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ?
              strokeStyleWidth : defaultLineWidth),
            miterLimit: strokeStyleMiterLimit !== undefined ?
              strokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(strokeStyleColor ?
              strokeStyleColor : defaultStrokeStyle)
          };
        }
      };

      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {module:ol/style/Image} imageStyle Image style.
       * @override
       */
      CanvasImmediateRenderer.prototype.setImageStyle = function setImageStyle (imageStyle) {
        if (!imageStyle) {
          this.image_ = null;
        } else {
          var imageAnchor = imageStyle.getAnchor();
          // FIXME pixel ratio
          var imageImage = imageStyle.getImage(1);
          var imageOrigin = imageStyle.getOrigin();
          var imageSize = imageStyle.getSize();
          this.imageAnchorX_ = imageAnchor[0];
          this.imageAnchorY_ = imageAnchor[1];
          this.imageHeight_ = imageSize[1];
          this.image_ = imageImage;
          this.imageOpacity_ = imageStyle.getOpacity();
          this.imageOriginX_ = imageOrigin[0];
          this.imageOriginY_ = imageOrigin[1];
          this.imageRotateWithView_ = imageStyle.getRotateWithView();
          this.imageRotation_ = imageStyle.getRotation();
          this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
          this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
          this.imageWidth_ = imageSize[0];
        }
      };

      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {module:ol/style/Text} textStyle Text style.
       * @override
       */
      CanvasImmediateRenderer.prototype.setTextStyle = function setTextStyle (textStyle) {
        if (!textStyle) {
          this.text_ = '';
        } else {
          var textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            this.textFillState_ = null;
          } else {
            var textFillStyleColor = textFillStyle.getColor();
            this.textFillState_ = {
              fillStyle: asColorLike(textFillStyleColor ?
                textFillStyleColor : defaultFillStyle)
            };
          }
          var textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            this.textStrokeState_ = null;
          } else {
            var textStrokeStyleColor = textStrokeStyle.getColor();
            var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
            var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            var textStrokeStyleWidth = textStrokeStyle.getWidth();
            var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            this.textStrokeState_ = {
              lineCap: textStrokeStyleLineCap !== undefined ?
                textStrokeStyleLineCap : defaultLineCap,
              lineDash: textStrokeStyleLineDash ?
                textStrokeStyleLineDash : defaultLineDash,
              lineDashOffset: textStrokeStyleLineDashOffset ?
                textStrokeStyleLineDashOffset : defaultLineDashOffset,
              lineJoin: textStrokeStyleLineJoin !== undefined ?
                textStrokeStyleLineJoin : defaultLineJoin,
              lineWidth: textStrokeStyleWidth !== undefined ?
                textStrokeStyleWidth : defaultLineWidth,
              miterLimit: textStrokeStyleMiterLimit !== undefined ?
                textStrokeStyleMiterLimit : defaultMiterLimit,
              strokeStyle: asColorLike(textStrokeStyleColor ?
                textStrokeStyleColor : defaultStrokeStyle)
            };
          }
          var textFont = textStyle.getFont();
          var textOffsetX = textStyle.getOffsetX();
          var textOffsetY = textStyle.getOffsetY();
          var textRotateWithView = textStyle.getRotateWithView();
          var textRotation = textStyle.getRotation();
          var textScale = textStyle.getScale();
          var textText = textStyle.getText();
          var textTextAlign = textStyle.getTextAlign();
          var textTextBaseline = textStyle.getTextBaseline();
          this.textState_ = {
            font: textFont !== undefined ?
              textFont : defaultFont,
            textAlign: textTextAlign !== undefined ?
              textTextAlign : defaultTextAlign,
            textBaseline: textTextBaseline !== undefined ?
              textTextBaseline : defaultTextBaseline
          };
          this.text_ = textText !== undefined ? textText : '';
          this.textOffsetX_ =
              textOffsetX !== undefined ? (this.pixelRatio_ * textOffsetX) : 0;
          this.textOffsetY_ =
              textOffsetY !== undefined ? (this.pixelRatio_ * textOffsetY) : 0;
          this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
          this.textRotation_ = textRotation !== undefined ? textRotation : 0;
          this.textScale_ = this.pixelRatio_ * (textScale !== undefined ?
            textScale : 1);
        }
      };

      return CanvasImmediateRenderer;
    }(VectorContext));

    /**
     * @module ol/style/IconImageCache
     */

    /**
     * @classdesc
     * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
     */
    var IconImageCache = function IconImageCache() {

      /**
      * @type {!Object.<string, module:ol/style/IconImage>}
      * @private
      */
      this.cache_ = {};

      /**
      * @type {number}
      * @private
      */
      this.cacheSize_ = 0;

      /**
      * @type {number}
      * @private
      */
      this.maxCacheSize_ = 32;
    };

    /**
    * FIXME empty description for jsdoc
    */
    IconImageCache.prototype.clear = function clear () {
      this.cache_ = {};
      this.cacheSize_ = 0;
    };

    /**
    * FIXME empty description for jsdoc
    */
    IconImageCache.prototype.expire = function expire () {
        var this$1 = this;

      if (this.cacheSize_ > this.maxCacheSize_) {
        var i = 0;
        for (var key in this$1.cache_) {
          var iconImage = this$1.cache_[key];
          if ((i++ & 3) === 0 && !iconImage.hasListener()) {
            delete this$1.cache_[key];
            --this$1.cacheSize_;
          }
        }
      }
    };

    /**
    * @param {string} src Src.
    * @param {?string} crossOrigin Cross origin.
    * @param {module:ol/color~Color} color Color.
    * @return {module:ol/style/IconImage} Icon image.
    */
    IconImageCache.prototype.get = function get (src, crossOrigin, color) {
      var key = getKey(src, crossOrigin, color);
      return key in this.cache_ ? this.cache_[key] : null;
    };

    /**
    * @param {string} src Src.
    * @param {?string} crossOrigin Cross origin.
    * @param {module:ol/color~Color} color Color.
    * @param {module:ol/style/IconImage} iconImage Icon image.
    */
    IconImageCache.prototype.set = function set (src, crossOrigin, color, iconImage) {
      var key = getKey(src, crossOrigin, color);
      this.cache_[key] = iconImage;
      ++this.cacheSize_;
    };

    /**
    * Set the cache size of the icon cache. Default is `32`. Change this value when
    * your map uses more than 32 different icon images and you are not caching icon
    * styles on the application level.
    * @param {number} maxCacheSize Cache max size.
    * @api
    */
    IconImageCache.prototype.setSize = function setSize (maxCacheSize) {
      this.maxCacheSize_ = maxCacheSize;
      this.expire();
    };


    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {module:ol/color~Color} color Color.
     * @return {string} Cache key.
     */
    function getKey(src, crossOrigin, color) {
      var colorString = color ? asString(color) : 'null';
      return crossOrigin + ':' + src + ':' + colorString;
    }


    /**
     * The {@link module:ol/style/IconImageCache~IconImageCache} for
     * {@link module:ol/style/Icon~Icon} images.
     * @api
     */
    var shared = new IconImageCache();

    /**
     * @module ol/renderer/Map
     */


    var MapRenderer = (function (Disposable$$1) {
      function MapRenderer(map) {
        Disposable$$1.call(this);

        /**
         * @private
         * @type {module:ol/PluggableMap}
         */
        this.map_ = map;

        /**
         * @private
         * @type {!Object.<string, module:ol/renderer/Layer>}
         */
        this.layerRenderers_ = {};

        /**
         * @private
         * @type {Object.<string, module:ol/events~EventsKey>}
         */
        this.layerRendererListeners_ = {};

        /**
         * @private
         * @type {Array.<module:ol/renderer/Layer>}
         */
        this.layerRendererConstructors_ = [];

      }

      if ( Disposable$$1 ) MapRenderer.__proto__ = Disposable$$1;
      MapRenderer.prototype = Object.create( Disposable$$1 && Disposable$$1.prototype );
      MapRenderer.prototype.constructor = MapRenderer;

      /**
       * Register layer renderer constructors.
       * @param {Array.<module:ol/renderer/Layer>} constructors Layer renderers.
       */
      MapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
        this.layerRendererConstructors_.push.apply(this.layerRendererConstructors_, constructors);
      };

      /**
       * Get the registered layer renderer constructors.
       * @return {Array.<module:ol/renderer/Layer>} Registered layer renderers.
       */
      MapRenderer.prototype.getLayerRendererConstructors = function getLayerRendererConstructors () {
        return this.layerRendererConstructors_;
      };

      /**
       * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
       * @protected
       */
      MapRenderer.prototype.calculateMatrices2D = function calculateMatrices2D (frameState) {
        var viewState = frameState.viewState;
        var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
        var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

        compose(coordinateToPixelTransform,
          frameState.size[0] / 2, frameState.size[1] / 2,
          1 / viewState.resolution, -1 / viewState.resolution,
          -viewState.rotation,
          -viewState.center[0], -viewState.center[1]);

        invert(
          setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
      };

      /**
       * Removes all layer renderers.
       */
      MapRenderer.prototype.removeLayerRenderers = function removeLayerRenderers () {
        var this$1 = this;

        for (var key in this$1.layerRenderers_) {
          this$1.removeLayerRendererByKey_(key).dispose();
        }
      };

      /**
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature),
       *     module:ol/layer/Layer): T} callback Feature callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      MapRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
        coordinate,
        frameState,
        hitTolerance,
        callback,
        thisArg,
        layerFilter,
        thisArg2
      ) {
        var this$1 = this;

        var result;
        var viewState = frameState.viewState;
        var viewResolution = viewState.resolution;

        /**
         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
         * @param {module:ol/layer/Layer} layer Layer.
         * @return {?} Callback result.
         */
        function forEachFeatureAtCoordinate(feature, layer) {
          var key = getUid(feature).toString();
          var managed = frameState.layerStates[getUid(layer)].managed;
          if (!(key in frameState.skippedFeatureUids && !managed)) {
            return callback.call(thisArg, feature, managed ? layer : null);
          }
        }

        var projection = viewState.projection;

        var translatedCoordinate = coordinate;
        if (projection.canWrapX()) {
          var projectionExtent = projection.getExtent();
          var worldWidth = getWidth(projectionExtent);
          var x = coordinate[0];
          if (x < projectionExtent[0] || x > projectionExtent[2]) {
            var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
            translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
          }
        }

        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;
        var i;
        for (i = numLayers - 1; i >= 0; --i) {
          var layerState = layerStates[i];
          var layer = layerState.layer;
          if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
            var layerRenderer = this$1.getLayerRenderer(layer);
            if (layer.getSource()) {
              result = layerRenderer.forEachFeatureAtCoordinate(
                layer.getSource().getWrapX() ? translatedCoordinate : coordinate,
                frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
            }
            if (result) {
              return result;
            }
          }
        }
        return undefined;
      };

      /**
       * @abstract
       * @param {module:ol/pixel~Pixel} pixel Pixel.
       * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      MapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {};

      /**
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(this: U, module:ol/layer/Layer): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
       * @return {boolean} Is there a feature at the given coordinate?
       * @template U
       */
      MapRenderer.prototype.hasFeatureAtCoordinate = function hasFeatureAtCoordinate (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
        var hasFeature = this.forEachFeatureAtCoordinate(
          coordinate, frameState, hitTolerance, TRUE, this, layerFilter, thisArg);

        return hasFeature !== undefined;
      };

      /**
       * @param {module:ol/layer/Layer} layer Layer.
       * @protected
       * @return {module:ol/renderer/Layer} Layer renderer.
       */
      MapRenderer.prototype.getLayerRenderer = function getLayerRenderer (layer) {
        var this$1 = this;

        var layerKey = getUid(layer).toString();
        if (layerKey in this.layerRenderers_) {
          return this.layerRenderers_[layerKey];
        } else {
          var renderer;
          for (var i = 0, ii = this.layerRendererConstructors_.length; i < ii; ++i) {
            var candidate = this$1.layerRendererConstructors_[i];
            if (candidate['handles'](layer)) {
              renderer = candidate['create'](this$1, layer);
              break;
            }
          }
          if (renderer) {
            this.layerRenderers_[layerKey] = renderer;
            this.layerRendererListeners_[layerKey] = listen(renderer,
              EventType.CHANGE, this.handleLayerRendererChange_, this);
          } else {
            throw new Error('Unable to create renderer for layer: ' + layer.getType());
          }
          return renderer;
        }
      };

      /**
       * @param {string} layerKey Layer key.
       * @protected
       * @return {module:ol/renderer/Layer} Layer renderer.
       */
      MapRenderer.prototype.getLayerRendererByKey = function getLayerRendererByKey (layerKey) {
        return this.layerRenderers_[layerKey];
      };

      /**
       * @protected
       * @return {Object.<string, module:ol/renderer/Layer>} Layer renderers.
       */
      MapRenderer.prototype.getLayerRenderers = function getLayerRenderers () {
        return this.layerRenderers_;
      };

      /**
       * @return {module:ol/PluggableMap} Map.
       */
      MapRenderer.prototype.getMap = function getMap () {
        return this.map_;
      };

      /**
       * Handle changes in a layer renderer.
       * @private
       */
      MapRenderer.prototype.handleLayerRendererChange_ = function handleLayerRendererChange_ () {
        this.map_.render();
      };

      /**
       * @param {string} layerKey Layer key.
       * @return {module:ol/renderer/Layer} Layer renderer.
       * @private
       */
      MapRenderer.prototype.removeLayerRendererByKey_ = function removeLayerRendererByKey_ (layerKey) {
        var layerRenderer = this.layerRenderers_[layerKey];
        delete this.layerRenderers_[layerKey];

        unlistenByKey(this.layerRendererListeners_[layerKey]);
        delete this.layerRendererListeners_[layerKey];

        return layerRenderer;
      };

      /**
       * @param {module:ol/PluggableMap} map Map.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @private
       */
      MapRenderer.prototype.removeUnusedLayerRenderers_ = function removeUnusedLayerRenderers_ (map, frameState) {
        var this$1 = this;

        for (var layerKey in this$1.layerRenderers_) {
          if (!frameState || !(layerKey in frameState.layerStates)) {
            this$1.removeLayerRendererByKey_(layerKey).dispose();
          }
        }
      };

      /**
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @protected
       */
      MapRenderer.prototype.scheduleExpireIconCache = function scheduleExpireIconCache (frameState) {
        frameState.postRenderFunctions.push(/** @type {module:ol/PluggableMap~PostRenderFunction} */ (expireIconCache));
      };

      /**
       * @param {!module:ol/PluggableMap~FrameState} frameState Frame state.
       * @protected
       */
      MapRenderer.prototype.scheduleRemoveUnusedLayerRenderers = function scheduleRemoveUnusedLayerRenderers (frameState) {
        var this$1 = this;

        for (var layerKey in this$1.layerRenderers_) {
          if (!(layerKey in frameState.layerStates)) {
            frameState.postRenderFunctions.push(
              /** @type {module:ol/PluggableMap~PostRenderFunction} */ (this$1.removeUnusedLayerRenderers_.bind(this$1))
            );
            return;
          }
        }
      };

      return MapRenderer;
    }(Disposable));


    /**
     * @param {module:ol/PluggableMap} map Map.
     * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
     */
    function expireIconCache(map, frameState) {
      shared.expire();
    }


    /**
     * Render.
     * @param {?module:ol/PluggableMap~FrameState} frameState Frame state.
     */
    MapRenderer.prototype.renderFrame = UNDEFINED;


    /**
     * @param {module:ol/layer/Layer~State} state1 First layer state.
     * @param {module:ol/layer/Layer~State} state2 Second layer state.
     * @return {number} The zIndex difference.
     */
    function sortByZIndex(state1, state2) {
      return state1.zIndex - state2.zIndex;
    }

    /**
     * @module ol/renderer/canvas/Map
     */


    /**
     * @type {Array.<module:ol/renderer/Layer>}
     */
    var layerRendererConstructors = [];

    /**
     * @classdesc
     * Canvas map renderer.
     * @api
     */
    var CanvasMapRenderer = (function (MapRenderer$$1) {
      function CanvasMapRenderer(map) {
        MapRenderer$$1.call(this, map);

        var container = map.getViewport();

        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        this.context_ = createCanvasContext2D();

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.canvas_ = this.context_.canvas;

        this.canvas_.style.width = '100%';
        this.canvas_.style.height = '100%';
        this.canvas_.style.display = 'block';
        this.canvas_.className = CLASS_UNSELECTABLE;
        container.insertBefore(this.canvas_, container.childNodes[0] || null);

        /**
         * @private
         * @type {boolean}
         */
        this.renderedVisible_ = true;

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.transform_ = create();

      }

      if ( MapRenderer$$1 ) CanvasMapRenderer.__proto__ = MapRenderer$$1;
      CanvasMapRenderer.prototype = Object.create( MapRenderer$$1 && MapRenderer$$1.prototype );
      CanvasMapRenderer.prototype.constructor = CanvasMapRenderer;

      /**
       * @param {module:ol/render/EventType} type Event type.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @private
       */
      CanvasMapRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, frameState) {
        var map = this.getMap();
        var context = this.context_;
        if (map.hasListener(type)) {
          var extent = frameState.extent;
          var pixelRatio = frameState.pixelRatio;
          var viewState = frameState.viewState;
          var rotation = viewState.rotation;

          var transform = this.getTransform(frameState);

          var vectorContext = new CanvasImmediateRenderer(context, pixelRatio,
            extent, transform, rotation);
          var composeEvent = new RenderEvent(type, vectorContext,
            frameState, context, null);
          map.dispatchEvent(composeEvent);
        }
      };

      /**
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @protected
       * @return {!module:ol/transform~Transform} Transform.
       */
      CanvasMapRenderer.prototype.getTransform = function getTransform (frameState) {
        var viewState = frameState.viewState;
        var dx1 = this.canvas_.width / 2;
        var dy1 = this.canvas_.height / 2;
        var sx = frameState.pixelRatio / viewState.resolution;
        var sy = -sx;
        var angle = -viewState.rotation;
        var dx2 = -viewState.center[0];
        var dy2 = -viewState.center[1];
        return compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
      };

      /**
       * @inheritDoc
       */
      CanvasMapRenderer.prototype.renderFrame = function renderFrame (frameState) {
        var this$1 = this;


        if (!frameState) {
          if (this.renderedVisible_) {
            this.canvas_.style.display = 'none';
            this.renderedVisible_ = false;
          }
          return;
        }

        var context = this.context_;
        var pixelRatio = frameState.pixelRatio;
        var width = Math.round(frameState.size[0] * pixelRatio);
        var height = Math.round(frameState.size[1] * pixelRatio);
        if (this.canvas_.width != width || this.canvas_.height != height) {
          this.canvas_.width = width;
          this.canvas_.height = height;
        } else {
          context.clearRect(0, 0, width, height);
        }

        var rotation = frameState.viewState.rotation;

        this.calculateMatrices2D(frameState);

        this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, frameState);

        var layerStatesArray = frameState.layerStatesArray;
        stableSort(layerStatesArray, sortByZIndex);

        if (rotation) {
          context.save();
          rotateAtOffset(context, rotation, width / 2, height / 2);
        }

        var viewResolution = frameState.viewState.resolution;
        var i, ii, layer, layerRenderer, layerState;
        for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
          layerState = layerStatesArray[i];
          layer = layerState.layer;
          layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this$1.getLayerRenderer(layer));
          if (!visibleAtResolution(layerState, viewResolution) ||
              layerState.sourceState != SourceState.READY) {
            continue;
          }
          if (layerRenderer.prepareFrame(frameState, layerState)) {
            layerRenderer.composeFrame(frameState, layerState, context);
          }
        }

        if (rotation) {
          context.restore();
        }

        this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, frameState);

        if (!this.renderedVisible_) {
          this.canvas_.style.display = '';
          this.renderedVisible_ = true;
        }

        this.scheduleRemoveUnusedLayerRenderers(frameState);
        this.scheduleExpireIconCache(frameState);
      };

      /**
       * @inheritDoc
       */
      CanvasMapRenderer.prototype.forEachLayerAtPixel = function forEachLayerAtPixel (pixel, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
        var this$1 = this;

        var result;
        var viewState = frameState.viewState;
        var viewResolution = viewState.resolution;

        var layerStates = frameState.layerStatesArray;
        var numLayers = layerStates.length;

        var coordinate = apply(
          frameState.pixelToCoordinateTransform, pixel.slice());

        var i;
        for (i = numLayers - 1; i >= 0; --i) {
          var layerState = layerStates[i];
          var layer = layerState.layer;
          if (visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
            var layerRenderer = /** @type {module:ol/renderer/canvas/Layer} */ (this$1.getLayerRenderer(layer));
            result = layerRenderer.forEachLayerAtCoordinate(
              coordinate, frameState, hitTolerance, callback, thisArg);
            if (result) {
              return result;
            }
          }
        }
        return undefined;
      };

      /**
       * @inheritDoc
       */
      CanvasMapRenderer.prototype.registerLayerRenderers = function registerLayerRenderers (constructors) {
        MapRenderer$$1.prototype.registerLayerRenderers.call(this, constructors);
        for (var i = 0, ii = constructors.length; i < ii; ++i) {
          var ctor = constructors[i];
          if (!includes(layerRendererConstructors, ctor)) {
            layerRendererConstructors.push(ctor);
          }
        }
      };

      return CanvasMapRenderer;
    }(MapRenderer));

    /**
     * @module ol/renderer/Layer
     */

    var LayerRenderer = (function (Observable$$1) {
      function LayerRenderer(layer) {

        Observable$$1.call(this);

        /**
         * @private
         * @type {module:ol/layer/Layer}
         */
        this.layer_ = layer;

      }

      if ( Observable$$1 ) LayerRenderer.__proto__ = Observable$$1;
      LayerRenderer.prototype = Object.create( Observable$$1 && Observable$$1.prototype );
      LayerRenderer.prototype.constructor = LayerRenderer;

      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {module:ol/source/Tile} source Tile source.
       * @param {module:ol/proj/Projection} projection Projection of the tiles.
       * @param {Object.<number, Object.<string, module:ol/Tile>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, module:ol/TileRange):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      LayerRenderer.prototype.createLoadedTileFinder = function createLoadedTileFinder (source, projection, tiles) {
        return (
          /**
           * @param {number} zoom Zoom level.
           * @param {module:ol/TileRange} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           */
          function(zoom, tileRange) {
            function callback(tile) {
              if (!tiles[zoom]) {
                tiles[zoom] = {};
              }
              tiles[zoom][tile.tileCoord.toString()] = tile;
            }
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }
        );
      };

      /**
       * @return {module:ol/layer/Layer} Layer.
       */
      LayerRenderer.prototype.getLayer = function getLayer () {
        return this.layer_;
      };

      /**
       * Handle changes in image state.
       * @param {module:ol/events/Event} event Image change event.
       * @private
       */
      LayerRenderer.prototype.handleImageChange_ = function handleImageChange_ (event) {
        var image = /** @type {module:ol/Image} */ (event.target);
        if (image.getState() === ImageState.LOADED) {
          this.renderIfReadyAndVisible();
        }
      };

      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {module:ol/ImageBase} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      LayerRenderer.prototype.loadImage = function loadImage (image) {
        var imageState = image.getState();
        if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
          listen(image, EventType.CHANGE, this.handleImageChange_, this);
        }
        if (imageState == ImageState.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState.LOADED;
      };

      /**
       * @protected
       */
      LayerRenderer.prototype.renderIfReadyAndVisible = function renderIfReadyAndVisible () {
        var layer = this.getLayer();
        if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
          this.changed();
        }
      };

      /**
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/source/Tile} tileSource Tile source.
       * @protected
       */
      LayerRenderer.prototype.scheduleExpireCache = function scheduleExpireCache (frameState, tileSource) {
        if (tileSource.canExpireCache()) {
          /**
           * @param {module:ol/source/Tile} tileSource Tile source.
           * @param {module:ol/PluggableMap} map Map.
           * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
           */
          var postRenderFunction = function(tileSource, map, frameState) {
            var tileSourceKey = getUid(tileSource).toString();
            if (tileSourceKey in frameState.usedTiles) {
              tileSource.expireCache(frameState.viewState.projection,
                frameState.usedTiles[tileSourceKey]);
            }
          }.bind(null, tileSource);

          frameState.postRenderFunctions.push(
            /** @type {module:ol/PluggableMap~PostRenderFunction} */ (postRenderFunction)
          );
        }
      };

      /**
       * @param {!Object.<string, !Object.<string, module:ol/TileRange>>} usedTiles Used tiles.
       * @param {module:ol/source/Tile} tileSource Tile source.
       * @param {number} z Z.
       * @param {module:ol/TileRange} tileRange Tile range.
       * @protected
       */
      LayerRenderer.prototype.updateUsedTiles = function updateUsedTiles (usedTiles, tileSource, z, tileRange) {
        // FIXME should we use tilesToDrawByZ instead?
        var tileSourceKey = getUid(tileSource).toString();
        var zKey = z.toString();
        if (tileSourceKey in usedTiles) {
          if (zKey in usedTiles[tileSourceKey]) {
            usedTiles[tileSourceKey][zKey].extend(tileRange);
          } else {
            usedTiles[tileSourceKey][zKey] = tileRange;
          }
        } else {
          usedTiles[tileSourceKey] = {};
          usedTiles[tileSourceKey][zKey] = tileRange;
        }
      };

      /**
       * Manage tile pyramid.
       * This function performs a number of functions related to the tiles at the
       * current zoom and lower zoom levels:
       * - registers idle tiles in frameState.wantedTiles so that they are not
       *   discarded by the tile queue
       * - enqueues missing tiles
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/source/Tile} tileSource Tile source.
       * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @param {module:ol/extent~Extent} extent Extent.
       * @param {number} currentZ Current Z.
       * @param {number} preload Load low resolution tiles up to 'preload' levels.
       * @param {function(this: T, module:ol/Tile)=} opt_tileCallback Tile callback.
       * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
       * @protected
       * @template T
       */
      LayerRenderer.prototype.manageTilePyramid = function manageTilePyramid (
        frameState,
        tileSource,
        tileGrid,
        pixelRatio,
        projection,
        extent,
        currentZ,
        preload,
        opt_tileCallback,
        opt_this
      ) {
        var tileSourceKey = getUid(tileSource).toString();
        if (!(tileSourceKey in frameState.wantedTiles)) {
          frameState.wantedTiles[tileSourceKey] = {};
        }
        var wantedTiles = frameState.wantedTiles[tileSourceKey];
        var tileQueue = frameState.tileQueue;
        var minZoom = tileGrid.getMinZoom();
        var tile, tileRange, tileResolution, x, y, z;
        for (z = minZoom; z <= currentZ; ++z) {
          tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
          tileResolution = tileGrid.getResolution(z);
          for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
            for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
              if (currentZ - z <= preload) {
                tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                if (tile.getState() == TileState.IDLE) {
                  wantedTiles[tile.getKey()] = true;
                  if (!tileQueue.isKeyQueued(tile.getKey())) {
                    tileQueue.enqueue([tile, tileSourceKey,
                      tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
                  }
                }
                if (opt_tileCallback !== undefined) {
                  opt_tileCallback.call(opt_this, tile);
                }
              } else {
                tileSource.useTile(z, x, y, projection);
              }
            }
          }
        }
      };

      return LayerRenderer;
    }(Observable));


    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(this: S, (module:ol/Feature|module:ol/render/Feature), module:ol/layer/Layer): T}
     *     callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @return {T|undefined} Callback result.
     * @template S,T
     */
    LayerRenderer.prototype.forEachFeatureAtCoordinate = UNDEFINED;


    /**
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
     * @return {boolean} Is there a feature at the given coordinate?
     */
    LayerRenderer.prototype.hasFeatureAtCoordinate = FALSE;

    /**
     * @module ol/renderer/canvas/Layer
     */

    var CanvasLayerRenderer = (function (LayerRenderer$$1) {
      function CanvasLayerRenderer(layer) {

        LayerRenderer$$1.call(this, layer);

        /**
         * @protected
         * @type {number}
         */
        this.renderedResolution;

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.transform_ = create();

      }

      if ( LayerRenderer$$1 ) CanvasLayerRenderer.__proto__ = LayerRenderer$$1;
      CanvasLayerRenderer.prototype = Object.create( LayerRenderer$$1 && LayerRenderer$$1.prototype );
      CanvasLayerRenderer.prototype.constructor = CanvasLayerRenderer;

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/extent~Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clip = function clip (context, frameState, extent) {
        var pixelRatio = frameState.pixelRatio;
        var width = frameState.size[0] * pixelRatio;
        var height = frameState.size[1] * pixelRatio;
        var rotation = frameState.viewState.rotation;
        var topLeft = getTopLeft(/** @type {module:ol/extent~Extent} */ (extent));
        var topRight = getTopRight(/** @type {module:ol/extent~Extent} */ (extent));
        var bottomRight = getBottomRight(/** @type {module:ol/extent~Extent} */ (extent));
        var bottomLeft = getBottomLeft(/** @type {module:ol/extent~Extent} */ (extent));

        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);

        context.save();
        rotateAtOffset(context, -rotation, width / 2, height / 2);
        context.beginPath();
        context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
        context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
        context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
        context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
        context.clip();
        rotateAtOffset(context, rotation, width / 2, height / 2);
      };

      /**
       * @param {module:ol/render/EventType} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/transform~Transform=} opt_transform Transform.
       * @private
       */
      CanvasLayerRenderer.prototype.dispatchComposeEvent_ = function dispatchComposeEvent_ (type, context, frameState, opt_transform) {
        var layer = this.getLayer();
        if (layer.hasListener(type)) {
          var width = frameState.size[0] * frameState.pixelRatio;
          var height = frameState.size[1] * frameState.pixelRatio;
          var rotation = frameState.viewState.rotation;
          rotateAtOffset(context, -rotation, width / 2, height / 2);
          var transform = opt_transform !== undefined ?
            opt_transform : this.getTransform(frameState, 0);
          var render = new CanvasImmediateRenderer(
            context, frameState.pixelRatio, frameState.extent, transform,
            frameState.viewState.rotation);
          var composeEvent = new RenderEvent(type, render, frameState,
            context, null);
          layer.dispatchEvent(composeEvent);
          rotateAtOffset(context, rotation, width / 2, height / 2);
        }
      };

      /**
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {module:ol/PluggableMap~FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(this: S, module:ol/layer/Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      CanvasLayerRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, TRUE, this);

        if (hasFeature) {
          return callback.call(thisArg, this.getLayer(), null);
        } else {
          return undefined;
        }
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/layer/Layer~State} layerState Layer state.
       * @param {module:ol/transform~Transform=} opt_transform Transform.
       * @protected
       */
      CanvasLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState, opt_transform) {
        this.dispatchComposeEvent_(RenderEventType.POSTCOMPOSE, context, frameState, opt_transform);
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/transform~Transform=} opt_transform Transform.
       * @protected
       */
      CanvasLayerRenderer.prototype.preCompose = function preCompose (context, frameState, opt_transform) {
        this.dispatchComposeEvent_(RenderEventType.PRECOMPOSE, context, frameState, opt_transform);
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/transform~Transform=} opt_transform Transform.
       * @protected
       */
      CanvasLayerRenderer.prototype.dispatchRenderEvent = function dispatchRenderEvent (context, frameState, opt_transform) {
        this.dispatchComposeEvent_(RenderEventType.RENDER, context, frameState, opt_transform);
      };

      /**
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!module:ol/transform~Transform} Transform.
       */
      CanvasLayerRenderer.prototype.getTransform = function getTransform (frameState, offsetX) {
        var viewState = frameState.viewState;
        var pixelRatio = frameState.pixelRatio;
        var dx1 = pixelRatio * frameState.size[0] / 2;
        var dy1 = pixelRatio * frameState.size[1] / 2;
        var sx = pixelRatio / viewState.resolution;
        var sy = -sx;
        var angle = -viewState.rotation;
        var dx2 = -viewState.center[0] + offsetX;
        var dy2 = -viewState.center[1];
        return compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
      };

      /**
       * @abstract
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/layer/Layer~State} layerState Layer state.
       * @param {CanvasRenderingContext2D} context Context.
       */
      CanvasLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {};

      /**
       * @abstract
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/layer/Layer~State} layerState Layer state.
       * @return {boolean} whether composeFrame should be called.
       */
      CanvasLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {};

      return CanvasLayerRenderer;
    }(LayerRenderer));

    /**
     * @module ol/renderer/canvas/IntermediateCanvas
     */

    var IntermediateCanvasRenderer = (function (CanvasLayerRenderer$$1) {
      function IntermediateCanvasRenderer(layer) {

        CanvasLayerRenderer$$1.call(this, layer);

        /**
         * @protected
         * @type {module:ol/transform~Transform}
         */
        this.coordinateToCanvasPixelTransform = create();

        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        this.hitCanvasContext_ = null;

      }

      if ( CanvasLayerRenderer$$1 ) IntermediateCanvasRenderer.__proto__ = CanvasLayerRenderer$$1;
      IntermediateCanvasRenderer.prototype = Object.create( CanvasLayerRenderer$$1 && CanvasLayerRenderer$$1.prototype );
      IntermediateCanvasRenderer.prototype.constructor = IntermediateCanvasRenderer;

      /**
       * @inheritDoc
       */
      IntermediateCanvasRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {

        this.preCompose(context, frameState);

        var image = this.getImage();
        if (image) {

          // clipped rendering if layer extent is set
          var extent = layerState.extent;
          var clipped = extent !== undefined &&
              !containsExtent(extent, frameState.extent) &&
              intersects(extent, frameState.extent);
          if (clipped) {
            this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (extent));
          }

          var imageTransform = this.getImageTransform();
          // for performance reasons, context.save / context.restore is not used
          // to save and restore the transformation matrix and the opacity.
          // see http://jsperf.com/context-save-restore-versus-variable
          var alpha = context.globalAlpha;
          context.globalAlpha = layerState.opacity;

          // for performance reasons, context.setTransform is only used
          // when the view is rotated. see http://jsperf.com/canvas-transform
          var dx = imageTransform[4];
          var dy = imageTransform[5];
          var dw = image.width * imageTransform[0];
          var dh = image.height * imageTransform[3];
          context.drawImage(image, 0, 0, +image.width, +image.height,
            Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
          context.globalAlpha = alpha;

          if (clipped) {
            context.restore();
          }
        }

        this.postCompose(context, frameState, layerState);
      };

      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Canvas.
       */
      IntermediateCanvasRenderer.prototype.getImage = function getImage () {};

      /**
       * @abstract
       * @return {!module:ol/transform~Transform} Image transform.
       */
      IntermediateCanvasRenderer.prototype.getImageTransform = function getImageTransform () {};

      /**
       * @inheritDoc
       */
      IntermediateCanvasRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        var layer = this.getLayer();
        var source = layer.getSource();
        var resolution = frameState.viewState.resolution;
        var rotation = frameState.viewState.rotation;
        var skippedFeatureUids = frameState.skippedFeatureUids;
        return source.forEachFeatureAtCoordinate(
          coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
          /**
           * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
           * @return {?} Callback result.
           */
          function(feature) {
            return callback.call(thisArg, feature, layer);
          });
      };

      /**
       * @inheritDoc
       */
      IntermediateCanvasRenderer.prototype.forEachLayerAtCoordinate = function forEachLayerAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        if (!this.getImage()) {
          return undefined;
        }

        if (this.getLayer().getSource().forEachFeatureAtCoordinate !== UNDEFINED) {
          // for ImageCanvas sources use the original hit-detection logic,
          // so that for example also transparent polygons are detected
          return CanvasLayerRenderer$$1.prototype.forEachLayerAtCoordinate.apply(this, arguments);
        } else {
          var pixel = apply(this.coordinateToCanvasPixelTransform, coordinate.slice());
          scale(pixel, frameState.viewState.resolution / this.renderedResolution);

          if (!this.hitCanvasContext_) {
            this.hitCanvasContext_ = createCanvasContext2D(1, 1);
          }

          this.hitCanvasContext_.clearRect(0, 0, 1, 1);
          this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

          var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
          if (imageData[3] > 0) {
            return callback.call(thisArg, this.getLayer(), imageData);
          } else {
            return undefined;
          }
        }
      };

      return IntermediateCanvasRenderer;
    }(CanvasLayerRenderer));

    /**
     * @module ol/renderer/canvas/ImageLayer
     */

    /**
     * @classdesc
     * Canvas renderer for image layers.
     * @api
     */
    var CanvasImageLayerRenderer = (function (IntermediateCanvasRenderer$$1) {
      function CanvasImageLayerRenderer(imageLayer) {
        var this$1 = this;


        IntermediateCanvasRenderer$$1.call(this, imageLayer);

        /**
         * @private
         * @type {?module:ol/ImageBase}
         */
        this.image_ = null;

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.imageTransform_ = create();

        /**
         * @type {!Array.<string>}
         */
        this.skippedFeatures_ = [];

        /**
         * @private
         * @type {module:ol/renderer/canvas/VectorLayer}
         */
        this.vectorRenderer_ = null;

        if (imageLayer.getType() === LayerType.VECTOR) {
          for (var i = 0, ii = layerRendererConstructors.length; i < ii; ++i) {
            var ctor = layerRendererConstructors[i];
            if (ctor !== CanvasImageLayerRenderer && ctor['handles'](imageLayer)) {
              this$1.vectorRenderer_ = new ctor(imageLayer);
              break;
            }
          }
        }

      }

      if ( IntermediateCanvasRenderer$$1 ) CanvasImageLayerRenderer.__proto__ = IntermediateCanvasRenderer$$1;
      CanvasImageLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer$$1 && IntermediateCanvasRenderer$$1.prototype );
      CanvasImageLayerRenderer.prototype.constructor = CanvasImageLayerRenderer;

      /**
       * @inheritDoc
       */
      CanvasImageLayerRenderer.prototype.disposeInternal = function disposeInternal () {
        if (this.vectorRenderer_) {
          this.vectorRenderer_.dispose();
        }
        IntermediateCanvasRenderer$$1.prototype.disposeInternal.call(this);
      };

      /**
       * @inheritDoc
       */
      CanvasImageLayerRenderer.prototype.getImage = function getImage () {
        return !this.image_ ? null : this.image_.getImage();
      };

      /**
       * @inheritDoc
       */
      CanvasImageLayerRenderer.prototype.getImageTransform = function getImageTransform () {
        return this.imageTransform_;
      };

      /**
       * @inheritDoc
       */
      CanvasImageLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {

        var pixelRatio = frameState.pixelRatio;
        var size = frameState.size;
        var viewState = frameState.viewState;
        var viewCenter = viewState.center;
        var viewResolution = viewState.resolution;

        var image;
        var imageLayer = /** @type {module:ol/layer/Image} */ (this.getLayer());
        var imageSource = imageLayer.getSource();

        var hints = frameState.viewHints;

        var vectorRenderer = this.vectorRenderer_;
        var renderedExtent = frameState.extent;
        if (!vectorRenderer && layerState.extent !== undefined) {
          renderedExtent = getIntersection(renderedExtent, layerState.extent);
        }

        if (!hints[ViewHint.ANIMATING] && !hints[ViewHint.INTERACTING] &&
            !isEmpty$1(renderedExtent)) {
          var projection = viewState.projection;
          var skippedFeatures = this.skippedFeatures_;
          if (vectorRenderer) {
            var context = vectorRenderer.context;
            var imageFrameState = /** @type {module:ol/PluggableMap~FrameState} */ (assign({}, frameState, {
              size: [
                getWidth(renderedExtent) / viewResolution,
                getHeight(renderedExtent) / viewResolution
              ],
              viewState: /** @type {module:ol/View~State} */ (assign({}, frameState.viewState, {
                rotation: 0
              }))
            }));
            var newSkippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
            image = new ImageCanvas(renderedExtent, viewResolution, pixelRatio, context.canvas, function(callback) {
              if (vectorRenderer.prepareFrame(imageFrameState, layerState) &&
                  (vectorRenderer.replayGroupChanged ||
                  !equals(skippedFeatures, newSkippedFeatures))) {
                context.canvas.width = imageFrameState.size[0] * pixelRatio;
                context.canvas.height = imageFrameState.size[1] * pixelRatio;
                vectorRenderer.compose(context, imageFrameState, layerState);
                skippedFeatures = newSkippedFeatures;
                callback();
              }
            });
          } else {
            image = imageSource.getImage(
              renderedExtent, viewResolution, pixelRatio, projection);
          }
          if (image && this.loadImage(image)) {
            this.image_ = image;
            this.skippedFeatures_ = skippedFeatures;
          }
        }

        if (this.image_) {
          image = this.image_;
          var imageExtent = image.getExtent();
          var imageResolution = image.getResolution();
          var imagePixelRatio = image.getPixelRatio();
          var scale = pixelRatio * imageResolution /
              (viewResolution * imagePixelRatio);
          var transform = compose(this.imageTransform_,
            pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
            scale, scale,
            0,
            imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution,
            imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
          compose(this.coordinateToCanvasPixelTransform,
            pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
            pixelRatio / viewResolution, -pixelRatio / viewResolution,
            0,
            -viewCenter[0], -viewCenter[1]);

          this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
        }

        return !!this.image_;
      };

      /**
       * @inheritDoc
       */
      CanvasImageLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        if (this.vectorRenderer_) {
          return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
        } else {
          return IntermediateCanvasRenderer$$1.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
        }
      };

      return CanvasImageLayerRenderer;
    }(IntermediateCanvasRenderer));


    /**
     * Determine if this renderer handles the provided layer.
     * @param {module:ol/layer/Layer} layer The candidate layer.
     * @return {boolean} The renderer can render the layer.
     */
    CanvasImageLayerRenderer['handles'] = function(layer) {
      return layer.getType() === LayerType.IMAGE ||
        layer.getType() === LayerType.VECTOR &&
        /** @type {module:ol/layer/Vector} */ (layer).getRenderMode() === VectorRenderType.IMAGE;
    };


    /**
     * Create a layer renderer.
     * @param {module:ol/renderer/Map} mapRenderer The map renderer.
     * @param {module:ol/layer/Layer} layer The layer to be rendererd.
     * @return {module:ol/renderer/canvas/ImageLayer} The layer renderer.
     */
    CanvasImageLayerRenderer['create'] = function(mapRenderer, layer) {
      return new CanvasImageLayerRenderer(/** @type {module:ol/layer/Image} */ (layer));
    };

    /**
     * @module ol/TileRange
     */

    /**
     * A representation of a contiguous block of tiles.  A tile range is specified
     * by its min/max tile coordinates and is inclusive of coordinates.
     */
    var TileRange = function TileRange(minX, maxX, minY, maxY) {

      /**
       * @type {number}
       */
      this.minX = minX;

      /**
       * @type {number}
       */
      this.maxX = maxX;

      /**
       * @type {number}
       */
      this.minY = minY;

      /**
       * @type {number}
       */
      this.maxY = maxY;

    };

    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @return {boolean} Contains tile coordinate.
     */
    TileRange.prototype.contains = function contains (tileCoord) {
      return this.containsXY(tileCoord[1], tileCoord[2]);
    };

    /**
     * @param {module:ol/TileRange} tileRange Tile range.
     * @return {boolean} Contains.
     */
    TileRange.prototype.containsTileRange = function containsTileRange (tileRange) {
      return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX &&
         this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
    };

    /**
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @return {boolean} Contains coordinate.
     */
    TileRange.prototype.containsXY = function containsXY (x, y) {
      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
    };

    /**
     * @param {module:ol/TileRange} tileRange Tile range.
     * @return {boolean} Equals.
     */
    TileRange.prototype.equals = function equals (tileRange) {
      return this.minX == tileRange.minX && this.minY == tileRange.minY &&
         this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
    };

    /**
     * @param {module:ol/TileRange} tileRange Tile range.
     */
    TileRange.prototype.extend = function extend (tileRange) {
      if (tileRange.minX < this.minX) {
        this.minX = tileRange.minX;
      }
      if (tileRange.maxX > this.maxX) {
        this.maxX = tileRange.maxX;
      }
      if (tileRange.minY < this.minY) {
        this.minY = tileRange.minY;
      }
      if (tileRange.maxY > this.maxY) {
        this.maxY = tileRange.maxY;
      }
    };

    /**
    * @return {number} Height.
    */
    TileRange.prototype.getHeight = function getHeight () {
      return this.maxY - this.minY + 1;
    };

    /**
    * @return {module:ol/size~Size} Size.
    */
    TileRange.prototype.getSize = function getSize () {
      return [this.getWidth(), this.getHeight()];
    };

    /**
    * @return {number} Width.
    */
    TileRange.prototype.getWidth = function getWidth () {
      return this.maxX - this.minX + 1;
    };

    /**
    * @param {module:ol/TileRange} tileRange Tile range.
    * @return {boolean} Intersects.
    */
    TileRange.prototype.intersects = function intersects (tileRange) {
      return this.minX <= tileRange.maxX &&
         this.maxX >= tileRange.minX &&
         this.minY <= tileRange.maxY &&
         this.maxY >= tileRange.minY;
    };


    /**
     * @param {number} minX Minimum X.
     * @param {number} maxX Maximum X.
     * @param {number} minY Minimum Y.
     * @param {number} maxY Maximum Y.
     * @param {module:ol/TileRange=} tileRange TileRange.
     * @return {module:ol/TileRange} Tile range.
     */
    function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
      if (tileRange !== undefined) {
        tileRange.minX = minX;
        tileRange.maxX = maxX;
        tileRange.minY = minY;
        tileRange.maxY = maxY;
        return tileRange;
      } else {
        return new TileRange(minX, maxX, minY, maxY);
      }
    }

    /**
     * @module ol/renderer/canvas/TileLayer
     */

    /**
     * @classdesc
     * Canvas renderer for tile layers.
     * @api
     */
    var CanvasTileLayerRenderer = (function (IntermediateCanvasRenderer$$1) {
      function CanvasTileLayerRenderer(tileLayer, opt_noContext) {

        IntermediateCanvasRenderer$$1.call(this, tileLayer);

        /**
         * @protected
         * @type {CanvasRenderingContext2D}
         */
        this.context = opt_noContext ? null : createCanvasContext2D();

        /**
         * @private
         * @type {number}
         */
        this.oversampling_;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.renderedExtent_ = null;

        /**
         * @protected
         * @type {number}
         */
        this.renderedRevision;

        /**
         * @protected
         * @type {!Array.<module:ol/Tile>}
         */
        this.renderedTiles = [];

        /**
         * @private
         * @type {boolean}
         */
        this.newTiles_ = false;

        /**
         * @protected
         * @type {module:ol/extent~Extent}
         */
        this.tmpExtent = createEmpty();

        /**
         * @private
         * @type {module:ol/TileRange}
         */
        this.tmpTileRange_ = new TileRange(0, 0, 0, 0);

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.imageTransform_ = create();

        /**
         * @protected
         * @type {number}
         */
        this.zDirection = 0;

      }

      if ( IntermediateCanvasRenderer$$1 ) CanvasTileLayerRenderer.__proto__ = IntermediateCanvasRenderer$$1;
      CanvasTileLayerRenderer.prototype = Object.create( IntermediateCanvasRenderer$$1 && IntermediateCanvasRenderer$$1.prototype );
      CanvasTileLayerRenderer.prototype.constructor = CanvasTileLayerRenderer;

      /**
       * @private
       * @param {module:ol/Tile} tile Tile.
       * @return {boolean} Tile is drawable.
       */
      CanvasTileLayerRenderer.prototype.isDrawableTile_ = function isDrawableTile_ (tile) {
        var tileState = tile.getState();
        var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
        return tileState == TileState.LOADED ||
            tileState == TileState.EMPTY ||
            tileState == TileState.ERROR && !useInterimTilesOnError;
      };

      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {!module:ol/Tile} Tile.
       */
      CanvasTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
        var layer = this.getLayer();
        var source = /** @type {module:ol/source/Tile} */ (layer.getSource());
        var tile = source.getTile(z, x, y, pixelRatio, projection);
        if (tile.getState() == TileState.ERROR) {
          if (!layer.getUseInterimTilesOnError()) {
            // When useInterimTilesOnError is false, we consider the error tile as loaded.
            tile.setState(TileState.LOADED);
          } else if (layer.getPreload() > 0) {
            // Preloaded tiles for lower resolutions might have finished loading.
            this.newTiles_ = true;
          }
        }
        if (!this.isDrawableTile_(tile)) {
          tile = tile.getInterimTile();
        }
        return tile;
      };

      /**
       * @inheritDoc
       */
      CanvasTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
        var this$1 = this;


        var pixelRatio = frameState.pixelRatio;
        var size = frameState.size;
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var viewResolution = viewState.resolution;
        var viewCenter = viewState.center;

        var tileLayer = this.getLayer();
        var tileSource = /** @type {module:ol/source/Tile} */ (tileLayer.getSource());
        var sourceRevision = tileSource.getRevision();
        var tileGrid = tileSource.getTileGridForProjection(projection);
        var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
        var tileResolution = tileGrid.getResolution(z);
        var oversampling = Math.round(viewResolution / tileResolution) || 1;
        var extent = frameState.extent;

        if (layerState.extent !== undefined) {
          extent = getIntersection(extent, layerState.extent);
        }
        if (isEmpty$1(extent)) {
          // Return false to prevent the rendering of the layer.
          return false;
        }

        var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
        var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

        var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

        /**
         * @type {Object.<number, Object.<string, module:ol/Tile>>}
         */
        var tilesToDrawByZ = {};
        tilesToDrawByZ[z] = {};

        var findLoadedTiles = this.createLoadedTileFinder(
          tileSource, projection, tilesToDrawByZ);

        var hints = frameState.viewHints;
        var animatingOrInteracting = hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING];

        var tmpExtent = this.tmpExtent;
        var tmpTileRange = this.tmpTileRange_;
        this.newTiles_ = false;
        var tile, x, y;
        for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
            if (Date.now() - frameState.time > 16 && animatingOrInteracting) {
              continue;
            }
            tile = this$1.getTile(z, x, y, pixelRatio, projection);
            if (this$1.isDrawableTile_(tile)) {
              var uid = getUid(this$1);
              if (tile.getState() == TileState.LOADED) {
                tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                var inTransition = tile.inTransition(uid);
                if (!this$1.newTiles_ && (inTransition || this$1.renderedTiles.indexOf(tile) === -1)) {
                  this$1.newTiles_ = true;
                }
              }
              if (tile.getAlpha(uid, frameState.time) === 1) {
                // don't look for alt tiles if alpha is 1
                continue;
              }
            }

            var childTileRange = tileGrid.getTileCoordChildTileRange(
              tile.tileCoord, tmpTileRange, tmpExtent);
            var covered = false;
            if (childTileRange) {
              covered = findLoadedTiles(z + 1, childTileRange);
            }
            if (!covered) {
              tileGrid.forEachTileCoordParentTileRange(
                tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
            }

          }
        }

        var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
        if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (
          this.newTiles_ ||
              !(this.renderedExtent_ && containsExtent(this.renderedExtent_, extent)) ||
              this.renderedRevision != sourceRevision ||
              oversampling != this.oversampling_ ||
              !animatingOrInteracting && renderedResolution != this.renderedResolution
        )) {

          var context = this.context;
          if (context) {
            var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
            var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
            var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
            var canvas = context.canvas;
            if (canvas.width != width || canvas.height != height) {
              this.oversampling_ = oversampling;
              canvas.width = width;
              canvas.height = height;
            } else {
              if (this.renderedExtent_ && !equals$2(imageExtent, this.renderedExtent_)) {
                context.clearRect(0, 0, width, height);
              }
              oversampling = this.oversampling_;
            }
          }

          this.renderedTiles.length = 0;
          /** @type {Array.<number>} */
          var zs = Object.keys(tilesToDrawByZ).map(Number);
          zs.sort(function(a, b) {
            if (a === z) {
              return 1;
            } else if (b === z) {
              return -1;
            } else {
              return a > b ? 1 : a < b ? -1 : 0;
            }
          });
          var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
          var tileExtent, tileGutter, tilesToDraw, w, h;
          for (i = 0, ii = zs.length; i < ii; ++i) {
            currentZ = zs[i];
            currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
            currentResolution = tileGrid.getResolution(currentZ);
            currentScale = currentResolution / tileResolution;
            tileGutter = tilePixelRatio * tileSource.getGutter(projection);
            tilesToDraw = tilesToDrawByZ[currentZ];
            for (var tileCoordKey in tilesToDraw) {
              tile = tilesToDraw[tileCoordKey];
              tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
              x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
              y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
              w = currentTilePixelSize[0] * currentScale / oversampling;
              h = currentTilePixelSize[1] * currentScale / oversampling;
              this$1.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
              this$1.renderedTiles.push(tile);
            }
          }

          this.renderedRevision = sourceRevision;
          this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
          this.renderedExtent_ = imageExtent;
        }

        var scale = this.renderedResolution / viewResolution;
        var transform = compose(this.imageTransform_,
          pixelRatio * size[0] / 2, pixelRatio * size[1] / 2,
          scale, scale,
          0,
          (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio,
          (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
        compose(this.coordinateToCanvasPixelTransform,
          pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5],
          pixelRatio / viewResolution, -pixelRatio / viewResolution,
          0,
          -viewCenter[0], -viewCenter[1]);


        this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
        this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio,
          projection, extent, z, tileLayer.getPreload());
        this.scheduleExpireCache(frameState, tileSource);

        return this.renderedTiles.length > 0;
      };

      /**
       * @param {module:ol/Tile} tile Tile.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/layer/Layer~State} layerState Layer state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       */
      CanvasTileLayerRenderer.prototype.drawTileImage = function drawTileImage (tile, frameState, layerState, x, y, w, h, gutter, transition) {
        var image = tile.getImage(this.getLayer());
        if (!image) {
          return;
        }
        var uid = getUid(this);
        var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
        if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
          this.context.clearRect(x, y, w, h);
        }
        var alphaChanged = alpha !== this.context.globalAlpha;
        if (alphaChanged) {
          this.context.save();
          this.context.globalAlpha = alpha;
        }
        this.context.drawImage(image, gutter, gutter,
          image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

        if (alphaChanged) {
          this.context.restore();
        }
        if (alpha !== 1) {
          frameState.animate = true;
        } else if (transition) {
          tile.endTransition(uid);
        }
      };

      /**
       * @inheritDoc
       */
      CanvasTileLayerRenderer.prototype.getImage = function getImage () {
        var context = this.context;
        return context ? context.canvas : null;
      };

      /**
       * @inheritDoc
       */
      CanvasTileLayerRenderer.prototype.getImageTransform = function getImageTransform () {
        return this.imageTransform_;
      };

      return CanvasTileLayerRenderer;
    }(IntermediateCanvasRenderer));


    /**
     * Determine if this renderer handles the provided layer.
     * @param {module:ol/layer/Layer} layer The candidate layer.
     * @return {boolean} The renderer can render the layer.
     */
    CanvasTileLayerRenderer['handles'] = function(layer) {
      return layer.getType() === LayerType.TILE;
    };


    /**
     * Create a layer renderer.
     * @param {module:ol/renderer/Map} mapRenderer The map renderer.
     * @param {module:ol/layer/Layer} layer The layer to be rendererd.
     * @return {module:ol/renderer/canvas/TileLayer} The layer renderer.
     */
    CanvasTileLayerRenderer['create'] = function(mapRenderer, layer) {
      return new CanvasTileLayerRenderer(/** @type {module:ol/layer/Tile} */ (layer));
    };


    /**
     * @function
     * @return {module:ol/layer/Tile|module:ol/layer/VectorTile}
     */
    CanvasTileLayerRenderer.prototype.getLayer;

    /**
     * @module ol/render/ReplayGroup
     */
    /**
     * Base class for replay groups.
     */
    var ReplayGroup = function ReplayGroup () {};

    ReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {};

    /**
     * @abstract
     * @return {boolean} Is empty.
     */
    ReplayGroup.prototype.isEmpty = function isEmpty () {};

    /**
     * @module ol/render/ReplayType
     */

    /**
     * @enum {string}
     */
    var ReplayType = {
      CIRCLE: 'Circle',
      DEFAULT: 'Default',
      IMAGE: 'Image',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      TEXT: 'Text'
    };

    /**
     * @module ol/geom/flat/textpath
     */


    /**
     * @param {Array.<number>} flatCoordinates Path to put text on.
     * @param {number} offset Start offset of the `flatCoordinates`.
     * @param {number} end End offset of the `flatCoordinates`.
     * @param {number} stride Stride.
     * @param {string} text Text to place on the path.
     * @param {function(string):number} measure Measure function returning the
     * width of the character passed as 1st argument.
     * @param {number} startM m along the path where the text starts.
     * @param {number} maxAngle Max angle between adjacent chars in radians.
     * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was
     * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
     */
    function drawTextOnPath(
      flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
      var result = [];

      // Keep text upright
      var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];

      var numChars = text.length;

      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      offset += stride;
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      var segmentM = 0;
      var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

      var chunk = '';
      var chunkLength = 0;
      var data, index, previousAngle;
      for (var i = 0; i < numChars; ++i) {
        index = reverse ? numChars - i - 1 : i;
        var char = text.charAt(index);
        chunk = reverse ? char + chunk : chunk + char;
        var charLength = measure(chunk) - chunkLength;
        chunkLength += charLength;
        var charM = startM + charLength / 2;
        while (offset < end - stride && segmentM + segmentLength < charM) {
          x1 = x2;
          y1 = y2;
          offset += stride;
          x2 = flatCoordinates[offset];
          y2 = flatCoordinates[offset + 1];
          segmentM += segmentLength;
          segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }
        var segmentPos = charM - segmentM;
        var angle = Math.atan2(y2 - y1, x2 - x1);
        if (reverse) {
          angle += angle > 0 ? -Math.PI : Math.PI;
        }
        if (previousAngle !== undefined) {
          var delta = angle - previousAngle;
          delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;
          if (Math.abs(delta) > maxAngle) {
            return null;
          }
        }
        var interpolate = segmentPos / segmentLength;
        var x = lerp(x1, x2, interpolate);
        var y = lerp(y1, y2, interpolate);
        if (previousAngle == angle) {
          if (reverse) {
            data[0] = x;
            data[1] = y;
            data[2] = charLength / 2;
          }
          data[4] = chunk;
        } else {
          chunk = char;
          chunkLength = charLength;
          data = [x, y, charLength / 2, angle, chunk];
          if (reverse) {
            result.unshift(data);
          } else {
            result.push(data);
          }
          previousAngle = angle;
        }
        startM += charLength;
      }
      return result;
    }

    /**
     * @module ol/render/canvas/Instruction
     */

    /**
     * @enum {number}
     */
    var Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12
    };


    /**
     * @type {Array.<Instruction>}
     */
    var fillInstruction = [Instruction.FILL];


    /**
     * @type {Array.<Instruction>}
     */
    var strokeInstruction = [Instruction.STROKE];


    /**
     * @type {Array.<Instruction>}
     */
    var beginPathInstruction = [Instruction.BEGIN_PATH];


    /**
     * @type {Array.<Instruction>}
     */
    var closePathInstruction = [Instruction.CLOSE_PATH];

    /**
     * @module ol/render/replay
     */


    /**
     * @const
     * @type {Array.<module:ol/render/ReplayType>}
     */
    var ORDER = [
      ReplayType.POLYGON,
      ReplayType.CIRCLE,
      ReplayType.LINE_STRING,
      ReplayType.IMAGE,
      ReplayType.TEXT,
      ReplayType.DEFAULT
    ];

    /**
     * @const
     * @enum {number}
     */
    var TEXT_ALIGN = {};
    TEXT_ALIGN['left'] = 0;
    TEXT_ALIGN['end'] = 0;
    TEXT_ALIGN['center'] = 0.5;
    TEXT_ALIGN['right'] = 1;
    TEXT_ALIGN['start'] = 1;
    TEXT_ALIGN['top'] = 0;
    TEXT_ALIGN['middle'] = 0.5;
    TEXT_ALIGN['hanging'] = 0.2;
    TEXT_ALIGN['alphabetic'] = 0.8;
    TEXT_ALIGN['ideographic'] = 0.8;
    TEXT_ALIGN['bottom'] = 1;

    /**
     * @module ol/render/canvas/Replay
     */


    /**
     * @type {module:ol/extent~Extent}
     */
    var tmpExtent = createEmpty();


    /**
     * @type {!module:ol/transform~Transform}
     */
    var tmpTransform$1 = create();


    var CanvasReplay = (function (VectorContext$$1) {
      function CanvasReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
        VectorContext$$1.call(this);

        /**
         * @type {?}
         */
        this.declutterTree = declutterTree;

        /**
         * @protected
         * @type {number}
         */
        this.tolerance = tolerance;

        /**
         * @protected
         * @const
         * @type {module:ol/extent~Extent}
         */
        this.maxExtent = maxExtent;

        /**
         * @protected
         * @type {boolean}
         */
        this.overlaps = overlaps;

        /**
         * @protected
         * @type {number}
         */
        this.pixelRatio = pixelRatio;

        /**
         * @protected
         * @type {number}
         */
        this.maxLineWidth = 0;

        /**
         * @protected
         * @const
         * @type {number}
         */
        this.resolution = resolution;

        /**
         * @private
         * @type {boolean}
         */
        this.alignFill_;

        /**
         * @private
         * @type {Array.<*>}
         */
        this.beginGeometryInstruction1_ = null;

        /**
         * @private
         * @type {Array.<*>}
         */
        this.beginGeometryInstruction2_ = null;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.bufferedMaxExtent_ = null;

        /**
         * @protected
         * @type {Array.<*>}
         */
        this.instructions = [];

        /**
         * @protected
         * @type {Array.<number>}
         */
        this.coordinates = [];

        /**
         * @private
         * @type {!Object.<number,module:ol/coordinate~Coordinate|Array.<module:ol/coordinate~Coordinate>|Array.<Array.<module:ol/coordinate~Coordinate>>>}
         */
        this.coordinateCache_ = {};

        /**
         * @private
         * @type {!module:ol/transform~Transform}
         */
        this.renderedTransform_ = create();

        /**
         * @protected
         * @type {Array.<*>}
         */
        this.hitDetectionInstructions = [];

        /**
         * @private
         * @type {Array.<number>}
         */
        this.pixelCoordinates_ = null;

        /**
         * @protected
         * @type {module:ol/render/canvas~FillStrokeState}
         */
        this.state = /** @type {module:ol/render/canvas~FillStrokeState} */ ({});

        /**
         * @private
         * @type {number}
         */
        this.viewRotation_ = 0;

      }

      if ( VectorContext$$1 ) CanvasReplay.__proto__ = VectorContext$$1;
      CanvasReplay.prototype = Object.create( VectorContext$$1 && VectorContext$$1.prototype );
      CanvasReplay.prototype.constructor = CanvasReplay;

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/coordinate~Coordinate} p1 1st point of the background box.
       * @param {module:ol/coordinate~Coordinate} p2 2nd point of the background box.
       * @param {module:ol/coordinate~Coordinate} p3 3rd point of the background box.
       * @param {module:ol/coordinate~Coordinate} p4 4th point of the background box.
       * @param {Array.<*>} fillInstruction Fill instruction.
       * @param {Array.<*>} strokeInstruction Stroke instruction.
       */
      CanvasReplay.prototype.replayTextBackground_ = function replayTextBackground_ (context, p1, p2, p3, p4, fillInstruction$$1, strokeInstruction$$1) {
        context.beginPath();
        context.moveTo.apply(context, p1);
        context.lineTo.apply(context, p2);
        context.lineTo.apply(context, p3);
        context.lineTo.apply(context, p4);
        context.lineTo.apply(context, p1);
        if (fillInstruction$$1) {
          this.alignFill_ = /** @type {boolean} */ (fillInstruction$$1[2]);
          this.fill_(context);
        }
        if (strokeInstruction$$1) {
          this.setStrokeStyle_(context, /** @type {Array.<*>} */ (strokeInstruction$$1));
          context.stroke();
        }
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
       * @param {number} height Height.
       * @param {number} opacity Opacity.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {number} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {number} width Width.
       * @param {Array.<number>} padding Padding.
       * @param {Array.<*>} fillInstruction Fill instruction.
       * @param {Array.<*>} strokeInstruction Stroke instruction.
       */
      CanvasReplay.prototype.replayImage_ = function replayImage_ (
        context,
        x,
        y,
        image,
        anchorX,
        anchorY,
        declutterGroup,
        height,
        opacity,
        originX,
        originY,
        rotation,
        scale,
        snapToPixel,
        width,
        padding,
        fillInstruction$$1,
        strokeInstruction$$1
      ) {
        var fillStroke = fillInstruction$$1 || strokeInstruction$$1;
        anchorX *= scale;
        anchorY *= scale;
        x -= anchorX;
        y -= anchorY;

        var w = (width + originX > image.width) ? image.width - originX : width;
        var h = (height + originY > image.height) ? image.height - originY : height;
        var boxW = padding[3] + w * scale + padding[1];
        var boxH = padding[0] + h * scale + padding[2];
        var boxX = x - padding[3];
        var boxY = y - padding[0];

        /** @type {module:ol/coordinate~Coordinate} */
        var p1;
        /** @type {module:ol/coordinate~Coordinate} */
        var p2;
        /** @type {module:ol/coordinate~Coordinate} */
        var p3;
        /** @type {module:ol/coordinate~Coordinate} */
        var p4;
        if (fillStroke || rotation !== 0) {
          p1 = [boxX, boxY];
          p2 = [boxX + boxW, boxY];
          p3 = [boxX + boxW, boxY + boxH];
          p4 = [boxX, boxY + boxH];
        }

        var transform = null;
        if (rotation !== 0) {
          var centerX = x + anchorX;
          var centerY = y + anchorY;
          transform = compose(tmpTransform$1, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

          createOrUpdateEmpty(tmpExtent);
          extendCoordinate(tmpExtent, apply(tmpTransform$1, p1));
          extendCoordinate(tmpExtent, apply(tmpTransform$1, p2));
          extendCoordinate(tmpExtent, apply(tmpTransform$1, p3));
          extendCoordinate(tmpExtent, apply(tmpTransform$1, p4));
        } else {
          createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
        }
        var canvas = context.canvas;
        var strokePadding = strokeInstruction$$1 ? (strokeInstruction$$1[2] * scale / 2) : 0;
        var intersects$$1 =
            tmpExtent[0] - strokePadding <= canvas.width && tmpExtent[2] + strokePadding >= 0 &&
            tmpExtent[1] - strokePadding <= canvas.height && tmpExtent[3] + strokePadding >= 0;

        if (snapToPixel) {
          x = Math.round(x);
          y = Math.round(y);
        }

        if (declutterGroup) {
          if (!intersects$$1 && declutterGroup[4] == 1) {
            return;
          }
          extend$1(declutterGroup, tmpExtent);
          var declutterArgs = intersects$$1 ?
            [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] :
            null;
          if (declutterArgs && fillStroke) {
            declutterArgs.push(fillInstruction$$1, strokeInstruction$$1, p1, p2, p3, p4);
          }
          declutterGroup.push(declutterArgs);
        } else if (intersects$$1) {
          if (fillStroke) {
            this.replayTextBackground_(context, p1, p2, p3, p4,
              /** @type {Array.<*>} */ (fillInstruction$$1),
              /** @type {Array.<*>} */ (strokeInstruction$$1));
          }
          drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
        }
      };

      /**
       * @protected
       * @param {Array.<number>} dashArray Dash array.
       * @return {Array.<number>} Dash array with pixel ratio applied
       */
      CanvasReplay.prototype.applyPixelRatio = function applyPixelRatio (dashArray) {
        var pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
          return dash * pixelRatio;
        });
      };

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      CanvasReplay.prototype.appendFlatCoordinates = function appendFlatCoordinates (flatCoordinates, offset, end, stride, closed, skipFirst) {
        var this$1 = this;


        var myEnd = this.coordinates.length;
        var extent = this.getBufferedMaxExtent();
        if (skipFirst) {
          offset += stride;
        }
        var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
        var nextCoord = [NaN, NaN];
        var skipped = true;

        var i, lastRel, nextRel;
        for (i = offset + stride; i < end; i += stride) {
          nextCoord[0] = flatCoordinates[i];
          nextCoord[1] = flatCoordinates[i + 1];
          nextRel = coordinateRelationship(extent, nextCoord);
          if (nextRel !== lastRel) {
            if (skipped) {
              this$1.coordinates[myEnd++] = lastCoord[0];
              this$1.coordinates[myEnd++] = lastCoord[1];
            }
            this$1.coordinates[myEnd++] = nextCoord[0];
            this$1.coordinates[myEnd++] = nextCoord[1];
            skipped = false;
          } else if (nextRel === Relationship.INTERSECTING) {
            this$1.coordinates[myEnd++] = nextCoord[0];
            this$1.coordinates[myEnd++] = nextCoord[1];
            skipped = false;
          } else {
            skipped = true;
          }
          lastCoord[0] = nextCoord[0];
          lastCoord[1] = nextCoord[1];
          lastRel = nextRel;
        }

        // Last coordinate equals first or only one point to append:
        if ((closed && skipped) || i === offset + stride) {
          this.coordinates[myEnd++] = lastCoord[0];
          this.coordinates[myEnd++] = lastCoord[1];
        }
        return myEnd;
      };

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array.<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array.<number>} replayEnds Replay ends.
       * @return {number} Offset.
       */
      CanvasReplay.prototype.drawCustomCoordinates_ = function drawCustomCoordinates_ (flatCoordinates, offset, ends, stride, replayEnds) {
        var this$1 = this;

        for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var replayEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
          replayEnds.push(replayEnd);
          offset = end;
        }
        return offset;
      };

      /**
       * @inheritDoc.
       */
      CanvasReplay.prototype.drawCustom = function drawCustom (geometry, feature, renderer) {
        var this$1 = this;

        this.beginGeometry(geometry, feature);
        var type = geometry.getType();
        var stride = geometry.getStride();
        var replayBegin = this.coordinates.length;
        var flatCoordinates, replayEnd, replayEnds, replayEndss;
        var offset;
        if (type == GeometryType.MULTI_POLYGON) {
          geometry = /** @type {module:ol/geom/MultiPolygon} */ (geometry);
          flatCoordinates = geometry.getOrientedFlatCoordinates();
          replayEndss = [];
          var endss = geometry.getEndss();
          offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
            var myEnds = [];
            offset = this$1.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
            replayEndss.push(myEnds);
          }
          this.instructions.push([Instruction.CUSTOM,
            replayBegin, replayEndss, geometry, renderer, inflateMultiCoordinatesArray]);
        } else if (type == GeometryType.POLYGON || type == GeometryType.MULTI_LINE_STRING) {
          replayEnds = [];
          flatCoordinates = (type == GeometryType.POLYGON) ?
            /** @type {module:ol/geom/Polygon} */ (geometry).getOrientedFlatCoordinates() :
            geometry.getFlatCoordinates();
          offset = this.drawCustomCoordinates_(flatCoordinates, 0,
            /** @type {module:ol/geom/Polygon|module:ol/geom/MultiLineString} */ (geometry).getEnds(),
            stride, replayEnds);
          this.instructions.push([Instruction.CUSTOM,
            replayBegin, replayEnds, geometry, renderer, inflateCoordinatesArray]);
        } else if (type == GeometryType.LINE_STRING || type == GeometryType.MULTI_POINT) {
          flatCoordinates = geometry.getFlatCoordinates();
          replayEnd = this.appendFlatCoordinates(
            flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          this.instructions.push([Instruction.CUSTOM,
            replayBegin, replayEnd, geometry, renderer, inflateCoordinates]);
        } else if (type == GeometryType.POINT) {
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          replayEnd = this.coordinates.length;
          this.instructions.push([Instruction.CUSTOM,
            replayBegin, replayEnd, geometry, renderer]);
        }
        this.endGeometry(geometry, feature);
      };

      /**
       * @protected
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       */
      CanvasReplay.prototype.beginGeometry = function beginGeometry (geometry, feature) {
        this.beginGeometryInstruction1_ = [Instruction.BEGIN_GEOMETRY, feature, 0];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [Instruction.BEGIN_GEOMETRY, feature, 0];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      };

      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      CanvasReplay.prototype.fill_ = function fill_ (context) {
        if (this.alignFill_) {
          var origin = apply(this.renderedTransform_, [0, 0]);
          var repeatSize = 512 * this.pixelRatio;
          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
          context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) {
          context.setTransform.apply(context, resetTransform);
        }
      };

      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array.<*>} instruction Instruction.
       */
      CanvasReplay.prototype.setStrokeStyle_ = function setStrokeStyle_ (context, instruction) {
        context.strokeStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);
        context.lineWidth = /** @type {number} */ (instruction[2]);
        context.lineCap = /** @type {string} */ (instruction[3]);
        context.lineJoin = /** @type {string} */ (instruction[4]);
        context.miterLimit = /** @type {number} */ (instruction[5]);
        if (CANVAS_LINE_DASH) {
          context.lineDashOffset = /** @type {number} */ (instruction[7]);
          context.setLineDash(/** @type {Array.<number>} */ (instruction[6]));
        }
      };

      /**
       * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       */
      CanvasReplay.prototype.renderDeclutter_ = function renderDeclutter_ (declutterGroup, feature) {
        var this$1 = this;

        if (declutterGroup && declutterGroup.length > 5) {
          var groupCount = declutterGroup[4];
          if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
            /** @type {module:ol/structs/RBush~Entry} */
            var box = {
              minX: /** @type {number} */ (declutterGroup[0]),
              minY: /** @type {number} */ (declutterGroup[1]),
              maxX: /** @type {number} */ (declutterGroup[2]),
              maxY: /** @type {number} */ (declutterGroup[3]),
              value: feature
            };
            if (!this.declutterTree.collides(box)) {
              this.declutterTree.insert(box);
              for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
                var declutterData = /** @type {Array} */ (declutterGroup[j]);
                if (declutterData) {
                  if (declutterData.length > 11) {
                    this$1.replayTextBackground_(declutterData[0],
                      declutterData[13], declutterData[14], declutterData[15], declutterData[16],
                      declutterData[11], declutterData[12]);
                  }
                  drawImage.apply(undefined, declutterData);
                }
              }
            }
            declutterGroup.length = 5;
            createOrUpdateEmpty(declutterGroup);
          }
        }
      };

      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/transform~Transform} transform Transform.
       * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
       *     to skip.
       * @param {Array.<*>} instructions Instructions array.
       * @param {function((module:ol/Feature|module:ol/render/Feature)): T|undefined}
       *     featureCallback Feature callback.
       * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CanvasReplay.prototype.replay_ = function replay_ (
        context,
        transform,
        skippedFeaturesHash,
        instructions,
        featureCallback,
        opt_hitExtent
      ) {
        var this$1 = this;

        /** @type {Array.<number>} */
        var pixelCoordinates;
        if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {
          pixelCoordinates = this.pixelCoordinates_;
        } else {
          if (!this.pixelCoordinates_) {
            this.pixelCoordinates_ = [];
          }
          pixelCoordinates = transform2D(
            this.coordinates, 0, this.coordinates.length, 2,
            transform, this.pixelCoordinates_);
          setFromArray(this.renderedTransform_, transform);
        }
        var skipFeatures = !isEmpty(skippedFeaturesHash);
        var i = 0; // instruction index
        var ii = instructions.length; // end of instructions
        var d = 0; // data index
        var dd; // end of per-instruction data
        var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
        var pendingFill = 0;
        var pendingStroke = 0;
        var lastFillInstruction = null;
        var lastStrokeInstruction = null;
        var coordinateCache = this.coordinateCache_;
        var viewRotation = this.viewRotation_;

        var state = /** @type {module:ol/render~State} */ ({
          context: context,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: viewRotation
        });

        // When the batch size gets too big, performance decreases. 200 is a good
        // balance between batch size and number of fill/stroke instructions.
        var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        var /** @type {module:ol/Feature|module:ol/render/Feature} */ feature;
        var x, y;
        while (i < ii) {
          var instruction = instructions[i];
          var type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);
          switch (type) {
            case Instruction.BEGIN_GEOMETRY:
              feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);
              if ((skipFeatures &&
                  skippedFeaturesHash[getUid(feature).toString()]) ||
                  !feature.getGeometry()) {
                i = /** @type {number} */ (instruction[2]);
              } else if (opt_hitExtent !== undefined && !intersects(
                opt_hitExtent, feature.getGeometry().getExtent())) {
                i = /** @type {number} */ (instruction[2]) + 1;
              } else {
                ++i;
              }
              break;
            case Instruction.BEGIN_PATH:
              if (pendingFill > batchSize) {
                this$1.fill_(context);
                pendingFill = 0;
              }
              if (pendingStroke > batchSize) {
                context.stroke();
                pendingStroke = 0;
              }
              if (!pendingFill && !pendingStroke) {
                context.beginPath();
                prevX = prevY = NaN;
              }
              ++i;
              break;
            case Instruction.CIRCLE:
              d = /** @type {number} */ (instruction[1]);
              var x1 = pixelCoordinates[d];
              var y1 = pixelCoordinates[d + 1];
              var x2 = pixelCoordinates[d + 2];
              var y2 = pixelCoordinates[d + 3];
              var dx = x2 - x1;
              var dy = y2 - y1;
              var r = Math.sqrt(dx * dx + dy * dy);
              context.moveTo(x1 + r, y1);
              context.arc(x1, y1, r, 0, 2 * Math.PI, true);
              ++i;
              break;
            case Instruction.CLOSE_PATH:
              context.closePath();
              ++i;
              break;
            case Instruction.CUSTOM:
              d = /** @type {number} */ (instruction[1]);
              dd = instruction[2];
              var geometry = /** @type {module:ol/geom/SimpleGeometry} */ (instruction[3]);
              var renderer = instruction[4];
              var fn = instruction.length == 6 ? instruction[5] : undefined;
              state.geometry = geometry;
              state.feature = feature;
              if (!(i in coordinateCache)) {
                coordinateCache[i] = [];
              }
              var coords = coordinateCache[i];
              if (fn) {
                fn(pixelCoordinates, d, dd, 2, coords);
              } else {
                coords[0] = pixelCoordinates[d];
                coords[1] = pixelCoordinates[d + 1];
                coords.length = 2;
              }
              renderer(coords, state);
              ++i;
              break;
            case Instruction.DRAW_IMAGE:
              d = /** @type {number} */ (instruction[1]);
              dd = /** @type {number} */ (instruction[2]);
              image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
                  (instruction[3]);
              // Remaining arguments in DRAW_IMAGE are in alphabetical order
              anchorX = /** @type {number} */ (instruction[4]);
              anchorY = /** @type {number} */ (instruction[5]);
              declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[6]);
              var height = /** @type {number} */ (instruction[7]);
              var opacity = /** @type {number} */ (instruction[8]);
              var originX = /** @type {number} */ (instruction[9]);
              var originY = /** @type {number} */ (instruction[10]);
              var rotateWithView = /** @type {boolean} */ (instruction[11]);
              var rotation = /** @type {number} */ (instruction[12]);
              var scale = /** @type {number} */ (instruction[13]);
              var snapToPixel = /** @type {boolean} */ (instruction[14]);
              var width = /** @type {number} */ (instruction[15]);

              var padding = (void 0), backgroundFill = (void 0), backgroundStroke = (void 0);
              if (instruction.length > 16) {
                padding = /** @type {Array.<number>} */ (instruction[16]);
                backgroundFill = /** @type {boolean} */ (instruction[17]);
                backgroundStroke = /** @type {boolean} */ (instruction[18]);
              } else {
                padding = defaultPadding;
                backgroundFill = backgroundStroke = false;
              }

              if (rotateWithView) {
                rotation += viewRotation;
              }
              for (; d < dd; d += 2) {
                this$1.replayImage_(context,
                  pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY,
                  declutterGroup, height, opacity, originX, originY, rotation, scale,
                  snapToPixel, width, padding,
                  backgroundFill ? /** @type {Array.<*>} */ (lastFillInstruction) : null,
                  backgroundStroke ? /** @type {Array.<*>} */ (lastStrokeInstruction) : null);
              }
              this$1.renderDeclutter_(declutterGroup, feature);
              ++i;
              break;
            case Instruction.DRAW_CHARS:
              var begin = /** @type {number} */ (instruction[1]);
              var end = /** @type {number} */ (instruction[2]);
              var baseline = /** @type {number} */ (instruction[3]);
              declutterGroup = featureCallback ? null : /** @type {module:ol/render/canvas~DeclutterGroup} */ (instruction[4]);
              var overflow = /** @type {number} */ (instruction[5]);
              var fillKey = /** @type {string} */ (instruction[6]);
              var maxAngle = /** @type {number} */ (instruction[7]);
              var measure = /** @type {function(string):number} */ (instruction[8]);
              var offsetY = /** @type {number} */ (instruction[9]);
              var strokeKey = /** @type {string} */ (instruction[10]);
              var strokeWidth = /** @type {number} */ (instruction[11]);
              var text = /** @type {string} */ (instruction[12]);
              var textKey = /** @type {string} */ (instruction[13]);
              var textScale = /** @type {number} */ (instruction[14]);

              var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
              var textLength = measure(text);
              if (overflow || textLength <= pathLength) {
                var textAlign = /** @type {module:ol~render} */ (this$1).textStates[textKey].textAlign;
                var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                var parts = drawTextOnPath(
                  pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
                if (parts) {
                  var c = (void 0), cc = (void 0), chars = (void 0), label = (void 0), part = (void 0);
                  if (strokeKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c]; // x, y, anchorX, rotation, chunk
                      chars = /** @type {string} */ (part[4]);
                      label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, '', strokeKey);
                      anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                      anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                      this$1.replayImage_(context,
                        /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                        anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                        /** @type {number} */ (part[3]), textScale, false, label.width,
                        defaultPadding, null, null);
                    }
                  }
                  if (fillKey) {
                    for (c = 0, cc = parts.length; c < cc; ++c) {
                      part = parts[c]; // x, y, anchorX, rotation, chunk
                      chars = /** @type {string} */ (part[4]);
                      label = /** @type {module:ol~render} */ (this$1).getImage(chars, textKey, fillKey, '');
                      anchorX = /** @type {number} */ (part[2]);
                      anchorY = baseline * label.height - offsetY;
                      this$1.replayImage_(context,
                        /** @type {number} */ (part[0]), /** @type {number} */ (part[1]), label,
                        anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                        /** @type {number} */ (part[3]), textScale, false, label.width,
                        defaultPadding, null, null);
                    }
                  }
                }
              }
              this$1.renderDeclutter_(declutterGroup, feature);
              ++i;
              break;
            case Instruction.END_GEOMETRY:
              if (featureCallback !== undefined) {
                feature = /** @type {module:ol/Feature|module:ol/render/Feature} */ (instruction[1]);
                var result = featureCallback(feature);
                if (result) {
                  return result;
                }
              }
              ++i;
              break;
            case Instruction.FILL:
              if (batchSize) {
                pendingFill++;
              } else {
                this$1.fill_(context);
              }
              ++i;
              break;
            case Instruction.MOVE_TO_LINE_TO:
              d = /** @type {number} */ (instruction[1]);
              dd = /** @type {number} */ (instruction[2]);
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = (x + 0.5) | 0;
              roundY = (y + 0.5) | 0;
              if (roundX !== prevX || roundY !== prevY) {
                context.moveTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
              for (d += 2; d < dd; d += 2) {
                x = pixelCoordinates[d];
                y = pixelCoordinates[d + 1];
                roundX = (x + 0.5) | 0;
                roundY = (y + 0.5) | 0;
                if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                  context.lineTo(x, y);
                  prevX = roundX;
                  prevY = roundY;
                }
              }
              ++i;
              break;
            case Instruction.SET_FILL_STYLE:
              lastFillInstruction = instruction;
              this$1.alignFill_ = instruction[2];

              if (pendingFill) {
                this$1.fill_(context);
                pendingFill = 0;
                if (pendingStroke) {
                  context.stroke();
                  pendingStroke = 0;
                }
              }

              context.fillStyle = /** @type {module:ol/colorlike~ColorLike} */ (instruction[1]);
              ++i;
              break;
            case Instruction.SET_STROKE_STYLE:
              lastStrokeInstruction = instruction;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
              this$1.setStrokeStyle_(context, /** @type {Array.<*>} */ (instruction));
              ++i;
              break;
            case Instruction.STROKE:
              if (batchSize) {
                pendingStroke++;
              } else {
                context.stroke();
              }
              ++i;
              break;
            default:
              ++i; // consume the instruction anyway, to avoid an infinite loop
              break;
          }
        }
        if (pendingFill) {
          this.fill_(context);
        }
        if (pendingStroke) {
          context.stroke();
        }
        return undefined;
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/transform~Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
       *     to skip.
       */
      CanvasReplay.prototype.replay = function replay (context, transform, viewRotation, skippedFeaturesHash) {
        this.viewRotation_ = viewRotation;
        this.replay_(context, transform,
          skippedFeaturesHash, this.instructions, undefined, undefined);
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/transform~Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
       *     to skip.
       * @param {function((module:ol/Feature|module:ol/render/Feature)): T=} opt_featureCallback
       *     Feature callback.
       * @param {module:ol/extent~Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CanvasReplay.prototype.replayHitDetection = function replayHitDetection (
        context,
        transform,
        viewRotation,
        skippedFeaturesHash,
        opt_featureCallback,
        opt_hitExtent
      ) {
        this.viewRotation_ = viewRotation;
        return this.replay_(context, transform, skippedFeaturesHash,
          this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
      };

      /**
       * Reverse the hit detection instructions.
       */
      CanvasReplay.prototype.reverseHitDetectionInstructions = function reverseHitDetectionInstructions () {
        var this$1 = this;

        var hitDetectionInstructions = this.hitDetectionInstructions;
        // step 1 - reverse array
        hitDetectionInstructions.reverse();
        // step 2 - reverse instructions within geometry blocks
        var i;
        var n = hitDetectionInstructions.length;
        var instruction;
        var type;
        var begin = -1;
        for (i = 0; i < n; ++i) {
          instruction = hitDetectionInstructions[i];
          type = /** @type {module:ol/render/canvas/Instruction} */ (instruction[0]);
          if (type == Instruction.END_GEOMETRY) {
            begin = i;
          } else if (type == Instruction.BEGIN_GEOMETRY) {
            instruction[2] = i;
            reverseSubArray(this$1.hitDetectionInstructions, begin, i);
            begin = -1;
          }
        }
      };

      /**
       * @inheritDoc
       */
      CanvasReplay.prototype.setFillStrokeStyle = function setFillStrokeStyle (fillStyle, strokeStyle) {
        var state = this.state;
        if (fillStyle) {
          var fillStyleColor = fillStyle.getColor();
          state.fillStyle = asColorLike(fillStyleColor ?
            fillStyleColor : defaultFillStyle);
        } else {
          state.fillStyle = undefined;
        }
        if (strokeStyle) {
          var strokeStyleColor = strokeStyle.getColor();
          state.strokeStyle = asColorLike(strokeStyleColor ?
            strokeStyleColor : defaultStrokeStyle);
          var strokeStyleLineCap = strokeStyle.getLineCap();
          state.lineCap = strokeStyleLineCap !== undefined ?
            strokeStyleLineCap : defaultLineCap;
          var strokeStyleLineDash = strokeStyle.getLineDash();
          state.lineDash = strokeStyleLineDash ?
            strokeStyleLineDash.slice() : defaultLineDash;
          var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          state.lineDashOffset = strokeStyleLineDashOffset ?
            strokeStyleLineDashOffset : defaultLineDashOffset;
          var strokeStyleLineJoin = strokeStyle.getLineJoin();
          state.lineJoin = strokeStyleLineJoin !== undefined ?
            strokeStyleLineJoin : defaultLineJoin;
          var strokeStyleWidth = strokeStyle.getWidth();
          state.lineWidth = strokeStyleWidth !== undefined ?
            strokeStyleWidth : defaultLineWidth;
          var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          state.miterLimit = strokeStyleMiterLimit !== undefined ?
            strokeStyleMiterLimit : defaultMiterLimit;

          if (state.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = state.lineWidth;
            // invalidate the buffered max extent cache
            this.bufferedMaxExtent_ = null;
          }
        } else {
          state.strokeStyle = undefined;
          state.lineCap = undefined;
          state.lineDash = null;
          state.lineDashOffset = undefined;
          state.lineJoin = undefined;
          state.lineWidth = undefined;
          state.miterLimit = undefined;
        }
      };

      /**
       * @param {module:ol/render/canvas~FillStrokeState} state State.
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
       * @return {Array.<*>} Fill instruction.
       */
      CanvasReplay.prototype.createFill = function createFill (state, geometry) {
        var fillStyle = state.fillStyle;
        var fillInstruction$$1 = [Instruction.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== 'string') {
          // Fill is a pattern or gradient - align it!
          fillInstruction$$1.push(true);
        }
        return fillInstruction$$1;
      };

      /**
       * @param {module:ol/render/canvas~FillStrokeState} state State.
       */
      CanvasReplay.prototype.applyStroke = function applyStroke (state) {
        this.instructions.push(this.createStroke(state));
      };

      /**
       * @param {module:ol/render/canvas~FillStrokeState} state State.
       * @return {Array.<*>} Stroke instruction.
       */
      CanvasReplay.prototype.createStroke = function createStroke (state) {
        return [
          Instruction.SET_STROKE_STYLE,
          state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap,
          state.lineJoin, state.miterLimit,
          this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio
        ];
      };

      /**
       * @param {module:ol/render/canvas~FillStrokeState} state State.
       * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState, (module:ol/geom/Geometry|module:ol/render/Feature)):Array.<*>} createFill Create fill.
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
       */
      CanvasReplay.prototype.updateFillStyle = function updateFillStyle (state, createFill, geometry) {
        var fillStyle = state.fillStyle;
        if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
          if (fillStyle !== undefined) {
            this.instructions.push(createFill.call(this, state, geometry));
          }
          state.currentFillStyle = fillStyle;
        }
      };

      /**
       * @param {module:ol/render/canvas~FillStrokeState} state State.
       * @param {function(this:module:ol/render/canvas/Replay, module:ol/render/canvas~FillStrokeState)} applyStroke Apply stroke.
       */
      CanvasReplay.prototype.updateStrokeStyle = function updateStrokeStyle (state, applyStroke) {
        var strokeStyle = state.strokeStyle;
        var lineCap = state.lineCap;
        var lineDash = state.lineDash;
        var lineDashOffset = state.lineDashOffset;
        var lineJoin = state.lineJoin;
        var lineWidth = state.lineWidth;
        var miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle ||
            state.currentLineCap != lineCap ||
            (lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash)) ||
            state.currentLineDashOffset != lineDashOffset ||
            state.currentLineJoin != lineJoin ||
            state.currentLineWidth != lineWidth ||
            state.currentMiterLimit != miterLimit) {
          if (strokeStyle !== undefined) {
            applyStroke.call(this, state);
          }
          state.currentStrokeStyle = strokeStyle;
          state.currentLineCap = lineCap;
          state.currentLineDash = lineDash;
          state.currentLineDashOffset = lineDashOffset;
          state.currentLineJoin = lineJoin;
          state.currentLineWidth = lineWidth;
          state.currentMiterLimit = miterLimit;
        }
      };

      /**
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       */
      CanvasReplay.prototype.endGeometry = function endGeometry (geometry, feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
      };

      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {module:ol/extent~Extent} The buffered rendering extent.
       * @protected
       */
      CanvasReplay.prototype.getBufferedMaxExtent = function getBufferedMaxExtent () {
        if (!this.bufferedMaxExtent_) {
          this.bufferedMaxExtent_ = clone(this.maxExtent);
          if (this.maxLineWidth > 0) {
            var width = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
          }
        }
        return this.bufferedMaxExtent_;
      };

      return CanvasReplay;
    }(VectorContext));


    /**
     * FIXME empty description for jsdoc
     */
    CanvasReplay.prototype.finish = UNDEFINED;

    /**
     * @module ol/render/canvas/ImageReplay
     */

    var CanvasImageReplay = (function (CanvasReplay$$1) {
      function CanvasImageReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

        /**
         * @private
         * @type {module:ol/render/canvas~DeclutterGroup}
         */
        this.declutterGroup_ = null;

        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        this.hitDetectionImage_ = null;

        /**
         * @private
         * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
         */
        this.image_ = null;

        /**
         * @private
         * @type {number|undefined}
         */
        this.anchorX_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.anchorY_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.height_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.opacity_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.originX_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.originY_ = undefined;

        /**
         * @private
         * @type {boolean|undefined}
         */
        this.rotateWithView_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.rotation_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.scale_ = undefined;

        /**
         * @private
         * @type {boolean|undefined}
         */
        this.snapToPixel_ = undefined;

        /**
         * @private
         * @type {number|undefined}
         */
        this.width_ = undefined;

      }

      if ( CanvasReplay$$1 ) CanvasImageReplay.__proto__ = CanvasReplay$$1;
      CanvasImageReplay.prototype = Object.create( CanvasReplay$$1 && CanvasReplay$$1.prototype );
      CanvasImageReplay.prototype.constructor = CanvasImageReplay;

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} My end.
       */
      CanvasImageReplay.prototype.drawCoordinates_ = function drawCoordinates_ (flatCoordinates, offset, end, stride) {
        return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      };

      /**
       * @inheritDoc
       */
      CanvasImageReplay.prototype.drawPoint = function drawPoint (pointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(pointGeometry, feature);
        var flatCoordinates = pointGeometry.getFlatCoordinates();
        var stride = pointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.instructions.push([
          Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
          this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
          this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_
        ]);
        this.hitDetectionInstructions.push([
          Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
          this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
          this.scale_, this.snapToPixel_, this.width_
        ]);
        this.endGeometry(pointGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasImageReplay.prototype.drawMultiPoint = function drawMultiPoint (multiPointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(multiPointGeometry, feature);
        var flatCoordinates = multiPointGeometry.getFlatCoordinates();
        var stride = multiPointGeometry.getStride();
        var myBegin = this.coordinates.length;
        var myEnd = this.drawCoordinates_(
          flatCoordinates, 0, flatCoordinates.length, stride);
        this.instructions.push([
          Instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
          this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
          this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_
        ]);
        this.hitDetectionInstructions.push([
          Instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_,
          this.originX_, this.originY_, this.rotateWithView_, this.rotation_,
          this.scale_, this.snapToPixel_, this.width_
        ]);
        this.endGeometry(multiPointGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasImageReplay.prototype.finish = function finish () {
        this.reverseHitDetectionInstructions();
        // FIXME this doesn't really protect us against further calls to draw*Geometry
        this.anchorX_ = undefined;
        this.anchorY_ = undefined;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.height_ = undefined;
        this.scale_ = undefined;
        this.opacity_ = undefined;
        this.originX_ = undefined;
        this.originY_ = undefined;
        this.rotateWithView_ = undefined;
        this.rotation_ = undefined;
        this.snapToPixel_ = undefined;
        this.width_ = undefined;
      };

      /**
       * @inheritDoc
       */
      CanvasImageReplay.prototype.setImageStyle = function setImageStyle (imageStyle, declutterGroup) {
        var anchor = imageStyle.getAnchor();
        var size = imageStyle.getSize();
        var hitDetectionImage = imageStyle.getHitDetectionImage(1);
        var image = imageStyle.getImage(1);
        var origin = imageStyle.getOrigin();
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);
        this.hitDetectionImage_ = hitDetectionImage;
        this.image_ = image;
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScale();
        this.snapToPixel_ = imageStyle.getSnapToPixel();
        this.width_ = size[0];
      };

      return CanvasImageReplay;
    }(CanvasReplay));

    /**
     * @module ol/render/canvas/LineStringReplay
     */

    var CanvasLineStringReplay = (function (CanvasReplay$$1) {
      function CanvasLineStringReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
      }

      if ( CanvasReplay$$1 ) CanvasLineStringReplay.__proto__ = CanvasReplay$$1;
      CanvasLineStringReplay.prototype = Object.create( CanvasReplay$$1 && CanvasReplay$$1.prototype );
      CanvasLineStringReplay.prototype.constructor = CanvasLineStringReplay;

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      CanvasLineStringReplay.prototype.drawFlatCoordinates_ = function drawFlatCoordinates_ (flatCoordinates, offset, end, stride) {
        var myBegin = this.coordinates.length;
        var myEnd = this.appendFlatCoordinates(
          flatCoordinates, offset, end, stride, false, false);
        var moveToLineToInstruction = [Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
      };

      /**
       * @inheritDoc
       */
      CanvasLineStringReplay.prototype.drawLineString = function drawLineString (lineStringGeometry, feature) {
        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push([
          Instruction.SET_STROKE_STYLE,
          state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
          state.miterLimit, state.lineDash, state.lineDashOffset
        ], beginPathInstruction);
        var flatCoordinates = lineStringGeometry.getFlatCoordinates();
        var stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(lineStringGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasLineStringReplay.prototype.drawMultiLineString = function drawMultiLineString (multiLineStringGeometry, feature) {
        var this$1 = this;

        var state = this.state;
        var strokeStyle = state.strokeStyle;
        var lineWidth = state.lineWidth;
        if (strokeStyle === undefined || lineWidth === undefined) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push([
          Instruction.SET_STROKE_STYLE,
          state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
          state.miterLimit, state.lineDash, state.lineDashOffset
        ], beginPathInstruction);
        var ends = multiLineStringGeometry.getEnds();
        var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        var stride = multiLineStringGeometry.getStride();
        var offset = 0;
        for (var i = 0, ii = ends.length; i < ii; ++i) {
          offset = this$1.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
        }
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(multiLineStringGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasLineStringReplay.prototype.finish = function finish () {
        var state = this.state;
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
      };

      /**
       * @inheritDoc.
       */
      CanvasLineStringReplay.prototype.applyStroke = function applyStroke (state) {
        if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
          state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        CanvasReplay$$1.prototype.applyStroke.call(this, state);
        this.instructions.push(beginPathInstruction);
      };

      return CanvasLineStringReplay;
    }(CanvasReplay));

    /**
     * @module ol/render/canvas/PolygonReplay
     */


    var CanvasPolygonReplay = (function (CanvasReplay$$1) {
      function CanvasPolygonReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
      }

      if ( CanvasReplay$$1 ) CanvasPolygonReplay.__proto__ = CanvasReplay$$1;
      CanvasPolygonReplay.prototype = Object.create( CanvasReplay$$1 && CanvasReplay$$1.prototype );
      CanvasPolygonReplay.prototype.constructor = CanvasPolygonReplay;

      /**
       * @param {Array.<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array.<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasPolygonReplay.prototype.drawFlatCoordinatess_ = function drawFlatCoordinatess_ (flatCoordinates, offset, ends, stride) {
        var this$1 = this;

        var state = this.state;
        var fill = state.fillStyle !== undefined;
        var stroke = state.strokeStyle != undefined;
        var numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (var i = 0; i < numEnds; ++i) {
          var end = ends[i];
          var myBegin = this$1.coordinates.length;
          var myEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
          var moveToLineToInstruction = [Instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
          this$1.instructions.push(moveToLineToInstruction);
          this$1.hitDetectionInstructions.push(moveToLineToInstruction);
          if (stroke) {
            // Performance optimization: only call closePath() when we have a stroke.
            // Otherwise the ring is closed already (see appendFlatCoordinates above).
            this$1.instructions.push(closePathInstruction);
            this$1.hitDetectionInstructions.push(closePathInstruction);
          }
          offset = end;
        }
        if (fill) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (stroke) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset;
      };

      /**
       * @inheritDoc
       */
      CanvasPolygonReplay.prototype.drawCircle = function drawCircle (circleGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
          return;
        }
        this.setFillStrokeStyles_(circleGeometry);
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_FILL_STYLE,
            asString(defaultFillStyle)
          ]);
        }
        if (state.strokeStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_STROKE_STYLE,
            state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
            state.miterLimit, state.lineDash, state.lineDashOffset
          ]);
        }
        var flatCoordinates = circleGeometry.getFlatCoordinates();
        var stride = circleGeometry.getStride();
        var myBegin = this.coordinates.length;
        this.appendFlatCoordinates(
          flatCoordinates, 0, flatCoordinates.length, stride, false, false);
        var circleInstruction = [Instruction.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
        if (state.fillStyle !== undefined) {
          this.instructions.push(fillInstruction);
        }
        if (state.strokeStyle !== undefined) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(circleGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasPolygonReplay.prototype.drawPolygon = function drawPolygon (polygonGeometry, feature) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
          return;
        }
        this.setFillStrokeStyles_(polygonGeometry);
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_FILL_STYLE,
            asString(defaultFillStyle)
          ]);
        }
        if (state.strokeStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_STROKE_STYLE,
            state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
            state.miterLimit, state.lineDash, state.lineDashOffset
          ]);
        }
        var ends = polygonGeometry.getEnds();
        var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        var stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
        this.endGeometry(polygonGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasPolygonReplay.prototype.drawMultiPolygon = function drawMultiPolygon (multiPolygonGeometry, feature) {
        var this$1 = this;

        var state = this.state;
        var fillStyle = state.fillStyle;
        var strokeStyle = state.strokeStyle;
        if (fillStyle === undefined && strokeStyle === undefined) {
          return;
        }
        this.setFillStrokeStyles_(multiPolygonGeometry);
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_FILL_STYLE,
            asString(defaultFillStyle)
          ]);
        }
        if (state.strokeStyle !== undefined) {
          this.hitDetectionInstructions.push([
            Instruction.SET_STROKE_STYLE,
            state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin,
            state.miterLimit, state.lineDash, state.lineDashOffset
          ]);
        }
        var endss = multiPolygonGeometry.getEndss();
        var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        var stride = multiPolygonGeometry.getStride();
        var offset = 0;
        for (var i = 0, ii = endss.length; i < ii; ++i) {
          offset = this$1.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
        }
        this.endGeometry(multiPolygonGeometry, feature);
      };

      /**
       * @inheritDoc
       */
      CanvasPolygonReplay.prototype.finish = function finish () {
        this.reverseHitDetectionInstructions();
        this.state = null;
        // We want to preserve topology when drawing polygons.  Polygons are
        // simplified using quantization and point elimination. However, we might
        // have received a mix of quantized and non-quantized geometries, so ensure
        // that all are quantized by quantizing all coordinates in the batch.
        var tolerance = this.tolerance;
        if (tolerance !== 0) {
          var coordinates = this.coordinates;
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
            coordinates[i] = snap(coordinates[i], tolerance);
          }
        }
      };

      /**
       * @private
       * @param {module:ol/geom/Geometry|module:ol/render/Feature} geometry Geometry.
       */
      CanvasPolygonReplay.prototype.setFillStrokeStyles_ = function setFillStrokeStyles_ (geometry) {
        var state = this.state;
        var fillStyle = state.fillStyle;
        if (fillStyle !== undefined) {
          this.updateFillStyle(state, this.createFill, geometry);
        }
        if (state.strokeStyle !== undefined) {
          this.updateStrokeStyle(state, this.applyStroke);
        }
      };

      return CanvasPolygonReplay;
    }(CanvasReplay));

    /**
     * @module ol/geom/flat/straightchunk
     */


    /**
     * @param {number} maxAngle Maximum acceptable angle delta between segments.
     * @param {Array.<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @return {Array.<number>} Start and end of the first suitable chunk of the
     * given `flatCoordinates`.
     */
    function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
      var chunkStart = offset;
      var chunkEnd = offset;
      var chunkM = 0;
      var m = 0;
      var start = offset;
      var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
      for (i = offset; i < end; i += stride) {
        var x2 = flatCoordinates[i];
        var y2 = flatCoordinates[i + 1];
        if (x1 !== undefined) {
          x23 = x2 - x1;
          y23 = y2 - y1;
          m23 = Math.sqrt(x23 * x23 + y23 * y23);
          if (x12 !== undefined) {
            m += m12;
            acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
            if (acos > maxAngle) {
              if (m > chunkM) {
                chunkM = m;
                chunkStart = start;
                chunkEnd = i;
              }
              m = 0;
              start = i - stride;
            }
          }
          m12 = m23;
          x12 = x23;
          y12 = y23;
        }
        x1 = x2;
        y1 = y2;
      }
      m += m23;
      return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
    }

    /**
     * @module ol/style/TextPlacement
     */

    /**
     * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
     * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
     * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
     * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
     * @enum {string}
     */
    var TextPlacement = {
      POINT: 'point',
      LINE: 'line'
    };

    /**
     * @module ol/render/canvas/TextReplay
     */

    var CanvasTextReplay = (function (CanvasReplay$$1) {
      function CanvasTextReplay(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
        CanvasReplay$$1.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

        /**
         * @private
         * @type {module:ol/render/canvas~DeclutterGroup}
         */
        this.declutterGroup_;

        /**
         * @private
         * @type {Array.<HTMLCanvasElement>}
         */
        this.labels_ = null;

        /**
         * @private
         * @type {string}
         */
        this.text_ = '';

        /**
         * @private
         * @type {number}
         */
        this.textOffsetX_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.textOffsetY_ = 0;

        /**
         * @private
         * @type {boolean|undefined}
         */
        this.textRotateWithView_ = undefined;

        /**
         * @private
         * @type {number}
         */
        this.textRotation_ = 0;

        /**
         * @private
         * @type {?module:ol/render/canvas~FillState}
         */
        this.textFillState_ = null;

        /**
         * @type {!Object.<string, module:ol/render/canvas~FillState>}
         */
        this.fillStates = {};

        /**
         * @private
         * @type {?module:ol/render/canvas~StrokeState}
         */
        this.textStrokeState_ = null;

        /**
         * @type {!Object.<string, module:ol/render/canvas~StrokeState>}
         */
        this.strokeStates = {};

        /**
         * @private
         * @type {module:ol/render/canvas~TextState}
         */
        this.textState_ = /** @type {module:ol/render/canvas~TextState} */ ({});

        /**
         * @type {!Object.<string, module:ol/render/canvas~TextState>}
         */
        this.textStates = {};

        /**
         * @private
         * @type {string}
         */
        this.textKey_ = '';

        /**
         * @private
         * @type {string}
         */
        this.fillKey_ = '';

        /**
         * @private
         * @type {string}
         */
        this.strokeKey_ = '';

        /**
         * @private
         * @type {Object.<string, Object.<string, number>>}
         */
        this.widths_ = {};

        labelCache.prune();

      }

      if ( CanvasReplay$$1 ) CanvasTextReplay.__proto__ = CanvasReplay$$1;
      CanvasTextReplay.prototype = Object.create( CanvasReplay$$1 && CanvasReplay$$1.prototype );
      CanvasTextReplay.prototype.constructor = CanvasTextReplay;

      /**
       * @inheritDoc
       */
      CanvasTextReplay.prototype.drawText = function drawText (geometry, feature) {
        var this$1 = this;

        var fillState = this.textFillState_;
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
          return;
        }

        var begin = this.coordinates.length;

        var geometryType = geometry.getType();
        var flatCoordinates = null;
        var end = 2;
        var stride = 2;
        var i, ii;

        if (textState.placement === TextPlacement.LINE) {
          if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
            return;
          }
          var ends;
          flatCoordinates = geometry.getFlatCoordinates();
          stride = geometry.getStride();
          if (geometryType == GeometryType.LINE_STRING) {
            ends = [flatCoordinates.length];
          } else if (geometryType == GeometryType.MULTI_LINE_STRING) {
            ends = geometry.getEnds();
          } else if (geometryType == GeometryType.POLYGON) {
            ends = geometry.getEnds().slice(0, 1);
          } else if (geometryType == GeometryType.MULTI_POLYGON) {
            var endss = geometry.getEndss();
            ends = [];
            for (i = 0, ii = endss.length; i < ii; ++i) {
              ends.push(endss[i][0]);
            }
          }
          this.beginGeometry(geometry, feature);
          var textAlign = textState.textAlign;
          var flatOffset = 0;
          var flatEnd;
          for (var o = 0, oo = ends.length; o < oo; ++o) {
            if (textAlign == undefined) {
              var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
              flatOffset = range[0];
              flatEnd = range[1];
            } else {
              flatEnd = ends[o];
            }
            for (i = flatOffset; i < flatEnd; i += stride) {
              this$1.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
            }
            end = this$1.coordinates.length;
            flatOffset = ends[o];
            this$1.drawChars_(begin, end, this$1.declutterGroup_);
            begin = end;
          }
          this.endGeometry(geometry, feature);

        } else {
          var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
          var width = label.width / this.pixelRatio;
          switch (geometryType) {
            case GeometryType.POINT:
            case GeometryType.MULTI_POINT:
              flatCoordinates = geometry.getFlatCoordinates();
              end = flatCoordinates.length;
              break;
            case GeometryType.LINE_STRING:
              flatCoordinates = /** @type {module:ol/geom/LineString} */ (geometry).getFlatMidpoint();
              break;
            case GeometryType.CIRCLE:
              flatCoordinates = /** @type {module:ol/geom/Circle} */ (geometry).getCenter();
              break;
            case GeometryType.MULTI_LINE_STRING:
              flatCoordinates = /** @type {module:ol/geom/MultiLineString} */ (geometry).getFlatMidpoints();
              end = flatCoordinates.length;
              break;
            case GeometryType.POLYGON:
              flatCoordinates = /** @type {module:ol/geom/Polygon} */ (geometry).getFlatInteriorPoint();
              if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
                return;
              }
              stride = 3;
              break;
            case GeometryType.MULTI_POLYGON:
              var interiorPoints = /** @type {module:ol/geom/MultiPolygon} */ (geometry).getFlatInteriorPoints();
              flatCoordinates = [];
              for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                if (textState.overflow || interiorPoints[i + 2] / this$1.resolution >= width) {
                  flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                }
              }
              end = flatCoordinates.length;
              if (end == 0) {
                return;
              }
              break;
            default:
          }
          end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
          if (textState.backgroundFill || textState.backgroundStroke) {
            this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
            if (textState.backgroundFill) {
              this.updateFillStyle(this.state, this.createFill, geometry);
              this.hitDetectionInstructions.push(this.createFill(this.state, geometry));
            }
            if (textState.backgroundStroke) {
              this.updateStrokeStyle(this.state, this.applyStroke);
              this.hitDetectionInstructions.push(this.createStroke(this.state));
            }
          }
          this.beginGeometry(geometry, feature);
          this.drawTextImage_(label, begin, end);
          this.endGeometry(geometry, feature);
        }
      };

      /**
       * @param {string} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {HTMLCanvasElement} Image.
       */
      CanvasTextReplay.prototype.getImage = function getImage (text, textKey, fillKey, strokeKey) {
        var label;
        var key = strokeKey + textKey + text + fillKey + this.pixelRatio;

        if (!labelCache.containsKey(key)) {
          var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
          var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
          var textState = this.textStates[textKey] || this.textState_;
          var pixelRatio = this.pixelRatio;
          var scale = textState.scale * pixelRatio;
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

          var lines = text.split('\n');
          var numLines = lines.length;
          var widths = [];
          var width = measureTextWidths(textState.font, lines, widths);
          var lineHeight = measureTextHeight(textState.font);
          var height = lineHeight * numLines;
          var renderWidth = (width + strokeWidth);
          var context = createCanvasContext2D(
            Math.ceil(renderWidth * scale),
            Math.ceil((height + strokeWidth) * scale));
          label = context.canvas;
          labelCache.set(key, label);
          if (scale != 1) {
            context.scale(scale, scale);
          }
          context.font = textState.font;
          if (strokeKey) {
            context.strokeStyle = strokeState.strokeStyle;
            context.lineWidth = strokeWidth;
            context.lineCap = strokeState.lineCap;
            context.lineJoin = strokeState.lineJoin;
            context.miterLimit = strokeState.miterLimit;
            if (CANVAS_LINE_DASH && strokeState.lineDash.length) {
              context.setLineDash(strokeState.lineDash);
              context.lineDashOffset = strokeState.lineDashOffset;
            }
          }
          if (fillKey) {
            context.fillStyle = fillState.fillStyle;
          }
          context.textBaseline = 'middle';
          context.textAlign = 'center';
          var leftRight = (0.5 - align);
          var x = align * label.width / scale + leftRight * strokeWidth;
          var i;
          if (strokeKey) {
            for (i = 0; i < numLines; ++i) {
              context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
            }
          }
          if (fillKey) {
            for (i = 0; i < numLines; ++i) {
              context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
            }
          }
        }
        return labelCache.get(key);
      };

      /**
       * @private
       * @param {HTMLCanvasElement} label Label.
       * @param {number} begin Begin.
       * @param {number} end End.
       */
      CanvasTextReplay.prototype.drawTextImage_ = function drawTextImage_ (label, begin, end) {
        var textState = this.textState_;
        var strokeState = this.textStrokeState_;
        var pixelRatio = this.pixelRatio;
        var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
        var baseline = TEXT_ALIGN[textState.textBaseline];
        var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

        var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
        var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        this.instructions.push([Instruction.DRAW_IMAGE, begin, end,
          label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
          this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
          1, true, label.width,
          textState.padding == defaultPadding ?
            defaultPadding : textState.padding.map(function(p) {
              return p * pixelRatio;
            }),
          !!textState.backgroundFill, !!textState.backgroundStroke
        ]);
        this.hitDetectionInstructions.push([Instruction.DRAW_IMAGE, begin, end,
          label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio,
          this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_,
          1 / pixelRatio, true, label.width, textState.padding,
          !!textState.backgroundFill, !!textState.backgroundStroke
        ]);
      };

      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       * @param {module:ol/render/canvas~DeclutterGroup} declutterGroup Declutter group.
       */
      CanvasTextReplay.prototype.drawChars_ = function drawChars_ (begin, end, declutterGroup) {
        var strokeState = this.textStrokeState_;
        var textState = this.textState_;
        var fillState = this.textFillState_;

        var strokeKey = this.strokeKey_;
        if (strokeState) {
          if (!(strokeKey in this.strokeStates)) {
            this.strokeStates[strokeKey] = /** @type {module:ol/render/canvas~StrokeState} */ ({
              strokeStyle: strokeState.strokeStyle,
              lineCap: strokeState.lineCap,
              lineDashOffset: strokeState.lineDashOffset,
              lineWidth: strokeState.lineWidth,
              lineJoin: strokeState.lineJoin,
              miterLimit: strokeState.miterLimit,
              lineDash: strokeState.lineDash
            });
          }
        }
        var textKey = this.textKey_;
        if (!(this.textKey_ in this.textStates)) {
          this.textStates[this.textKey_] = /** @type {module:ol/render/canvas~TextState} */ ({
            font: textState.font,
            textAlign: textState.textAlign || defaultTextAlign,
            scale: textState.scale
          });
        }
        var fillKey = this.fillKey_;
        if (fillState) {
          if (!(fillKey in this.fillStates)) {
            this.fillStates[fillKey] = /** @type {module:ol/render/canvas~FillState} */ ({
              fillStyle: fillState.fillStyle
            });
          }
        }

        var pixelRatio = this.pixelRatio;
        var baseline = TEXT_ALIGN[textState.textBaseline];

        var offsetY = this.textOffsetY_ * pixelRatio;
        var text = this.text_;
        var font = textState.font;
        var textScale = textState.scale;
        var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
        var widths = this.widths_[font];
        if (!widths) {
          this.widths_[font] = widths = {};
        }
        this.instructions.push([Instruction.DRAW_CHARS,
          begin, end, baseline, declutterGroup,
          textState.overflow, fillKey, textState.maxAngle,
          function(text) {
            var width = widths[text];
            if (!width) {
              width = widths[text] = measureTextWidth(font, text);
            }
            return width * textScale * pixelRatio;
          },
          offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1
        ]);
        this.hitDetectionInstructions.push([Instruction.DRAW_CHARS,
          begin, end, baseline, declutterGroup,
          textState.overflow, fillKey, textState.maxAngle,
          function(text) {
            var width = widths[text];
            if (!width) {
              width = widths[text] = measureTextWidth(font, text);
            }
            return width * textScale;
          },
          offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio
        ]);
      };

      /**
       * @inheritDoc
       */
      CanvasTextReplay.prototype.setTextStyle = function setTextStyle (textStyle, declutterGroup) {
        var textState, fillState, strokeState;
        if (!textStyle) {
          this.text_ = '';
        } else {
          this.declutterGroup_ = /** @type {module:ol/render/canvas~DeclutterGroup} */ (declutterGroup);

          var textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            fillState = this.textFillState_ = null;
          } else {
            fillState = this.textFillState_;
            if (!fillState) {
              fillState = this.textFillState_ = /** @type {module:ol/render/canvas~FillState} */ ({});
            }
            fillState.fillStyle = asColorLike(
              textFillStyle.getColor() || defaultFillStyle);
          }

          var textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            strokeState = this.textStrokeState_ = null;
          } else {
            strokeState = this.textStrokeState_;
            if (!strokeState) {
              strokeState = this.textStrokeState_ = /** @type {module:ol/render/canvas~StrokeState} */ ({});
            }
            var lineDash = textStrokeStyle.getLineDash();
            var lineDashOffset = textStrokeStyle.getLineDashOffset();
            var lineWidth = textStrokeStyle.getWidth();
            var miterLimit = textStrokeStyle.getMiterLimit();
            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
            strokeState.lineDashOffset =
                lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
            strokeState.lineWidth =
                lineWidth === undefined ? defaultLineWidth : lineWidth;
            strokeState.miterLimit =
                miterLimit === undefined ? defaultMiterLimit : miterLimit;
            strokeState.strokeStyle = asColorLike(
              textStrokeStyle.getColor() || defaultStrokeStyle);
          }

          textState = this.textState_;
          var font = textStyle.getFont() || defaultFont;
          checkFont(font);
          var textScale = textStyle.getScale();
          textState.overflow = textStyle.getOverflow();
          textState.font = font;
          textState.maxAngle = textStyle.getMaxAngle();
          textState.placement = textStyle.getPlacement();
          textState.textAlign = textStyle.getTextAlign();
          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
          textState.backgroundFill = textStyle.getBackgroundFill();
          textState.backgroundStroke = textStyle.getBackgroundStroke();
          textState.padding = textStyle.getPadding() || defaultPadding;
          textState.scale = textScale === undefined ? 1 : textScale;

          var textOffsetX = textStyle.getOffsetX();
          var textOffsetY = textStyle.getOffsetY();
          var textRotateWithView = textStyle.getRotateWithView();
          var textRotation = textStyle.getRotation();
          this.text_ = textStyle.getText() || '';
          this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
          this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
          this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
          this.textRotation_ = textRotation === undefined ? 0 : textRotation;

          this.strokeKey_ = strokeState ?
            (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) +
            strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth +
            strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' :
            '';
          this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
          this.fillKey_ = fillState ?
            (typeof fillState.fillStyle == 'string' ? fillState.fillStyle : ('|' + getUid(fillState.fillStyle))) :
            '';
        }
      };

      return CanvasTextReplay;
    }(CanvasReplay));


    /**
     * @param {string} font Font to use for measuring.
     * @param {Array.<string>} lines Lines to measure.
     * @param {Array.<number>} widths Array will be populated with the widths of
     * each line.
     * @return {number} Width of the whole text.
     */
    function measureTextWidths(font, lines, widths) {
      var numLines = lines.length;
      var width = 0;
      for (var i = 0; i < numLines; ++i) {
        var currentWidth = measureTextWidth(font, lines[i]);
        width = Math.max(width, currentWidth);
        widths.push(currentWidth);
      }
      return width;
    }

    /**
     * @module ol/render/canvas/ReplayGroup
     */


    /**
     * @type {Object.<module:ol/render/ReplayType,
     *                function(new: module:ol/render/canvas/Replay, number, module:ol/extent~Extent,
     *                number, number, boolean, Array.<module:ol/render/canvas~DeclutterGroup>)>}
     */
    var BATCH_CONSTRUCTORS = {
      'Circle': CanvasPolygonReplay,
      'Default': CanvasReplay,
      'Image': CanvasImageReplay,
      'LineString': CanvasLineStringReplay,
      'Polygon': CanvasPolygonReplay,
      'Text': CanvasTextReplay
    };


    var CanvasReplayGroup = (function (ReplayGroup$$1) {
      function CanvasReplayGroup(
        tolerance,
        maxExtent,
        resolution,
        pixelRatio,
        overlaps,
        declutterTree,
        opt_renderBuffer
      ) {
        ReplayGroup$$1.call(this);

        /**
         * Declutter tree.
         * @private
         */
        this.declutterTree_ = declutterTree;

        /**
         * @type {module:ol/render/canvas~DeclutterGroup}
         * @private
         */
        this.declutterGroup_ = null;

        /**
         * @private
         * @type {number}
         */
        this.tolerance_ = tolerance;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.maxExtent_ = maxExtent;

        /**
         * @private
         * @type {boolean}
         */
        this.overlaps_ = overlaps;

        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;

        /**
         * @private
         * @type {number}
         */
        this.resolution_ = resolution;

        /**
         * @private
         * @type {number|undefined}
         */
        this.renderBuffer_ = opt_renderBuffer;

        /**
         * @private
         * @type {!Object.<string, !Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>}
         */
        this.replaysByZIndex_ = {};

        /**
         * @private
         * @type {CanvasRenderingContext2D}
         */
        this.hitDetectionContext_ = createCanvasContext2D(1, 1);

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.hitDetectionTransform_ = create();
      }

      if ( ReplayGroup$$1 ) CanvasReplayGroup.__proto__ = ReplayGroup$$1;
      CanvasReplayGroup.prototype = Object.create( ReplayGroup$$1 && ReplayGroup$$1.prototype );
      CanvasReplayGroup.prototype.constructor = CanvasReplayGroup;

      /**
       * @param {boolean} group Group with previous replay.
       * @return {module:ol/render/canvas~DeclutterGroup} Declutter instruction group.
       */
      CanvasReplayGroup.prototype.addDeclutter = function addDeclutter (group) {
        var declutter = null;
        if (this.declutterTree_) {
          if (group) {
            declutter = this.declutterGroup_;
            /** @type {number} */ (declutter[4])++;
          } else {
            declutter = this.declutterGroup_ = createEmpty();
            declutter.push(1);
          }
        }
        return declutter;
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/transform~Transform} transform Transform.
       */
      CanvasReplayGroup.prototype.clip = function clip (context, transform) {
        var flatClipCoords = this.getClipCoords(transform);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
      };

      /**
       * @param {Array.<module:ol/render/ReplayType>} replays Replays.
       * @return {boolean} Has replays of the provided types.
       */
      CanvasReplayGroup.prototype.hasReplays = function hasReplays (replays) {
        var this$1 = this;

        for (var zIndex in this$1.replaysByZIndex_) {
          var candidates = this$1.replaysByZIndex_[zIndex];
          for (var i = 0, ii = replays.length; i < ii; ++i) {
            if (replays[i] in candidates) {
              return true;
            }
          }
        }
        return false;
      };

      /**
       * FIXME empty description for jsdoc
       */
      CanvasReplayGroup.prototype.finish = function finish () {
        var this$1 = this;

        for (var zKey in this$1.replaysByZIndex_) {
          var replays = this$1.replaysByZIndex_[zKey];
          for (var replayKey in replays) {
            replays[replayKey].finish();
          }
        }
      };

      /**
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.
       * @param {function((module:ol/Feature|module:ol/render/Feature)): T} callback Feature callback.
       * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>} declutterReplays Declutter replays.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CanvasReplayGroup.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (
        coordinate,
        resolution,
        rotation,
        hitTolerance,
        skippedFeaturesHash,
        callback,
        declutterReplays
      ) {
        var this$1 = this;


        hitTolerance = Math.round(hitTolerance);
        var contextSize = hitTolerance * 2 + 1;
        var transform = compose(this.hitDetectionTransform_,
          hitTolerance + 0.5, hitTolerance + 0.5,
          1 / resolution, -1 / resolution,
          -rotation,
          -coordinate[0], -coordinate[1]);
        var context = this.hitDetectionContext_;

        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
          context.canvas.width = contextSize;
          context.canvas.height = contextSize;
        } else {
          context.clearRect(0, 0, contextSize, contextSize);
        }

        /**
         * @type {module:ol/extent~Extent}
         */
        var hitExtent;
        if (this.renderBuffer_ !== undefined) {
          hitExtent = createEmpty();
          extendCoordinate(hitExtent, coordinate);
          buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
        }

        var mask = getCircleArray(hitTolerance);
        var declutteredFeatures;
        if (this.declutterTree_) {
          declutteredFeatures = this.declutterTree_.all().map(function(entry) {
            return entry.value;
          });
        }

        var replayType;

        /**
         * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
         * @return {?} Callback result.
         */
        function featureCallback(feature) {
          var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
          for (var i = 0; i < contextSize; i++) {
            for (var j = 0; j < contextSize; j++) {
              if (mask[i][j]) {
                if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
                  var result = (void 0);
                  if (!(declutteredFeatures && (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) ||
                      declutteredFeatures.indexOf(feature) !== -1) {
                    result = callback(feature);
                  }
                  if (result) {
                    return result;
                  } else {
                    context.clearRect(0, 0, contextSize, contextSize);
                    return undefined;
                  }
                }
              }
            }
          }
        }

        /** @type {Array.<number>} */
        var zs = Object.keys(this.replaysByZIndex_).map(Number);
        zs.sort(numberSafeCompareFunction);

        var i, j, replays, replay, result;
        for (i = zs.length - 1; i >= 0; --i) {
          var zIndexKey = zs[i].toString();
          replays = this$1.replaysByZIndex_[zIndexKey];
          for (j = ORDER.length - 1; j >= 0; --j) {
            replayType = ORDER[j];
            replay = replays[replayType];
            if (replay !== undefined) {
              if (declutterReplays &&
                  (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {
                var declutter = declutterReplays[zIndexKey];
                if (!declutter) {
                  declutterReplays[zIndexKey] = [replay, transform.slice(0)];
                } else {
                  declutter.push(replay, transform.slice(0));
                }
              } else {
                result = replay.replayHitDetection(context, transform, rotation,
                  skippedFeaturesHash, featureCallback, hitExtent);
                if (result) {
                  return result;
                }
              }
            }
          }
        }
        return undefined;
      };

      /**
       * @param {module:ol/transform~Transform} transform Transform.
       * @return {Array.<number>} Clip coordinates.
       */
      CanvasReplayGroup.prototype.getClipCoords = function getClipCoords (transform) {
        var maxExtent = this.maxExtent_;
        var minX = maxExtent[0];
        var minY = maxExtent[1];
        var maxX = maxExtent[2];
        var maxY = maxExtent[3];
        var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        transform2D(
          flatClipCoords, 0, 8, 2, transform, flatClipCoords);
        return flatClipCoords;
      };

      /**
       * @inheritDoc
       */
      CanvasReplayGroup.prototype.getReplay = function getReplay (zIndex, replayType) {
        var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
        var replays = this.replaysByZIndex_[zIndexKey];
        if (replays === undefined) {
          replays = {};
          this.replaysByZIndex_[zIndexKey] = replays;
        }
        var replay = replays[replayType];
        if (replay === undefined) {
          var Constructor = BATCH_CONSTRUCTORS[replayType];
          replay = new Constructor(this.tolerance_, this.maxExtent_,
            this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
          replays[replayType] = replay;
        }
        return replay;
      };

      /**
       * @return {Object.<string, Object.<module:ol/render/ReplayType, module:ol/render/canvas/Replay>>} Replays.
       */
      CanvasReplayGroup.prototype.getReplays = function getReplays () {
        return this.replaysByZIndex_;
      };

      /**
       * @inheritDoc
       */
      CanvasReplayGroup.prototype.isEmpty = function isEmpty$1$$1 () {
        return isEmpty(this.replaysByZIndex_);
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/transform~Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features to skip.
       * @param {Array.<module:ol/render/ReplayType>=} opt_replayTypes Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {Object.<string, module:ol/render/canvas~DeclutterGroup>=} opt_declutterReplays Declutter replays.
       */
      CanvasReplayGroup.prototype.replay = function replay (
        context,
        transform,
        viewRotation,
        skippedFeaturesHash,
        opt_replayTypes,
        opt_declutterReplays
      ) {
        var this$1 = this;


        /** @type {Array.<number>} */
        var zs = Object.keys(this.replaysByZIndex_).map(Number);
        zs.sort(numberSafeCompareFunction);

        // setup clipping so that the parts of over-simplified geometries are not
        // visible outside the current extent when panning
        context.save();
        this.clip(context, transform);

        var replayTypes = opt_replayTypes ? opt_replayTypes : ORDER;
        var i, ii, j, jj, replays, replay;
        for (i = 0, ii = zs.length; i < ii; ++i) {
          var zIndexKey = zs[i].toString();
          replays = this$1.replaysByZIndex_[zIndexKey];
          for (j = 0, jj = replayTypes.length; j < jj; ++j) {
            var replayType = replayTypes[j];
            replay = replays[replayType];
            if (replay !== undefined) {
              if (opt_declutterReplays &&
                  (replayType == ReplayType.IMAGE || replayType == ReplayType.TEXT)) {
                var declutter = opt_declutterReplays[zIndexKey];
                if (!declutter) {
                  opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
                } else {
                  declutter.push(replay, transform.slice(0));
                }
              } else {
                replay.replay(context, transform, viewRotation, skippedFeaturesHash);
              }
            }
          }
        }

        context.restore();
      };

      return CanvasReplayGroup;
    }(ReplayGroup));


    /**
     * This cache is used for storing calculated pixel circles for increasing performance.
     * It is a static property to allow each Replaygroup to access it.
     * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
     */
    var circleArrayCache = {
      0: [[true]]
    };


    /**
     * This method fills a row in the array from the given coordinate to the
     * middle with `true`.
     * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
     * @param {number} x X coordinate.
     * @param {number} y Y coordinate.
     */
    function fillCircleArrayRowToMiddle(array, x, y) {
      var i;
      var radius = Math.floor(array.length / 2);
      if (x >= radius) {
        for (i = radius; i < x; i++) {
          array[i][y] = true;
        }
      } else if (x < radius) {
        for (i = x + 1; i < radius; i++) {
          array[i][y] = true;
        }
      }
    }


    /**
     * This methods creates a circle inside a fitting array. Points inside the
     * circle are marked by true, points on the outside are undefined.
     * It uses the midpoint circle algorithm.
     * A cache is used to increase performance.
     * @param {number} radius Radius.
     * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
     */
    function getCircleArray(radius) {
      if (circleArrayCache[radius] !== undefined) {
        return circleArrayCache[radius];
      }

      var arraySize = radius * 2 + 1;
      var arr = new Array(arraySize);
      for (var i = 0; i < arraySize; i++) {
        arr[i] = new Array(arraySize);
      }

      var x = radius;
      var y = 0;
      var error = 0;

      while (x >= y) {
        fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
        fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
        fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
        fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
        fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
        fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
        fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
        fillCircleArrayRowToMiddle(arr, radius + x, radius - y);

        y++;
        error += 1 + 2 * y;
        if (2 * (error - x) + 1 > 0) {
          x -= 1;
          error += 1 - 2 * x;
        }
      }

      circleArrayCache[radius] = arr;
      return arr;
    }


    /**
     * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} rotation Rotation.
     */
    function replayDeclutter(declutterReplays, context, rotation) {
      var zs = Object.keys(declutterReplays).map(Number).sort(numberSafeCompareFunction);
      var skippedFeatureUids = {};
      for (var z = 0, zz = zs.length; z < zz; ++z) {
        var replayData = declutterReplays[zs[z].toString()];
        for (var i = 0, ii = replayData.length; i < ii;) {
          var replay = replayData[i++];
          var transform = replayData[i++];
          replay.replay(context, transform, rotation, skippedFeatureUids);
        }
      }
    }

    /**
     * @module ol/renderer/vector
     */


    /**
     * Tolerance for geometry simplification in device pixels.
     * @type {number}
     */
    var SIMPLIFY_TOLERANCE = 0.5;


    /**
     * @const
     * @type {Object.<module:ol/geom/GeometryType,
     *                function(module:ol/render/ReplayGroup, module:ol/geom/Geometry,
     *                         module:ol/style/Style, Object)>}
     */
    var GEOMETRY_RENDERERS = {
      'Point': renderPointGeometry,
      'LineString': renderLineStringGeometry,
      'Polygon': renderPolygonGeometry,
      'MultiPoint': renderMultiPointGeometry,
      'MultiLineString': renderMultiLineStringGeometry,
      'MultiPolygon': renderMultiPolygonGeometry,
      'GeometryCollection': renderGeometryCollectionGeometry,
      'Circle': renderCircleGeometry
    };


    /**
     * @param {module:ol/Feature|module:ol/render/Feature} feature1 Feature 1.
     * @param {module:ol/Feature|module:ol/render/Feature} feature2 Feature 2.
     * @return {number} Order.
     */
    function defaultOrder(feature1, feature2) {
      return getUid(feature1) - getUid(feature2);
    }


    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Squared pixel tolerance.
     */
    function getSquaredTolerance(resolution, pixelRatio) {
      var tolerance = getTolerance(resolution, pixelRatio);
      return tolerance * tolerance;
    }


    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel tolerance.
     */
    function getTolerance(resolution, pixelRatio) {
      return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/Circle} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature} feature Feature.
     */
    function renderCircleGeometry(replayGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
        var circleReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.CIRCLE);
        circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        circleReplay.drawCircle(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     * @param {module:ol/style/Style} style Style.
     * @param {number} squaredTolerance Squared tolerance.
     * @param {function(this: T, module:ol/events/Event)} listener Listener function.
     * @param {T} thisArg Value to use as `this` when executing `listener`.
     * @return {boolean} `true` if style is loading.
     * @template T
     */
    function renderFeature(replayGroup, feature, style, squaredTolerance, listener, thisArg) {
      var loading = false;
      var imageStyle = style.getImage();
      if (imageStyle) {
        var imageState = imageStyle.getImageState();
        if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
          imageStyle.unlistenImageChange(listener, thisArg);
        } else {
          if (imageState == ImageState.IDLE) {
            imageStyle.load();
          }
          imageState = imageStyle.getImageState();
          imageStyle.listenImageChange(listener, thisArg);
          loading = true;
        }
      }
      renderFeatureInternal(replayGroup, feature, style, squaredTolerance);

      return loading;
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     * @param {module:ol/style/Style} style Style.
     * @param {number} squaredTolerance Squared tolerance.
     */
    function renderFeatureInternal(replayGroup, feature, style, squaredTolerance) {
      var geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
        return;
      }
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      var renderer = style.getRenderer();
      if (renderer) {
        renderGeometry(replayGroup, simplifiedGeometry, style, feature);
      } else {
        var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
        geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/Geometry} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderGeometry(replayGroup, geometry, style, feature) {
      if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
        var geometries = /** @type {module:ol/geom/GeometryCollection} */ (geometry).getGeometries();
        for (var i = 0, ii = geometries.length; i < ii; ++i) {
          renderGeometry(replayGroup, geometries[i], style, feature);
        }
        return;
      }
      var replay = replayGroup.getReplay(style.getZIndex(), ReplayType.DEFAULT);
      replay.drawCustom(/** @type {module:ol/geom/SimpleGeometry} */ (geometry), feature, style.getRenderer());
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/GeometryCollection} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature} feature Feature.
     */
    function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
      var geometries = geometry.getGeometriesArray();
      var i, ii;
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        var geometryRenderer =
            GEOMETRY_RENDERERS[geometries[i].getType()];
        geometryRenderer(replayGroup, geometries[i], style, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/LineString|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderLineStringGeometry(replayGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
        var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/MultiLineString|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderMultiLineStringGeometry(replayGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
        var lineStringReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.LINE_STRING);
        lineStringReplay.setFillStrokeStyle(null, strokeStyle);
        lineStringReplay.drawMultiLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/MultiPolygon} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature} feature Feature.
     */
    function renderMultiPolygonGeometry(replayGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (strokeStyle || fillStyle) {
        var polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawMultiPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/Point|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderPointGeometry(replayGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
        if (imageStyle.getImageState() != ImageState.LOADED) {
          return;
        }
        var imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);
        imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
        imageReplay.drawPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/MultiPoint|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderMultiPointGeometry(replayGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
        if (imageStyle.getImageState() != ImageState.LOADED) {
          return;
        }
        var imageReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.IMAGE);
        imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
        imageReplay.drawMultiPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
        textReplay.drawText(geometry, feature);
      }
    }


    /**
     * @param {module:ol/render/ReplayGroup} replayGroup Replay group.
     * @param {module:ol/geom/Polygon|module:ol/render/Feature} geometry Geometry.
     * @param {module:ol/style/Style} style Style.
     * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
     */
    function renderPolygonGeometry(replayGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
        var polygonReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.POLYGON);
        polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
        polygonReplay.drawPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
        var textReplay = replayGroup.getReplay(style.getZIndex(), ReplayType.TEXT);
        textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
        textReplay.drawText(geometry, feature);
      }
    }

    /**
     * @module ol/renderer/canvas/VectorLayer
     */

    /**
     * @classdesc
     * Canvas renderer for vector layers.
     * @api
     */
    var CanvasVectorLayerRenderer = (function (CanvasLayerRenderer$$1) {
      function CanvasVectorLayerRenderer(vectorLayer) {

        CanvasLayerRenderer$$1.call(this, vectorLayer);

        /**
         * Declutter tree.
         * @private
         */
        this.declutterTree_ = vectorLayer.getDeclutter() ? C__Users_rendr_nextgis_nextgisweb_frontend_packages_olMapAdapter_node_modules_rbush(9, undefined) : null;

        /**
         * @private
         * @type {boolean}
         */
        this.dirty_ = false;

        /**
         * @private
         * @type {number}
         */
        this.renderedRevision_ = -1;

        /**
         * @private
         * @type {number}
         */
        this.renderedResolution_ = NaN;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.renderedExtent_ = createEmpty();

        /**
         * @private
         * @type {function(module:ol/Feature, module:ol/Feature): number|null}
         */
        this.renderedRenderOrder_ = null;

        /**
         * @private
         * @type {module:ol/render/canvas/ReplayGroup}
         */
        this.replayGroup_ = null;

        /**
         * A new replay group had to be created by `prepareFrame()`
         * @type {boolean}
         */
        this.replayGroupChanged = true;

        /**
         * @type {CanvasRenderingContext2D}
         */
        this.context = createCanvasContext2D();

        listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);

      }

      if ( CanvasLayerRenderer$$1 ) CanvasVectorLayerRenderer.__proto__ = CanvasLayerRenderer$$1;
      CanvasVectorLayerRenderer.prototype = Object.create( CanvasLayerRenderer$$1 && CanvasLayerRenderer$$1.prototype );
      CanvasVectorLayerRenderer.prototype.constructor = CanvasVectorLayerRenderer;

      /**
       * @inheritDoc
       */
      CanvasVectorLayerRenderer.prototype.disposeInternal = function disposeInternal () {
        unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);
        CanvasLayerRenderer$$1.prototype.disposeInternal.call(this);
      };

      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @param {module:ol/layer/Layer~State} layerState Layer state.
       */
      CanvasVectorLayerRenderer.prototype.compose = function compose (context, frameState, layerState) {
        var this$1 = this;

        var extent = frameState.extent;
        var pixelRatio = frameState.pixelRatio;
        var skippedFeatureUids = layerState.managed ?
          frameState.skippedFeatureUids : {};
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var rotation = viewState.rotation;
        var projectionExtent = projection.getExtent();
        var vectorSource = /** @type {module:ol/source/Vector} */ (this.getLayer().getSource());

        var transform = this.getTransform(frameState, 0);

        // clipped rendering if layer extent is set
        var clipExtent = layerState.extent;
        var clipped = clipExtent !== undefined;
        if (clipped) {
          this.clip(context, frameState, /** @type {module:ol/extent~Extent} */ (clipExtent));
        }
        var replayGroup = this.replayGroup_;
        if (replayGroup && !replayGroup.isEmpty()) {
          if (this.declutterTree_) {
            this.declutterTree_.clear();
          }
          var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
          var drawOffsetX = 0;
          var drawOffsetY = 0;
          var replayContext;
          var transparentLayer = layerState.opacity !== 1;
          var hasRenderListeners = layer.hasListener(RenderEventType.RENDER);
          if (transparentLayer || hasRenderListeners) {
            var drawWidth = context.canvas.width;
            var drawHeight = context.canvas.height;
            if (rotation) {
              var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
              drawOffsetX = (drawSize - drawWidth) / 2;
              drawOffsetY = (drawSize - drawHeight) / 2;
              drawWidth = drawHeight = drawSize;
            }
            // resize and clear
            this.context.canvas.width = drawWidth;
            this.context.canvas.height = drawHeight;
            replayContext = this.context;
          } else {
            replayContext = context;
          }

          var alpha = replayContext.globalAlpha;
          if (!transparentLayer) {
            // for performance reasons, context.save / context.restore is not used
            // to save and restore the transformation matrix and the opacity.
            // see http://jsperf.com/context-save-restore-versus-variable
            replayContext.globalAlpha = layerState.opacity;
          }

          if (replayContext != context) {
            replayContext.translate(drawOffsetX, drawOffsetY);
          }

          var width = frameState.size[0] * pixelRatio;
          var height = frameState.size[1] * pixelRatio;
          rotateAtOffset(replayContext, -rotation,
            width / 2, height / 2);
          replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
          if (vectorSource.getWrapX() && projection.canWrapX() &&
              !containsExtent(projectionExtent, extent)) {
            var startX = extent[0];
            var worldWidth = getWidth(projectionExtent);
            var world = 0;
            var offsetX;
            while (startX < projectionExtent[0]) {
              --world;
              offsetX = worldWidth * world;
              transform = this$1.getTransform(frameState, offsetX);
              replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
              startX += worldWidth;
            }
            world = 0;
            startX = extent[2];
            while (startX > projectionExtent[2]) {
              ++world;
              offsetX = worldWidth * world;
              transform = this$1.getTransform(frameState, offsetX);
              replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
              startX -= worldWidth;
            }
          }
          rotateAtOffset(replayContext, rotation,
            width / 2, height / 2);

          if (hasRenderListeners) {
            this.dispatchRenderEvent(replayContext, frameState, transform);
          }
          if (replayContext != context) {
            if (transparentLayer) {
              var mainContextAlpha = context.globalAlpha;
              context.globalAlpha = layerState.opacity;
              context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
              context.globalAlpha = mainContextAlpha;
            } else {
              context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
            }
            replayContext.translate(-drawOffsetX, -drawOffsetY);
          }

          if (!transparentLayer) {
            replayContext.globalAlpha = alpha;
          }
        }

        if (clipped) {
          context.restore();
        }
      };

      /**
       * @inheritDoc
       */
      CanvasVectorLayerRenderer.prototype.composeFrame = function composeFrame (frameState, layerState, context) {
        var transform = this.getTransform(frameState, 0);
        this.preCompose(context, frameState, transform);
        this.compose(context, frameState, layerState);
        this.postCompose(context, frameState, layerState, transform);
      };

      /**
       * @inheritDoc
       */
      CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        if (!this.replayGroup_) {
          return undefined;
        } else {
          var resolution = frameState.viewState.resolution;
          var rotation = frameState.viewState.rotation;
          var layer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
          /** @type {!Object.<string, boolean>} */
          var features = {};
          var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
            /**
             * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
             * @return {?} Callback result.
             */
            function(feature) {
              var key = getUid(feature).toString();
              if (!(key in features)) {
                features[key] = true;
                return callback.call(thisArg, feature, layer);
              }
            }, null);
          return result;
        }
      };

      /**
       * @param {module:ol/events/Event} event Event.
       */
      CanvasVectorLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
        var layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
          layer.changed();
        }
      };

      /**
       * Handle changes in image style state.
       * @param {module:ol/events/Event} event Image style change event.
       * @private
       */
      CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
        this.renderIfReadyAndVisible();
      };

      /**
       * @inheritDoc
       */
      CanvasVectorLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
        var vectorLayer = /** @type {module:ol/layer/Vector} */ (this.getLayer());
        var vectorSource = vectorLayer.getSource();

        var animating = frameState.viewHints[ViewHint.ANIMATING];
        var interacting = frameState.viewHints[ViewHint.INTERACTING];
        var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

        if (!this.dirty_ && (!updateWhileAnimating && animating) ||
            (!updateWhileInteracting && interacting)) {
          return true;
        }

        var frameStateExtent = frameState.extent;
        var viewState = frameState.viewState;
        var projection = viewState.projection;
        var resolution = viewState.resolution;
        var pixelRatio = frameState.pixelRatio;
        var vectorLayerRevision = vectorLayer.getRevision();
        var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

        if (vectorLayerRenderOrder === undefined) {
          vectorLayerRenderOrder = defaultOrder;
        }

        var extent = buffer(frameStateExtent,
          vectorLayerRenderBuffer * resolution);
        var projectionExtent = viewState.projection.getExtent();

        if (vectorSource.getWrapX() && viewState.projection.canWrapX() &&
            !containsExtent(projectionExtent, frameState.extent)) {
          // For the replay group, we need an extent that intersects the real world
          // (-180° to +180°). To support geometries in a coordinate range from -540°
          // to +540°, we add at least 1 world width on each side of the projection
          // extent. If the viewport is wider than the world, we need to add half of
          // the viewport width to make sure we cover the whole viewport.
          var worldWidth = getWidth(projectionExtent);
          var gutter = Math.max(getWidth(extent) / 2, worldWidth);
          extent[0] = projectionExtent[0] - gutter;
          extent[2] = projectionExtent[2] + gutter;
        }

        if (!this.dirty_ &&
            this.renderedResolution_ == resolution &&
            this.renderedRevision_ == vectorLayerRevision &&
            this.renderedRenderOrder_ == vectorLayerRenderOrder &&
            containsExtent(this.renderedExtent_, extent)) {
          this.replayGroupChanged = false;
          return true;
        }

        this.replayGroup_ = null;

        this.dirty_ = false;

        var replayGroup = new CanvasReplayGroup(
          getTolerance(resolution, pixelRatio), extent, resolution,
          pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
        vectorSource.loadFeatures(extent, resolution, projection);
        /**
         * @param {module:ol/Feature} feature Feature.
         * @this {module:ol/renderer/canvas/VectorLayer}
         */
        var render = function(feature) {
          var styles;
          var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
          if (styleFunction) {
            styles = styleFunction(feature, resolution);
          }
          if (styles) {
            var dirty = this.renderFeature(
              feature, resolution, pixelRatio, styles, replayGroup);
            this.dirty_ = this.dirty_ || dirty;
          }
        }.bind(this);
        if (vectorLayerRenderOrder) {
          /** @type {Array.<module:ol/Feature>} */
          var features = [];
          vectorSource.forEachFeatureInExtent(extent,
            /**
             * @param {module:ol/Feature} feature Feature.
             */
            function(feature) {
              features.push(feature);
            }, this);
          features.sort(vectorLayerRenderOrder);
          for (var i = 0, ii = features.length; i < ii; ++i) {
            render(features[i]);
          }
        } else {
          vectorSource.forEachFeatureInExtent(extent, render, this);
        }
        replayGroup.finish();

        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = extent;
        this.replayGroup_ = replayGroup;

        this.replayGroupChanged = true;
        return true;
      };

      /**
       * @param {module:ol/Feature} feature Feature.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.
       * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.
       * @return {boolean} `true` if an image is loading.
       */
      CanvasVectorLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, resolution, pixelRatio, styles, replayGroup) {
        var this$1 = this;

        if (!styles) {
          return false;
        }
        var loading = false;
        if (Array.isArray(styles)) {
          for (var i = 0, ii = styles.length; i < ii; ++i) {
            loading = renderFeature(
              replayGroup, feature, styles[i],
              getSquaredTolerance(resolution, pixelRatio),
              this$1.handleStyleImageChange_, this$1) || loading;
          }
        } else {
          loading = renderFeature(
            replayGroup, feature, styles,
            getSquaredTolerance(resolution, pixelRatio),
            this.handleStyleImageChange_, this);
        }
        return loading;
      };

      return CanvasVectorLayerRenderer;
    }(CanvasLayerRenderer));


    /**
     * Determine if this renderer handles the provided layer.
     * @param {module:ol/layer/Layer} layer The candidate layer.
     * @return {boolean} The renderer can render the layer.
     */
    CanvasVectorLayerRenderer['handles'] = function(layer) {
      return layer.getType() === LayerType.VECTOR;
    };


    /**
     * Create a layer renderer.
     * @param {module:ol/renderer/Map} mapRenderer The map renderer.
     * @param {module:ol/layer/Layer} layer The layer to be rendererd.
     * @return {module:ol/renderer/canvas/VectorLayer} The layer renderer.
     */
    CanvasVectorLayerRenderer['create'] = function(mapRenderer, layer) {
      return new CanvasVectorLayerRenderer(/** @type {module:ol/layer/Vector} */ (layer));
    };

    /**
     * @module ol/layer/VectorTileRenderType
     */

    /**
     * @enum {string}
     * Render mode for vector tiles:
     *  * `'image'`: Vector tiles are rendered as images. Great performance, but
     *    point symbols and texts are always rotated with the view and pixels are
     *    scaled during zoom animations.
     *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
     *    are scaled during zoom animations. Point symbols and texts are accurately
     *    rendered as vectors and can stay upright on rotated views.
     *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
     *    even during animations, but slower performance than the other options.
     * @api
     */
    var VectorTileRenderType = {
      IMAGE: 'image',
      HYBRID: 'hybrid',
      VECTOR: 'vector'
    };

    /**
     * @module ol/renderer/canvas/VectorTileLayer
     */


    /**
     * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}
     */
    var IMAGE_REPLAYS = {
      'image': [ReplayType.POLYGON, ReplayType.CIRCLE,
        ReplayType.LINE_STRING, ReplayType.IMAGE, ReplayType.TEXT],
      'hybrid': [ReplayType.POLYGON, ReplayType.LINE_STRING]
    };


    /**
     * @type {!Object.<string, Array.<module:ol/render/ReplayType>>}
     */
    var VECTOR_REPLAYS = {
      'image': [ReplayType.DEFAULT],
      'hybrid': [ReplayType.IMAGE, ReplayType.TEXT, ReplayType.DEFAULT],
      'vector': ORDER
    };


    /**
     * @classdesc
     * Canvas renderer for vector tile layers.
     * @api
     */
    var CanvasVectorTileLayerRenderer = (function (CanvasTileLayerRenderer$$1) {
      function CanvasVectorTileLayerRenderer(layer) {

        CanvasTileLayerRenderer$$1.call(this, layer, true);

        /**
         * Declutter tree.
         * @private
         */
        this.declutterTree_ = layer.getDeclutter() ? C__Users_rendr_nextgis_nextgisweb_frontend_packages_olMapAdapter_node_modules_rbush(9, undefined) : null;

        /**
         * @private
         * @type {boolean}
         */
        this.dirty_ = false;

        /**
         * @private
         * @type {number}
         */
        this.renderedLayerRevision_;

        /**
         * @private
         * @type {module:ol/transform~Transform}
         */
        this.tmpTransform_ = create();

        // Use lower resolution for pure vector rendering. Closest resolution otherwise.
        this.zDirection = layer.getRenderMode() == VectorTileRenderType.VECTOR ? 1 : 0;

        listen(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);

      }

      if ( CanvasTileLayerRenderer$$1 ) CanvasVectorTileLayerRenderer.__proto__ = CanvasTileLayerRenderer$$1;
      CanvasVectorTileLayerRenderer.prototype = Object.create( CanvasTileLayerRenderer$$1 && CanvasTileLayerRenderer$$1.prototype );
      CanvasVectorTileLayerRenderer.prototype.constructor = CanvasVectorTileLayerRenderer;

      /**
       * @inheritDoc
       */
      CanvasVectorTileLayerRenderer.prototype.disposeInternal = function disposeInternal () {
        unlisten(labelCache, EventType.CLEAR, this.handleFontsChanged_, this);
        CanvasTileLayerRenderer$$1.prototype.disposeInternal.call(this);
      };

      /**
       * @inheritDoc
       */
      CanvasVectorTileLayerRenderer.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
        var tile = CanvasTileLayerRenderer$$1.prototype.getTile.call(this, z, x, y, pixelRatio, projection);
        if (tile.getState() === TileState.LOADED) {
          this.createReplayGroup_(tile, pixelRatio, projection);
          if (this.context) {
            this.renderTileImage_(tile, pixelRatio, projection);
          }
        }
        return tile;
      };

      /**
       * @inheritDoc
       */
      CanvasVectorTileLayerRenderer.prototype.prepareFrame = function prepareFrame (frameState, layerState) {
        var layer = this.getLayer();
        var layerRevision = layer.getRevision();
        if (this.renderedLayerRevision_ != layerRevision) {
          this.renderedTiles.length = 0;
          var renderMode = layer.getRenderMode();
          if (!this.context && renderMode != VectorTileRenderType.VECTOR) {
            this.context = createCanvasContext2D();
          }
          if (this.context && renderMode == VectorTileRenderType.VECTOR) {
            this.context = null;
          }
        }
        this.renderedLayerRevision_ = layerRevision;
        return CanvasTileLayerRenderer$$1.prototype.prepareFrame.apply(this, arguments);
      };

      /**
       * @param {module:ol/VectorImageTile} tile Tile.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @private
       */
      CanvasVectorTileLayerRenderer.prototype.createReplayGroup_ = function createReplayGroup_ (tile, pixelRatio, projection) {
        var this$1 = this;

        var layer = this.getLayer();
        var revision = layer.getRevision();
        var renderOrder = /** @type {module:ol/render~OrderFunction} */ (layer.getRenderOrder()) || null;

        var replayState = tile.getReplayState(layer);
        if (!replayState.dirty && replayState.renderedRevision == revision &&
            replayState.renderedRenderOrder == renderOrder) {
          return;
        }

        var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
        var sourceTileGrid = source.getTileGrid();
        var tileGrid = source.getTileGridForProjection(projection);
        var resolution = tileGrid.getResolution(tile.tileCoord[0]);
        var tileExtent = tile.extent;
        var loop = function ( t, tt ) {
          var sourceTile = tile.getTile(tile.tileKeys[t]);
          if (sourceTile.getState() != TileState.LOADED) {
            return;
          }

          var sourceTileCoord = sourceTile.tileCoord;
          var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
          var sharedExtent = getIntersection(tileExtent, sourceTileExtent);
          var bufferedExtent = equals$2(sourceTileExtent, sharedExtent) ? null :
            buffer(sharedExtent, layer.getRenderBuffer() * resolution, this$1.tmpExtent);
          var tileProjection = sourceTile.getProjection();
          var reproject = false;
          if (!equivalent(projection, tileProjection)) {
            reproject = true;
            sourceTile.setProjection(projection);
          }
          replayState.dirty = false;
          var replayGroup = new CanvasReplayGroup(0, sharedExtent, resolution,
            pixelRatio, source.getOverlaps(), this$1.declutterTree_, layer.getRenderBuffer());
          var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);

          /**
           * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
           * @this {module:ol/renderer/canvas/VectorTileLayer}
           */
          var render = function(feature) {
            var styles;
            var styleFunction = feature.getStyleFunction() || layer.getStyleFunction();
            if (styleFunction) {
              styles = styleFunction(feature, resolution);
            }
            if (styles) {
              var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
              this.dirty_ = this.dirty_ || dirty;
              replayState.dirty = replayState.dirty || dirty;
            }
          };

          var features = sourceTile.getFeatures();
          if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
            features.sort(renderOrder);
          }
          for (var i = 0, ii = features.length; i < ii; ++i) {
            var feature = features[i];
            if (reproject) {
              if (tileProjection.getUnits() == Units.TILE_PIXELS) {
                // projected tile extent
                tileProjection.setWorldExtent(sourceTileExtent);
                // tile extent in tile pixel space
                tileProjection.setExtent(sourceTile.getExtent());
              }
              feature.getGeometry().transform(tileProjection, projection);
            }
            if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {
              render.call(this$1, feature);
            }
          }
          replayGroup.finish();
          for (var r in replayGroup.getReplays()) {
          }
          sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
        };

        for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) loop( t, tt );
        replayState.renderedRevision = revision;
        replayState.renderedRenderOrder = renderOrder;
      };

      /**
       * @inheritDoc
       */
      CanvasVectorTileLayerRenderer.prototype.forEachFeatureAtCoordinate = function forEachFeatureAtCoordinate (coordinate, frameState, hitTolerance, callback, thisArg) {
        var resolution = frameState.viewState.resolution;
        var rotation = frameState.viewState.rotation;
        hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
        var layer = this.getLayer();
        /** @type {!Object.<string, boolean>} */
        var features = {};

        /** @type {Array.<module:ol/VectorImageTile>} */
        var renderedTiles = this.renderedTiles;

        var bufferedExtent, found;
        var i, ii, replayGroup;
        for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
          var tile = renderedTiles[i];
          bufferedExtent = buffer(tile.extent, hitTolerance * resolution, bufferedExtent);
          if (!containsCoordinate(bufferedExtent, coordinate)) {
            continue;
          }
          for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
            var sourceTile = tile.getTile(tile.tileKeys[t]);
            if (sourceTile.getState() != TileState.LOADED) {
              continue;
            }
            replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
            found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
              /**
               * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
               * @return {?} Callback result.
               */
              function(feature) {
                var key = getUid(feature).toString();
                if (!(key in features)) {
                  features[key] = true;
                  return callback.call(thisArg, feature, layer);
                }
              }, null);
          }
        }
        return found;
      };

      /**
       * @param {module:ol/VectorTile} tile Tile.
       * @param {module:ol/PluggableMap~FrameState} frameState Frame state.
       * @return {module:ol/transform~Transform} transform Transform.
       * @private
       */
      CanvasVectorTileLayerRenderer.prototype.getReplayTransform_ = function getReplayTransform_ (tile, frameState) {
        var layer = this.getLayer();
        var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
        var tileGrid = source.getTileGrid();
        var tileCoord = tile.tileCoord;
        var tileResolution = tileGrid.getResolution(tileCoord[0]);
        var viewState = frameState.viewState;
        var pixelRatio = frameState.pixelRatio;
        var renderResolution = viewState.resolution / pixelRatio;
        var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
        var center = viewState.center;
        var origin = getTopLeft(tileExtent);
        var size = frameState.size;
        var offsetX = Math.round(pixelRatio * size[0] / 2);
        var offsetY = Math.round(pixelRatio * size[1] / 2);
        return compose(this.tmpTransform_,
          offsetX, offsetY,
          tileResolution / renderResolution, tileResolution / renderResolution,
          viewState.rotation,
          (origin[0] - center[0]) / tileResolution,
          (center[1] - origin[1]) / tileResolution);
      };

      /**
       * @param {module:ol/events/Event} event Event.
       */
      CanvasVectorTileLayerRenderer.prototype.handleFontsChanged_ = function handleFontsChanged_ (event) {
        var layer = this.getLayer();
        if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
          layer.changed();
        }
      };

      /**
       * Handle changes in image style state.
       * @param {module:ol/events/Event} event Image style change event.
       * @private
       */
      CanvasVectorTileLayerRenderer.prototype.handleStyleImageChange_ = function handleStyleImageChange_ (event) {
        this.renderIfReadyAndVisible();
      };

      /**
       * @inheritDoc
       */
      CanvasVectorTileLayerRenderer.prototype.postCompose = function postCompose (context, frameState, layerState) {
        var this$1 = this;

        var layer = this.getLayer();
        var renderMode = layer.getRenderMode();
        if (renderMode != VectorTileRenderType.IMAGE) {
          var declutterReplays = layer.getDeclutter() ? {} : null;
          var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
          var replayTypes = VECTOR_REPLAYS[renderMode];
          var pixelRatio = frameState.pixelRatio;
          var rotation = frameState.viewState.rotation;
          var size = frameState.size;
          var offsetX, offsetY;
          if (rotation) {
            offsetX = Math.round(pixelRatio * size[0] / 2);
            offsetY = Math.round(pixelRatio * size[1] / 2);
            rotateAtOffset(context, -rotation, offsetX, offsetY);
          }
          if (declutterReplays) {
            this.declutterTree_.clear();
          }
          var tiles = this.renderedTiles;
          var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
          var clips = [];
          var zs = [];
          for (var i = tiles.length - 1; i >= 0; --i) {
            var tile = /** @type {module:ol/VectorImageTile} */ (tiles[i]);
            if (tile.getState() == TileState.ABORT) {
              continue;
            }
            var tileCoord = tile.tileCoord;
            var worldOffset = tileGrid.getTileCoordExtent(tileCoord, this$1.tmpExtent)[0] - tile.extent[0];
            var transform$$1 = undefined;
            for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
              var sourceTile = tile.getTile(tile.tileKeys[t]);
              if (sourceTile.getState() != TileState.LOADED) {
                continue;
              }
              var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());
              if (!replayGroup || !replayGroup.hasReplays(replayTypes)) {
                // sourceTile was not yet loaded when this.createReplayGroup_() was
                // called, or it has no replays of the types we want to render
                continue;
              }
              if (!transform$$1) {
                transform$$1 = this$1.getTransform(frameState, worldOffset);
              }
              var currentZ = sourceTile.tileCoord[0];
              var currentClip = replayGroup.getClipCoords(transform$$1);
              context.save();
              context.globalAlpha = layerState.opacity;
              // Create a clip mask for regions in this low resolution tile that are
              // already filled by a higher resolution tile
              for (var j = 0, jj = clips.length; j < jj; ++j) {
                var clip = clips[j];
                if (currentZ < zs[j]) {
                  context.beginPath();
                  // counter-clockwise (outer ring) for current tile
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  // clockwise (inner ring) for higher resolution tile
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
              replayGroup.replay(context, transform$$1, rotation, {}, replayTypes, declutterReplays);
              context.restore();
              clips.push(currentClip);
              zs.push(currentZ);
            }
          }
          if (declutterReplays) {
            replayDeclutter(declutterReplays, context, rotation);
          }
          if (rotation) {
            rotateAtOffset(context, rotation,
              /** @type {number} */ (offsetX), /** @type {number} */ (offsetY));
          }
        }
        CanvasTileLayerRenderer$$1.prototype.postCompose.apply(this, arguments);
      };

      /**
       * @param {module:ol/Feature|module:ol/render/Feature} feature Feature.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {(module:ol/style/Style|Array.<module:ol/style/Style>)} styles The style or array of styles.
       * @param {module:ol/render/canvas/ReplayGroup} replayGroup Replay group.
       * @return {boolean} `true` if an image is loading.
       */
      CanvasVectorTileLayerRenderer.prototype.renderFeature = function renderFeature$1 (feature, squaredTolerance, styles, replayGroup) {
        var this$1 = this;

        if (!styles) {
          return false;
        }
        var loading = false;
        if (Array.isArray(styles)) {
          for (var i = 0, ii = styles.length; i < ii; ++i) {
            loading = renderFeature(
              replayGroup, feature, styles[i], squaredTolerance,
              this$1.handleStyleImageChange_, this$1) || loading;
          }
        } else {
          loading = renderFeature(
            replayGroup, feature, styles, squaredTolerance,
            this.handleStyleImageChange_, this);
        }
        return loading;
      };

      /**
       * @param {module:ol/VectorImageTile} tile Tile.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @private
       */
      CanvasVectorTileLayerRenderer.prototype.renderTileImage_ = function renderTileImage_ (tile, pixelRatio, projection) {
        var this$1 = this;

        var layer = this.getLayer();
        var replayState = tile.getReplayState(layer);
        var revision = layer.getRevision();
        var replays = IMAGE_REPLAYS[layer.getRenderMode()];
        if (replays && replayState.renderedTileRevision !== revision) {
          replayState.renderedTileRevision = revision;
          var tileCoord = tile.wrappedTileCoord;
          var z = tileCoord[0];
          var source = /** @type {module:ol/source/VectorTile} */ (layer.getSource());
          var tileGrid = source.getTileGridForProjection(projection);
          var resolution = tileGrid.getResolution(z);
          var context = tile.getContext(layer);
          var size = source.getTilePixelSize(z, pixelRatio, projection);
          context.canvas.width = size[0];
          context.canvas.height = size[1];
          var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
          for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
            var sourceTile = tile.getTile(tile.tileKeys[i]);
            if (sourceTile.getState() != TileState.LOADED) {
              continue;
            }
            var pixelScale = pixelRatio / resolution;
            var transform$$1 = reset(this$1.tmpTransform_);
            scale$2(transform$$1, pixelScale, -pixelScale);
            translate$1(transform$$1, -tileExtent[0], -tileExtent[3]);
            var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
            replayGroup.replay(context, transform$$1, 0, {}, replays);
          }
        }
      };

      return CanvasVectorTileLayerRenderer;
    }(CanvasTileLayerRenderer));


    /**
     * Determine if this renderer handles the provided layer.
     * @param {module:ol/layer/Layer} layer The candidate layer.
     * @return {boolean} The renderer can render the layer.
     */
    CanvasVectorTileLayerRenderer['handles'] = function(layer) {
      return layer.getType() === LayerType.VECTOR_TILE;
    };


    /**
     * Create a layer renderer.
     * @param {module:ol/renderer/Map} mapRenderer The map renderer.
     * @param {module:ol/layer/Layer} layer The layer to be rendererd.
     * @return {module:ol/renderer/canvas/VectorTileLayer} The layer renderer.
     */
    CanvasVectorTileLayerRenderer['create'] = function(mapRenderer, layer) {
      return new CanvasVectorTileLayerRenderer(/** @type {module:ol/layer/VectorTile} */ (layer));
    };

    /**
     * @module ol/Map
     */

    /**
     * @classdesc
     * The map is the core component of OpenLayers. For a map to render, a view,
     * one or more layers, and a target container are needed:
     *
     *     import Map from 'ol/Map';
     *     import View from 'ol/View';
     *     import TileLayer from 'ol/layer/Tile';
     *     import OSM from 'ol/source/OSM';
     *
     *     var map = new Map({
     *       view: new View({
     *         center: [0, 0],
     *         zoom: 1
     *       }),
     *       layers: [
     *         new TileLayer({
     *           source: new OSM()
     *         })
     *       ],
     *       target: 'map'
     *     });
     *
     * The above snippet creates a map using a {@link module:ol/layer/Tile} to
     * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
     * element with the id `map`.
     *
     * The constructor places a viewport container (with CSS class name
     * `ol-viewport`) in the target element (see `getViewport()`), and then two
     * further elements within the viewport: one with CSS class name
     * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
     * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
     * option of {@link module:ol/Overlay~Overlay} for the difference). The map
     * itself is placed in a further element within the viewport.
     *
     * Layers are stored as a {@link module:ol/Collection~Collection} in
     * layerGroups. A top-level group is provided by the library. This is what is
     * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
     * options are added to this group, and `addLayer` and `removeLayer` change the
     * layer collection in the group. `getLayers` is a convenience function for
     * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
     * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
     * options or added with `addLayer` can be groups, which can contain further
     * groups, and so on.
     *
     * @fires module:ol/MapBrowserEvent~MapBrowserEvent
     * @fires module:ol/MapEvent~MapEvent
     * @fires module:ol/render/Event~RenderEvent#postcompose
     * @fires module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    var Map = (function (PluggableMap$$1) {
      function Map(options) {
        options = assign({}, options);
        if (!options.controls) {
          options.controls = defaults();
        }
        if (!options.interactions) {
          options.interactions = defaults$1();
        }

        PluggableMap$$1.call(this, options);
      }

      if ( PluggableMap$$1 ) Map.__proto__ = PluggableMap$$1;
      Map.prototype = Object.create( PluggableMap$$1 && PluggableMap$$1.prototype );
      Map.prototype.constructor = Map;

      Map.prototype.createRenderer = function createRenderer () {
        var renderer = new CanvasMapRenderer(this);
        renderer.registerLayerRenderers([
          CanvasImageLayerRenderer,
          CanvasTileLayerRenderer,
          CanvasVectorLayerRenderer,
          CanvasVectorTileLayerRenderer
        ]);
        return renderer;
      };

      return Map;
    }(PluggableMap));

    /**
     * @module ol/Tile
     */


    /**
     * A function that takes an {@link module:ol/Tile} for the tile and a
     * `{string}` for the url as arguments.
     *
     * @typedef {function(module:ol/Tile, string)} LoadFunction
     * @api
     */

    /**
     * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
     * the url that provides a tile for a given tile coordinate.
     *
     * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
     * coordinate, a `{number}` representing the pixel ratio and a
     * {@link module:ol/proj/Projection} for the projection  as arguments
     * and returns a `{string}` representing the tile URL, or undefined if no tile
     * should be requested for the passed tile coordinate.
     *
     * @typedef {function(module:ol/tilecoord~TileCoord, number,
     *           module:ol/proj/Projection): (string|undefined)} UrlFunction
     * @api
     */


    /**
     * @typedef {Object} Options
     * @property {number} [transition=250] A duration for tile opacity
     * transitions in milliseconds. A duration of 0 disables the opacity transition.
     * @api
     */


    /**
     * @classdesc
     * Base class for tiles.
     *
     * @abstract
      */
    var Tile = (function (EventTarget$$1) {
      function Tile(tileCoord, state, opt_options) {
        EventTarget$$1.call(this);

        var options = opt_options ? opt_options : {};

        /**
         * @type {module:ol/tilecoord~TileCoord}
         */
        this.tileCoord = tileCoord;

        /**
         * @protected
         * @type {module:ol/TileState}
         */
        this.state = state;

        /**
         * An "interim" tile for this tile. The interim tile may be used while this
         * one is loading, for "smooth" transitions when changing params/dimensions
         * on the source.
         * @type {module:ol/Tile}
         */
        this.interimTile = null;

        /**
         * A key assigned to the tile. This is used by the tile source to determine
         * if this tile can effectively be used, or if a new tile should be created
         * and this one be used as an interim tile for this new tile.
         * @type {string}
         */
        this.key = '';

        /**
         * The duration for the opacity transition.
         * @type {number}
         */
        this.transition_ = options.transition === undefined ? 250 : options.transition;

        /**
         * Lookup of start times for rendering transitions.  If the start time is
         * equal to -1, the transition is complete.
         * @type {Object.<number, number>}
         */
        this.transitionStarts_ = {};

      }

      if ( EventTarget$$1 ) Tile.__proto__ = EventTarget$$1;
      Tile.prototype = Object.create( EventTarget$$1 && EventTarget$$1.prototype );
      Tile.prototype.constructor = Tile;

      /**
       * @protected
       */
      Tile.prototype.changed = function changed () {
        this.dispatchEvent(EventType.CHANGE);
      };

      /**
       * @return {string} Key.
       */
      Tile.prototype.getKey = function getKey () {
        return this.key + '/' + this.tileCoord;
      };

      /**
       * Get the interim tile most suitable for rendering using the chain of interim
       * tiles. This corresponds to the  most recent tile that has been loaded, if no
       * such tile exists, the original tile is returned.
       * @return {!module:ol/Tile} Best tile for rendering.
       */
      Tile.prototype.getInterimTile = function getInterimTile () {
        if (!this.interimTile) {
          //empty chain
          return this;
        }
        var tile = this.interimTile;

        // find the first loaded tile and return it. Since the chain is sorted in
        // decreasing order of creation time, there is no need to search the remainder
        // of the list (all those tiles correspond to older requests and will be
        // cleaned up by refreshInterimChain)
        do {
          if (tile.getState() == TileState.LOADED) {
            return tile;
          }
          tile = tile.interimTile;
        } while (tile);

        // we can not find a better tile
        return this;
      };

      /**
       * Goes through the chain of interim tiles and discards sections of the chain
       * that are no longer relevant.
       */
      Tile.prototype.refreshInterimChain = function refreshInterimChain () {
        if (!this.interimTile) {
          return;
        }

        var tile = this.interimTile;
        var prev = this;

        do {
          if (tile.getState() == TileState.LOADED) {
            //we have a loaded tile, we can discard the rest of the list
            //we would could abort any LOADING tile request
            //older than this tile (i.e. any LOADING tile following this entry in the chain)
            tile.interimTile = null;
            break;
          } else if (tile.getState() == TileState.LOADING) {
            //keep this LOADING tile any loaded tiles later in the chain are
            //older than this tile, so we're still interested in the request
            prev = tile;
          } else if (tile.getState() == TileState.IDLE) {
            //the head of the list is the most current tile, we don't need
            //to start any other requests for this chain
            prev.interimTile = tile.interimTile;
          } else {
            prev = tile;
          }
          tile = prev.interimTile;
        } while (tile);
      };

      /**
       * Get the tile coordinate for this tile.
       * @return {module:ol/tilecoord~TileCoord} The tile coordinate.
       * @api
       */
      Tile.prototype.getTileCoord = function getTileCoord () {
        return this.tileCoord;
      };

      /**
       * @return {module:ol/TileState} State.
       */
      Tile.prototype.getState = function getState () {
        return this.state;
      };

      /**
       * @param {module:ol/TileState} state State.
       */
      Tile.prototype.setState = function setState (state) {
        this.state = state;
        this.changed();
      };

      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */
      Tile.prototype.load = function load () {};

      /**
       * Get the alpha value for rendering.
       * @param {number} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */
      Tile.prototype.getAlpha = function getAlpha (id, time) {
        if (!this.transition_) {
          return 1;
        }

        var start = this.transitionStarts_[id];
        if (!start) {
          start = time;
          this.transitionStarts_[id] = start;
        } else if (start === -1) {
          return 1;
        }

        var delta = time - start + (1000 / 60); // avoid rendering at 0
        if (delta >= this.transition_) {
          return 1;
        }
        return easeIn(delta / this.transition_);
      };

      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {number} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */
      Tile.prototype.inTransition = function inTransition (id) {
        if (!this.transition_) {
          return false;
        }
        return this.transitionStarts_[id] !== -1;
      };

      /**
       * Mark a transition as complete.
       * @param {number} id An id for the renderer.
       */
      Tile.prototype.endTransition = function endTransition (id) {
        if (this.transition_) {
          this.transitionStarts_[id] = -1;
        }
      };

      return Tile;
    }(EventTarget));

    /**
     * @module ol/ImageTile
     */

    /**
     * @typedef {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord,
     * module:ol/TileState, string, ?string, module:ol/Tile~LoadFunction)} TileClass
     * @api
     */

    var ImageTile = (function (Tile$$1) {
      function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

        Tile$$1.call(this, tileCoord, state, opt_options);

        /**
         * @private
         * @type {?string}
         */
        this.crossOrigin_ = crossOrigin;

        /**
         * Image URI
         *
         * @private
         * @type {string}
         */
        this.src_ = src;

        /**
         * @private
         * @type {HTMLImageElement|HTMLCanvasElement}
         */
        this.image_ = new Image();
        if (crossOrigin !== null) {
          this.image_.crossOrigin = crossOrigin;
        }

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.imageListenerKeys_ = null;

        /**
         * @private
         * @type {module:ol/Tile~LoadFunction}
         */
        this.tileLoadFunction_ = tileLoadFunction;

      }

      if ( Tile$$1 ) ImageTile.__proto__ = Tile$$1;
      ImageTile.prototype = Object.create( Tile$$1 && Tile$$1.prototype );
      ImageTile.prototype.constructor = ImageTile;

      /**
       * @inheritDoc
       */
      ImageTile.prototype.disposeInternal = function disposeInternal () {
        if (this.state == TileState.LOADING) {
          this.unlistenImage_();
          this.image_ = getBlankImage();
        }
        if (this.interimTile) {
          this.interimTile.dispose();
        }
        this.state = TileState.ABORT;
        this.changed();
        Tile$$1.prototype.disposeInternal.call(this);
      };

      /**
       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageTile.prototype.getImage = function getImage () {
        return this.image_;
      };

      /**
       * @inheritDoc
       */
      ImageTile.prototype.getKey = function getKey () {
        return this.src_;
      };

      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageTile.prototype.handleImageError_ = function handleImageError_ () {
        this.state = TileState.ERROR;
        this.unlistenImage_();
        this.image_ = getBlankImage();
        this.changed();
      };

      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageTile.prototype.handleImageLoad_ = function handleImageLoad_ () {
        if (this.image_.naturalWidth && this.image_.naturalHeight) {
          this.state = TileState.LOADED;
        } else {
          this.state = TileState.EMPTY;
        }
        this.unlistenImage_();
        this.changed();
      };

      /**
       * @inheritDoc
       * @api
       */
      ImageTile.prototype.load = function load () {
        if (this.state == TileState.ERROR) {
          this.state = TileState.IDLE;
          this.image_ = new Image();
          if (this.crossOrigin_ !== null) {
            this.image_.crossOrigin = this.crossOrigin_;
          }
        }
        if (this.state == TileState.IDLE) {
          this.state = TileState.LOADING;
          this.changed();
          this.imageListenerKeys_ = [
            listenOnce(this.image_, EventType.ERROR,
              this.handleImageError_, this),
            listenOnce(this.image_, EventType.LOAD,
              this.handleImageLoad_, this)
          ];
          this.tileLoadFunction_(this, this.src_);
        }
      };

      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageTile.prototype.unlistenImage_ = function unlistenImage_ () {
        this.imageListenerKeys_.forEach(unlistenByKey);
        this.imageListenerKeys_ = null;
      };

      return ImageTile;
    }(Tile));


    /**
     * Get a 1-pixel blank image.
     * @return {HTMLCanvasElement} Blank image.
     */
    function getBlankImage() {
      var ctx = createCanvasContext2D(1, 1);
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, 1, 1);
      return ctx.canvas;
    }

    /**
     * @module ol/tilecoord
     */


    /**
     * An array of three numbers representing the location of a tile in a tile
     * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.
     * @typedef {Array.<number>} TileCoord
     * @api
     */


    /**
     * @param {number} z Z.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Tile coordinate.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     */
    function createOrUpdate$2(z, x, y, opt_tileCoord) {
      if (opt_tileCoord !== undefined) {
        opt_tileCoord[0] = z;
        opt_tileCoord[1] = x;
        opt_tileCoord[2] = y;
        return opt_tileCoord;
      } else {
        return [z, x, y];
      }
    }


    /**
     * @param {number} z Z.
     * @param {number} x X.
     * @param {number} y Y.
     * @return {string} Key.
     */
    function getKeyZXY(z, x, y) {
      return z + '/' + x + '/' + y;
    }


    /**
     * Get the key for a tile coord.
     * @param {module:ol/tilecoord~TileCoord} tileCoord The tile coord.
     * @return {string} Key.
     */
    function getKey$1(tileCoord) {
      return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
    }


    /**
     * Get a tile coord given a key.
     * @param {string} key The tile coord key.
     * @return {module:ol/tilecoord~TileCoord} The tile coord.
     */
    function fromKey(key) {
      return key.split('/').map(Number);
    }


    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coord.
     * @return {number} Hash.
     */
    function hash(tileCoord) {
      return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
    }


    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {!module:ol/tilegrid/TileGrid} tileGrid Tile grid.
     * @return {boolean} Tile coordinate is within extent and zoom level range.
     */
    function withinExtentAndZ(tileCoord, tileGrid) {
      var z = tileCoord[0];
      var x = tileCoord[1];
      var y = tileCoord[2];

      if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
        return false;
      }
      var extent = tileGrid.getExtent();
      var tileRange;
      if (!extent) {
        tileRange = tileGrid.getFullTileRange(z);
      } else {
        tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      }
      if (!tileRange) {
        return true;
      } else {
        return tileRange.containsXY(x, y);
      }
    }

    /**
     * @module ol/TileCache
     */

    var TileCache = (function (LRUCache$$1) {
      function TileCache(opt_highWaterMark) {

        LRUCache$$1.call(this, opt_highWaterMark);

      }

      if ( LRUCache$$1 ) TileCache.__proto__ = LRUCache$$1;
      TileCache.prototype = Object.create( LRUCache$$1 && LRUCache$$1.prototype );
      TileCache.prototype.constructor = TileCache;

      /**
       * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
       */
      TileCache.prototype.expireCache = function expireCache (usedTiles) {
        var this$1 = this;

        while (this.canExpireCache()) {
          var tile = this$1.peekLast();
          var zKey = tile.tileCoord[0].toString();
          if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
            break;
          } else {
            this$1.pop().dispose();
          }
        }
      };

      /**
       * Prune all tiles from the cache that don't have the same z as the newest tile.
       */
      TileCache.prototype.pruneExceptNewestZ = function pruneExceptNewestZ () {
        if (this.getCount() === 0) {
          return;
        }
        var key = this.peekFirstKey();
        var tileCoord = fromKey(key);
        var z = tileCoord[0];
        this.forEach(function(tile) {
          if (tile.tileCoord[0] !== z) {
            this.remove(getKey$1(tile.tileCoord));
            tile.dispose();
          }
        }, this);
      };

      return TileCache;
    }(LRUCache));

    /**
     * @module ol/reproj
     */


    /**
     * Calculates ideal resolution to use from the source in order to achieve
     * pixel mapping as close as possible to 1:1 during reprojection.
     * The resolution is calculated regardless of what resolutions
     * are actually available in the dataset (TileGrid, Image, ...).
     *
     * @param {module:ol/proj/Projection} sourceProj Source projection.
     * @param {module:ol/proj/Projection} targetProj Target projection.
     * @param {module:ol/coordinate~Coordinate} targetCenter Target center.
     * @param {number} targetResolution Target resolution.
     * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
     */
    function calculateSourceResolution(sourceProj, targetProj,
      targetCenter, targetResolution) {

      var sourceCenter = transform(targetCenter, targetProj, sourceProj);

      // calculate the ideal resolution of the source data
      var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);

      var targetMetersPerUnit = targetProj.getMetersPerUnit();
      if (targetMetersPerUnit !== undefined) {
        sourceResolution *= targetMetersPerUnit;
      }
      var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
      if (sourceMetersPerUnit !== undefined) {
        sourceResolution /= sourceMetersPerUnit;
      }

      // Based on the projection properties, the point resolution at the specified
      // coordinates may be slightly different. We need to reverse-compensate this
      // in order to achieve optimal results.

      var sourceExtent = sourceProj.getExtent();
      if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
        var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /
            sourceResolution;
        if (isFinite(compensationFactor) && compensationFactor > 0) {
          sourceResolution /= compensationFactor;
        }
      }

      return sourceResolution;
    }


    /**
     * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
     * in order to mask gaps caused by antialiasing.
     *
     * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
     * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
     * @param {number} x X coordinate of the point (in pixels).
     * @param {number} y Y coordinate of the point (in pixels).
     * @return {module:ol/coordinate~Coordinate} New point 1 px farther from the centroid.
     */
    function enlargeClipPoint(centroidX, centroidY, x, y) {
      var dX = x - centroidX;
      var dY = y - centroidY;
      var distance = Math.sqrt(dX * dX + dY * dY);
      return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
    }


    /**
     * Renders the source data into new canvas based on the triangulation.
     *
     * @param {number} width Width of the canvas.
     * @param {number} height Height of the canvas.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} sourceResolution Source resolution.
     * @param {module:ol/extent~Extent} sourceExtent Extent of the data source.
     * @param {number} targetResolution Target resolution.
     * @param {module:ol/extent~Extent} targetExtent Target extent.
     * @param {module:ol/reproj/Triangulation} triangulation
     * Calculated triangulation.
     * @param {Array.<{extent: module:ol/extent~Extent,
     *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
     * Array of sources.
     * @param {number} gutter Gutter of the sources.
     * @param {boolean=} opt_renderEdges Render reprojection edges.
     * @return {HTMLCanvasElement} Canvas with reprojected data.
     */
    function render$2(width, height, pixelRatio,
      sourceResolution, sourceExtent, targetResolution, targetExtent,
      triangulation, sources, gutter, opt_renderEdges) {

      var context = createCanvasContext2D(Math.round(pixelRatio * width),
        Math.round(pixelRatio * height));

      if (sources.length === 0) {
        return context.canvas;
      }

      context.scale(pixelRatio, pixelRatio);

      var sourceDataExtent = createEmpty();
      sources.forEach(function(src, i, arr) {
        extend$1(sourceDataExtent, src.extent);
      });

      var canvasWidthInUnits = getWidth(sourceDataExtent);
      var canvasHeightInUnits = getHeight(sourceDataExtent);
      var stitchContext = createCanvasContext2D(
        Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
        Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

      var stitchScale = pixelRatio / sourceResolution;

      sources.forEach(function(src, i, arr) {
        var xPos = src.extent[0] - sourceDataExtent[0];
        var yPos = -(src.extent[3] - sourceDataExtent[3]);
        var srcWidth = getWidth(src.extent);
        var srcHeight = getHeight(src.extent);

        stitchContext.drawImage(
          src.image,
          gutter, gutter,
          src.image.width - 2 * gutter, src.image.height - 2 * gutter,
          xPos * stitchScale, yPos * stitchScale,
          srcWidth * stitchScale, srcHeight * stitchScale);
      });

      var targetTopLeft = getTopLeft(targetExtent);

      triangulation.getTriangles().forEach(function(triangle, i, arr) {
        /* Calculate affine transform (src -> dst)
         * Resulting matrix can be used to transform coordinate
         * from `sourceProjection` to destination pixels.
         *
         * To optimize number of context calls and increase numerical stability,
         * we also do the following operations:
         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
         * here before solving the linear system so [ui, vi] are pixel coordinates.
         *
         * Src points: xi, yi
         * Dst points: ui, vi
         * Affine coefficients: aij
         *
         * | x0 y0 1  0  0 0 |   |a00|   |u0|
         * | x1 y1 1  0  0 0 |   |a01|   |u1|
         * | x2 y2 1  0  0 0 | x |a02| = |u2|
         * |  0  0 0 x0 y0 1 |   |a10|   |v0|
         * |  0  0 0 x1 y1 1 |   |a11|   |v1|
         * |  0  0 0 x2 y2 1 |   |a12|   |v2|
         */
        var source = triangle.source;
        var target = triangle.target;
        var x0 = source[0][0], y0 = source[0][1];
        var x1 = source[1][0], y1 = source[1][1];
        var x2 = source[2][0], y2 = source[2][1];
        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
        var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
        var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
        var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

        // Shift all the source points to improve numerical stability
        // of all the subsequent calculations. The [x0, y0] is used here.
        // This is also used to simplify the linear system.
        var sourceNumericalShiftX = x0;
        var sourceNumericalShiftY = y0;
        x0 = 0;
        y0 = 0;
        x1 -= sourceNumericalShiftX;
        y1 -= sourceNumericalShiftY;
        x2 -= sourceNumericalShiftX;
        y2 -= sourceNumericalShiftY;

        var augmentedMatrix = [
          [x1, y1, 0, 0, u1 - u0],
          [x2, y2, 0, 0, u2 - u0],
          [0, 0, x1, y1, v1 - v0],
          [0, 0, x2, y2, v2 - v0]
        ];
        var affineCoefs = solveLinearSystem(augmentedMatrix);
        if (!affineCoefs) {
          return;
        }

        context.save();
        context.beginPath();
        var centroidX = (u0 + u1 + u2) / 3;
        var centroidY = (v0 + v1 + v2) / 3;
        var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);
        var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);
        var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);

        context.moveTo(p1[0], p1[1]);
        context.lineTo(p0[0], p0[1]);
        context.lineTo(p2[0], p2[1]);
        context.clip();

        context.transform(
          affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

        context.translate(sourceDataExtent[0] - sourceNumericalShiftX,
          sourceDataExtent[3] - sourceNumericalShiftY);

        context.scale(sourceResolution / pixelRatio,
          -sourceResolution / pixelRatio);

        context.drawImage(stitchContext.canvas, 0, 0);
        context.restore();
      });

      if (opt_renderEdges) {
        context.save();

        context.strokeStyle = 'black';
        context.lineWidth = 1;

        triangulation.getTriangles().forEach(function(triangle, i, arr) {
          var target = triangle.target;
          var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
          var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
          var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
          var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
          var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
          var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

          context.beginPath();
          context.moveTo(u1, v1);
          context.lineTo(u0, v0);
          context.lineTo(u2, v2);
          context.closePath();
          context.stroke();
        });

        context.restore();
      }
      return context.canvas;
    }

    /**
     * @module ol/reproj/Triangulation
     */


    /**
     * Single triangle; consists of 3 source points and 3 target points.
     * @typedef {Object} Triangle
     * @property {Array.<module:ol/coordinate~Coordinate>} source
     * @property {Array.<module:ol/coordinate~Coordinate>} target
     */


    /**
     * Maximum number of subdivision steps during raster reprojection triangulation.
     * Prevents high memory usage and large number of proj4 calls (for certain
     * transformations and areas). At most `2*(2^this)` triangles are created for
     * each triangulated extent (tile/image).
     * @type {number}
     */
    var MAX_SUBDIVISION = 10;


    /**
     * Maximum allowed size of triangle relative to world width. When transforming
     * corners of world extent between certain projections, the resulting
     * triangulation seems to have zero error and no subdivision is performed. If
     * the triangle width is more than this (relative to world width; 0-1),
     * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
     * @type {number}
     */
    var MAX_TRIANGLE_WIDTH = 0.25;


    /**
     * @classdesc
     * Class containing triangulation of the given target extent.
     * Used for determining source data and the reprojection itself.
     */
    var Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

      /**
       * @type {module:ol/proj/Projection}
       * @private
       */
      this.sourceProj_ = sourceProj;

      /**
       * @type {module:ol/proj/Projection}
       * @private
       */
      this.targetProj_ = targetProj;

      /** @type {!Object.<string, module:ol/coordinate~Coordinate>} */
      var transformInvCache = {};
      var transformInv = getTransform(this.targetProj_, this.sourceProj_);

      /**
       * @param {module:ol/coordinate~Coordinate} c A coordinate.
       * @return {module:ol/coordinate~Coordinate} Transformed coordinate.
       * @private
       */
      this.transformInv_ = function(c) {
        var key = c[0] + '/' + c[1];
        if (!transformInvCache[key]) {
          transformInvCache[key] = transformInv(c);
        }
        return transformInvCache[key];
      };

      /**
       * @type {module:ol/extent~Extent}
       * @private
       */
      this.maxSourceExtent_ = maxSourceExtent;

      /**
       * @type {number}
       * @private
       */
      this.errorThresholdSquared_ = errorThreshold * errorThreshold;

      /**
       * @type {Array.<module:ol/reproj/Triangulation~Triangle>}
       * @private
       */
      this.triangles_ = [];

      /**
       * Indicates that the triangulation crosses edge of the source projection.
       * @type {boolean}
       * @private
       */
      this.wrapsXInSource_ = false;

      /**
       * @type {boolean}
       * @private
       */
      this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&
          !!maxSourceExtent &&
          !!this.sourceProj_.getExtent() &&
          (getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent()));

      /**
       * @type {?number}
       * @private
       */
      this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?
        getWidth(this.sourceProj_.getExtent()) : null;

      /**
       * @type {?number}
       * @private
       */
      this.targetWorldWidth_ = this.targetProj_.getExtent() ?
        getWidth(this.targetProj_.getExtent()) : null;

      var destinationTopLeft = getTopLeft(targetExtent);
      var destinationTopRight = getTopRight(targetExtent);
      var destinationBottomRight = getBottomRight(targetExtent);
      var destinationBottomLeft = getBottomLeft(targetExtent);
      var sourceTopLeft = this.transformInv_(destinationTopLeft);
      var sourceTopRight = this.transformInv_(destinationTopRight);
      var sourceBottomRight = this.transformInv_(destinationBottomRight);
      var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

      this.addQuad_(
        destinationTopLeft, destinationTopRight,
        destinationBottomRight, destinationBottomLeft,
        sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,
        MAX_SUBDIVISION);

      if (this.wrapsXInSource_) {
        var leftBound = Infinity;
        this.triangles_.forEach(function(triangle, i, arr) {
          leftBound = Math.min(leftBound,
            triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
        });

        // Shift triangles to be as close to `leftBound` as possible
        // (if the distance is more than `worldWidth / 2` it can be closer.
        this.triangles_.forEach(function(triangle) {
          if (Math.max(triangle.source[0][0], triangle.source[1][0],
            triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
            var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],
              [triangle.source[1][0], triangle.source[1][1]],
              [triangle.source[2][0], triangle.source[2][1]]];
            if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {
              newTriangle[0][0] -= this.sourceWorldWidth_;
            }
            if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {
              newTriangle[1][0] -= this.sourceWorldWidth_;
            }
            if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {
              newTriangle[2][0] -= this.sourceWorldWidth_;
            }

            // Rarely (if the extent contains both the dateline and prime meridian)
            // the shift can in turn break some triangles.
            // Detect this here and don't shift in such cases.
            var minX = Math.min(
              newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
            var maxX = Math.max(
              newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
            if ((maxX - minX) < this.sourceWorldWidth_ / 2) {
              triangle.source = newTriangle;
            }
          }
        }.bind(this));
      }

      transformInvCache = {};
    };

    /**
     * Adds triangle to the triangulation.
     * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
     * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
     * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
     * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
     * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
     * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
     * @private
     */
    Triangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {
      this.triangles_.push({
        source: [aSrc, bSrc, cSrc],
        target: [a, b, c]
      });
    };

    /**
     * Adds quad (points in clock-wise order) to the triangulation
     * (and reprojects the vertices) if valid.
     * Performs quad subdivision if needed to increase precision.
     *
     * @param {module:ol/coordinate~Coordinate} a The target a coordinate.
     * @param {module:ol/coordinate~Coordinate} b The target b coordinate.
     * @param {module:ol/coordinate~Coordinate} c The target c coordinate.
     * @param {module:ol/coordinate~Coordinate} d The target d coordinate.
     * @param {module:ol/coordinate~Coordinate} aSrc The source a coordinate.
     * @param {module:ol/coordinate~Coordinate} bSrc The source b coordinate.
     * @param {module:ol/coordinate~Coordinate} cSrc The source c coordinate.
     * @param {module:ol/coordinate~Coordinate} dSrc The source d coordinate.
     * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
     * @private
     */
    Triangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

      var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
      var sourceCoverageX = this.sourceWorldWidth_ ?
        getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
      var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);

      // when the quad is wrapped in the source projection
      // it covers most of the projection extent, but not fully
      var wrapsX = this.sourceProj_.canWrapX() &&
                   sourceCoverageX > 0.5 && sourceCoverageX < 1;

      var needsSubdivision = false;

      if (maxSubdivision > 0) {
        if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
          var targetQuadExtent = boundingExtent([a, b, c, d]);
          var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
          needsSubdivision |=
              targetCoverageX > MAX_TRIANGLE_WIDTH;
        }
        if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
          needsSubdivision |=
              sourceCoverageX > MAX_TRIANGLE_WIDTH;
        }
      }

      if (!needsSubdivision && this.maxSourceExtent_) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          // whole quad outside source projection extent -> ignore
          return;
        }
      }

      if (!needsSubdivision) {
        if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||
            !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||
            !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||
            !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
          if (maxSubdivision > 0) {
            needsSubdivision = true;
          } else {
            return;
          }
        }
      }

      if (maxSubdivision > 0) {
        if (!needsSubdivision) {
          var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
          var centerSrc = this.transformInv_(center);

          var dx;
          if (wrapsX) {
            var centerSrcEstimX =
                (modulo(aSrc[0], sourceWorldWidth) +
                 modulo(cSrc[0], sourceWorldWidth)) / 2;
            dx = centerSrcEstimX -
                modulo(centerSrc[0], sourceWorldWidth);
          } else {
            dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
          }
          var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
          var centerSrcErrorSquared = dx * dx + dy * dy;
          needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
        }
        if (needsSubdivision) {
          if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
            // split horizontally (top & bottom)
            var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
            var bcSrc = this.transformInv_(bc);
            var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
            var daSrc = this.transformInv_(da);

            this.addQuad_(
              a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
            this.addQuad_(
              da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
          } else {
            // split vertically (left & right)
            var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
            var abSrc = this.transformInv_(ab);
            var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
            var cdSrc = this.transformInv_(cd);

            this.addQuad_(
              a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
            this.addQuad_(
              ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
          }
          return;
        }
      }

      if (wrapsX) {
        if (!this.canWrapXInSource_) {
          return;
        }
        this.wrapsXInSource_ = true;
      }

      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
      this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
    };

    /**
     * Calculates extent of the 'source' coordinates from all the triangles.
     *
     * @return {module:ol/extent~Extent} Calculated extent.
     */
    Triangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {
      var extent = createEmpty();

      this.triangles_.forEach(function(triangle, i, arr) {
        var src = triangle.source;
        extendCoordinate(extent, src[0]);
        extendCoordinate(extent, src[1]);
        extendCoordinate(extent, src[2]);
      });

      return extent;
    };

    /**
     * @return {Array.<module:ol/reproj/Triangulation~Triangle>} Array of the calculated triangles.
     */
    Triangulation.prototype.getTriangles = function getTriangles () {
      return this.triangles_;
    };

    /**
     * @module ol/reproj/Tile
     */


    /**
     * @typedef {function(number, number, number, number) : module:ol/Tile} FunctionType
     */


    /**
     * @classdesc
     * Class encapsulating single reprojected tile.
     * See {@link module:ol/source/TileImage~TileImage}.
     *
     */
    var ReprojTile = (function (Tile$$1) {
      function ReprojTile(
        sourceProj,
        sourceTileGrid,
        targetProj,
        targetTileGrid,
        tileCoord,
        wrappedTileCoord,
        pixelRatio,
        gutter,
        getTileFunction,
        opt_errorThreshold,
        opt_renderEdges
      ) {
        var this$1 = this;

        Tile$$1.call(this, tileCoord, TileState.IDLE);

        /**
         * @private
         * @type {boolean}
         */
        this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

        /**
         * @private
         * @type {number}
         */
        this.pixelRatio_ = pixelRatio;

        /**
         * @private
         * @type {number}
         */
        this.gutter_ = gutter;

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.canvas_ = null;

        /**
         * @private
         * @type {module:ol/tilegrid/TileGrid}
         */
        this.sourceTileGrid_ = sourceTileGrid;

        /**
         * @private
         * @type {module:ol/tilegrid/TileGrid}
         */
        this.targetTileGrid_ = targetTileGrid;

        /**
         * @private
         * @type {module:ol/tilecoord~TileCoord}
         */
        this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

        /**
         * @private
         * @type {!Array.<module:ol/Tile>}
         */
        this.sourceTiles_ = [];

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.sourcesListenerKeys_ = null;

        /**
         * @private
         * @type {number}
         */
        this.sourceZ_ = 0;

        var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
        var maxTargetExtent = this.targetTileGrid_.getExtent();
        var maxSourceExtent = this.sourceTileGrid_.getExtent();

        var limitedTargetExtent = maxTargetExtent ?
          getIntersection(targetExtent, maxTargetExtent) : targetExtent;

        if (getArea(limitedTargetExtent) === 0) {
          // Tile is completely outside range -> EMPTY
          // TODO: is it actually correct that the source even creates the tile ?
          this.state = TileState.EMPTY;
          return;
        }

        var sourceProjExtent = sourceProj.getExtent();
        if (sourceProjExtent) {
          if (!maxSourceExtent) {
            maxSourceExtent = sourceProjExtent;
          } else {
            maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
          }
        }

        var targetResolution = targetTileGrid.getResolution(
          this.wrappedTileCoord_[0]);

        var targetCenter = getCenter(limitedTargetExtent);
        var sourceResolution = calculateSourceResolution(
          sourceProj, targetProj, targetCenter, targetResolution);

        if (!isFinite(sourceResolution) || sourceResolution <= 0) {
          // invalid sourceResolution -> EMPTY
          // probably edges of the projections when no extent is defined
          this.state = TileState.EMPTY;
          return;
        }

        var errorThresholdInPixels = opt_errorThreshold !== undefined ?
          opt_errorThreshold : ERROR_THRESHOLD;

        /**
         * @private
         * @type {!module:ol/reproj/Triangulation}
         */
        this.triangulation_ = new Triangulation(
          sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
          sourceResolution * errorThresholdInPixels);

        if (this.triangulation_.getTriangles().length === 0) {
          // no valid triangles -> EMPTY
          this.state = TileState.EMPTY;
          return;
        }

        this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
        var sourceExtent = this.triangulation_.calculateSourceExtent();

        if (maxSourceExtent) {
          if (sourceProj.canWrapX()) {
            sourceExtent[1] = clamp(
              sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
            sourceExtent[3] = clamp(
              sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
          } else {
            sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
          }
        }

        if (!getArea(sourceExtent)) {
          this.state = TileState.EMPTY;
        } else {
          var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
            sourceExtent, this.sourceZ_);

          for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
            for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
              var tile = getTileFunction(this$1.sourceZ_, srcX, srcY, pixelRatio);
              if (tile) {
                this$1.sourceTiles_.push(tile);
              }
            }
          }

          if (this.sourceTiles_.length === 0) {
            this.state = TileState.EMPTY;
          }
        }
      }

      if ( Tile$$1 ) ReprojTile.__proto__ = Tile$$1;
      ReprojTile.prototype = Object.create( Tile$$1 && Tile$$1.prototype );
      ReprojTile.prototype.constructor = ReprojTile;

      /**
       * @inheritDoc
       */
      ReprojTile.prototype.disposeInternal = function disposeInternal () {
        if (this.state == TileState.LOADING) {
          this.unlistenSources_();
        }
        Tile$$1.prototype.disposeInternal.call(this);
      };

      /**
       * Get the HTML Canvas element for this tile.
       * @return {HTMLCanvasElement} Canvas.
       */
      ReprojTile.prototype.getImage = function getImage () {
        return this.canvas_;
      };

      /**
       * @private
       */
      ReprojTile.prototype.reproject_ = function reproject_ () {
        var sources = [];
        this.sourceTiles_.forEach(function(tile, i, arr) {
          if (tile && tile.getState() == TileState.LOADED) {
            sources.push({
              extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
              image: tile.getImage()
            });
          }
        }.bind(this));
        this.sourceTiles_.length = 0;

        if (sources.length === 0) {
          this.state = TileState.ERROR;
        } else {
          var z = this.wrappedTileCoord_[0];
          var size = this.targetTileGrid_.getTileSize(z);
          var width = typeof size === 'number' ? size : size[0];
          var height = typeof size === 'number' ? size : size[1];
          var targetResolution = this.targetTileGrid_.getResolution(z);
          var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

          var targetExtent = this.targetTileGrid_.getTileCoordExtent(
            this.wrappedTileCoord_);
          this.canvas_ = render$2(width, height, this.pixelRatio_,
            sourceResolution, this.sourceTileGrid_.getExtent(),
            targetResolution, targetExtent, this.triangulation_, sources,
            this.gutter_, this.renderEdges_);

          this.state = TileState.LOADED;
        }
        this.changed();
      };

      /**
       * @inheritDoc
       */
      ReprojTile.prototype.load = function load () {
        if (this.state == TileState.IDLE) {
          this.state = TileState.LOADING;
          this.changed();

          var leftToLoad = 0;

          this.sourcesListenerKeys_ = [];
          this.sourceTiles_.forEach(function(tile, i, arr) {
            var state = tile.getState();
            if (state == TileState.IDLE || state == TileState.LOADING) {
              leftToLoad++;

              var sourceListenKey = listen(tile, EventType.CHANGE,
                function(e) {
                  var state = tile.getState();
                  if (state == TileState.LOADED ||
                        state == TileState.ERROR ||
                        state == TileState.EMPTY) {
                    unlistenByKey(sourceListenKey);
                    leftToLoad--;
                    if (leftToLoad === 0) {
                      this.unlistenSources_();
                      this.reproject_();
                    }
                  }
                }, this);
              this.sourcesListenerKeys_.push(sourceListenKey);
            }
          }.bind(this));

          this.sourceTiles_.forEach(function(tile, i, arr) {
            var state = tile.getState();
            if (state == TileState.IDLE) {
              tile.load();
            }
          });

          if (leftToLoad === 0) {
            setTimeout(this.reproject_.bind(this), 0);
          }
        }
      };

      /**
       * @private
       */
      ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {
        this.sourcesListenerKeys_.forEach(unlistenByKey);
        this.sourcesListenerKeys_ = null;
      };

      return ReprojTile;
    }(Tile));

    /**
     * @module ol/tileurlfunction
     */


    /**
     * @param {string} template Template.
     * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
     * @return {module:ol/Tile~UrlFunction} Tile URL function.
     */
    function createFromTemplate(template, tileGrid) {
      var zRegEx = /\{z\}/g;
      var xRegEx = /\{x\}/g;
      var yRegEx = /\{y\}/g;
      var dashYRegEx = /\{-y\}/g;
      return (
        /**
         * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {module:ol/proj/Projection} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            return template.replace(zRegEx, tileCoord[0].toString())
              .replace(xRegEx, tileCoord[1].toString())
              .replace(yRegEx, function() {
                var y = -tileCoord[2] - 1;
                return y.toString();
              })
              .replace(dashYRegEx, function() {
                var z = tileCoord[0];
                var range = tileGrid.getFullTileRange(z);
                assert(range, 55); // The {-y} placeholder requires a tile grid with extent
                var y = range.getHeight() + tileCoord[2];
                return y.toString();
              });
          }
        }
      );
    }


    /**
     * @param {Array.<string>} templates Templates.
     * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
     * @return {module:ol/Tile~UrlFunction} Tile URL function.
     */
    function createFromTemplates(templates, tileGrid) {
      var len = templates.length;
      var tileUrlFunctions = new Array(len);
      for (var i = 0; i < len; ++i) {
        tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
      }
      return createFromTileUrlFunctions(tileUrlFunctions);
    }


    /**
     * @param {Array.<module:ol/Tile~UrlFunction>} tileUrlFunctions Tile URL Functions.
     * @return {module:ol/Tile~UrlFunction} Tile URL function.
     */
    function createFromTileUrlFunctions(tileUrlFunctions) {
      if (tileUrlFunctions.length === 1) {
        return tileUrlFunctions[0];
      }
      return (
        /**
         * @param {module:ol/tilecoord~TileCoord} tileCoord Tile Coordinate.
         * @param {number} pixelRatio Pixel ratio.
         * @param {module:ol/proj/Projection} projection Projection.
         * @return {string|undefined} Tile URL.
         */
        function(tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
            return undefined;
          } else {
            var h = hash(tileCoord);
            var index = modulo(h, tileUrlFunctions.length);
            return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
          }
        }
      );
    }


    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
      return undefined;
    }


    /**
     * @param {string} url URL.
     * @return {Array.<string>} Array of urls.
     */
    function expandUrl(url) {
      var urls = [];
      var match = /\{([a-z])-([a-z])\}/.exec(url);
      if (match) {
        // char range
        var startCharCode = match[1].charCodeAt(0);
        var stopCharCode = match[2].charCodeAt(0);
        var charCode;
        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
          urls.push(url.replace(match[0], String.fromCharCode(charCode)));
        }
        return urls;
      }
      match = match = /\{(\d+)-(\d+)\}/.exec(url);
      if (match) {
        // number range
        var stop = parseInt(match[2], 10);
        for (var i = parseInt(match[1], 10); i <= stop; i++) {
          urls.push(url.replace(match[0], i.toString()));
        }
        return urls;
      }
      urls.push(url);
      return urls;
    }

    /**
     * @module ol/tilegrid/TileGrid
     */


    /**
     * @private
     * @type {module:ol/tilecoord~TileCoord}
     */
    var tmpTileCoord = [0, 0, 0];


    /**
     * @typedef {Object} Options
     * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. No tiles outside this
     * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
     * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
     * @property {number} [minZoom=0] Minimum zoom.
     * @property {module:ol/coordinate~Coordinate} [origin] The tile grid origin, i.e. where the `x`
     * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not
     * specified, `extent` or `origins` must be provided.
     * @property {Array.<module:ol/coordinate~Coordinate>} [origins] Tile grid origins, i.e. where
     * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or
     * `origin` must be provided.
     * @property {!Array.<number>} resolutions Resolutions. The array index of each resolution needs
     * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
     * array will have a length of `maxZoom + 1`.
     * @property {Array.<module:ol/size~Size>} [sizes] Sizes.
     * @property {number|module:ol/size~Size} [tileSize] Tile size.
     * Default is `[256, 256]`.
     * @property {Array.<module:ol/size~Size>} [tileSizes] Tile sizes. If given, the array length
     * should match the length of the `resolutions` array, i.e. each resolution can have a different
     * tile size.
     */


    /**
     * @classdesc
     * Base class for setting the grid pattern for sources accessing tiled-image
     * servers.
     * @api
     */
    var TileGrid = function TileGrid(options) {
      var this$1 = this;


      /**
       * @protected
       * @type {number}
       */
      this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

      /**
       * @private
       * @type {!Array.<number>}
       */
      this.resolutions_ = options.resolutions;
      assert(isSorted(this.resolutions_, function(a, b) {
        return b - a;
      }, true), 17); // `resolutions` must be sorted in descending order


      // check if we've got a consistent zoom factor and origin
      var zoomFactor;
      if (!options.origins) {
        for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
          if (!zoomFactor) {
            zoomFactor = this$1.resolutions_[i] / this$1.resolutions_[i + 1];
          } else {
            if (this$1.resolutions_[i] / this$1.resolutions_[i + 1] !== zoomFactor) {
              zoomFactor = undefined;
              break;
            }
          }
        }
      }


      /**
       * @private
       * @type {number|undefined}
       */
      this.zoomFactor_ = zoomFactor;


      /**
       * @protected
       * @type {number}
       */
      this.maxZoom = this.resolutions_.length - 1;

      /**
       * @private
       * @type {module:ol/coordinate~Coordinate}
       */
      this.origin_ = options.origin !== undefined ? options.origin : null;

      /**
       * @private
       * @type {Array.<module:ol/coordinate~Coordinate>}
       */
      this.origins_ = null;
      if (options.origins !== undefined) {
        this.origins_ = options.origins;
        assert(this.origins_.length == this.resolutions_.length,
          20); // Number of `origins` and `resolutions` must be equal
      }

      var extent = options.extent;

      if (extent !== undefined &&
          !this.origin_ && !this.origins_) {
        this.origin_ = getTopLeft(extent);
      }

      assert(
        (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),
        18); // Either `origin` or `origins` must be configured, never both

      /**
       * @private
       * @type {Array.<number|module:ol/size~Size>}
       */
      this.tileSizes_ = null;
      if (options.tileSizes !== undefined) {
        this.tileSizes_ = options.tileSizes;
        assert(this.tileSizes_.length == this.resolutions_.length,
          19); // Number of `tileSizes` and `resolutions` must be equal
      }

      /**
       * @private
       * @type {number|module:ol/size~Size}
       */
      this.tileSize_ = options.tileSize !== undefined ?
        options.tileSize :
        !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
      assert(
        (!this.tileSize_ && this.tileSizes_) ||
          (this.tileSize_ && !this.tileSizes_),
        22); // Either `tileSize` or `tileSizes` must be configured, never both

      /**
       * @private
       * @type {module:ol/extent~Extent}
       */
      this.extent_ = extent !== undefined ? extent : null;


      /**
       * @private
       * @type {Array.<module:ol/TileRange>}
       */
      this.fullTileRanges_ = null;

      /**
       * @private
       * @type {module:ol/size~Size}
       */
      this.tmpSize_ = [0, 0];

      if (options.sizes !== undefined) {
        this.fullTileRanges_ = options.sizes.map(function(size, z) {
          var tileRange = new TileRange(
            Math.min(0, size[0]), Math.max(size[0] - 1, -1),
            Math.min(0, size[1]), Math.max(size[1] - 1, -1));
          return tileRange;
        }, this);
      } else if (extent) {
        this.calculateTileRanges_(extent);
      }

    };

    /**
     * Call a function with each tile coordinate for a given extent and zoom level.
     *
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} zoom Integer zoom level.
     * @param {function(module:ol/tilecoord~TileCoord)} callback Function called with each tile coordinate.
     * @api
     */
    TileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {
      var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
      for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
        for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
          callback([zoom, i, j]);
        }
      }
    };

    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {function(this: T, number, module:ol/TileRange): boolean} callback Callback.
     * @param {T=} opt_this The object to use as `this` in `callback`.
     * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
     * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
     * @return {boolean} Callback succeeded.
     * @template T
     */
    TileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
        var this$1 = this;

      var tileRange, x, y;
      var tileCoordExtent = null;
      var z = tileCoord[0] - 1;
      if (this.zoomFactor_ === 2) {
        x = tileCoord[1];
        y = tileCoord[2];
      } else {
        tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
      }
      while (z >= this.minZoom) {
        if (this$1.zoomFactor_ === 2) {
          x = Math.floor(x / 2);
          y = Math.floor(y / 2);
          tileRange = createOrUpdate$1(x, x, y, y, opt_tileRange);
        } else {
          tileRange = this$1.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
        }
        if (callback.call(opt_this, z, tileRange)) {
          return true;
        }
        --z;
      }
      return false;
    };

    /**
     * Get the extent for this tile grid, if it was configured.
     * @return {module:ol/extent~Extent} Extent.
     */
    TileGrid.prototype.getExtent = function getExtent () {
      return this.extent_;
    };

    /**
     * Get the maximum zoom level for the grid.
     * @return {number} Max zoom.
     * @api
     */
    TileGrid.prototype.getMaxZoom = function getMaxZoom () {
      return this.maxZoom;
    };

    /**
     * Get the minimum zoom level for the grid.
     * @return {number} Min zoom.
     * @api
     */
    TileGrid.prototype.getMinZoom = function getMinZoom () {
      return this.minZoom;
    };

    /**
     * Get the origin for the grid at the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {module:ol/coordinate~Coordinate} Origin.
     * @api
     */
    TileGrid.prototype.getOrigin = function getOrigin (z) {
      if (this.origin_) {
        return this.origin_;
      } else {
        return this.origins_[z];
      }
    };

    /**
     * Get the resolution for the given zoom level.
     * @param {number} z Integer zoom level.
     * @return {number} Resolution.
     * @api
     */
    TileGrid.prototype.getResolution = function getResolution (z) {
      return this.resolutions_[z];
    };

    /**
     * Get the list of resolutions for the tile grid.
     * @return {Array.<number>} Resolutions.
     * @api
     */
    TileGrid.prototype.getResolutions = function getResolutions () {
      return this.resolutions_;
    };

    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {module:ol/TileRange=} opt_tileRange Temporary module:ol/TileRange object.
     * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
     * @return {module:ol/TileRange} Tile range.
     */
    TileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {
      if (tileCoord[0] < this.maxZoom) {
        if (this.zoomFactor_ === 2) {
          var minX = tileCoord[1] * 2;
          var minY = tileCoord[2] * 2;
          return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);
        }
        var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
        return this.getTileRangeForExtentAndZ(
          tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
      }
      return null;
    };

    /**
     * Get the extent for a tile range.
     * @param {number} z Integer zoom level.
     * @param {module:ol/TileRange} tileRange Tile range.
     * @param {module:ol/extent~Extent=} opt_extent Temporary module:ol/extent~Extent object.
     * @return {module:ol/extent~Extent} Extent.
     */
    TileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
      var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
      var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
      var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
      var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
    };

    /**
     * Get a tile range for the given extent and integer zoom level.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number} z Integer zoom level.
     * @param {module:ol/TileRange=} opt_tileRange Temporary tile range object.
     * @return {module:ol/TileRange} Tile range.
     */
    TileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {
      var tileCoord = tmpTileCoord;
      this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
      var minX = tileCoord[1];
      var minY = tileCoord[2];
      this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
      return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
    };

    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @return {module:ol/coordinate~Coordinate} Tile center.
     */
    TileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      return [
        origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
        origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution
      ];
    };

    /**
     * Get the extent of a tile coordinate.
     *
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {module:ol/extent~Extent=} opt_extent Temporary extent object.
     * @return {module:ol/extent~Extent} Extent.
     * @api
     */
    TileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {
      var origin = this.getOrigin(tileCoord[0]);
      var resolution = this.getResolution(tileCoord[0]);
      var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
      var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
      var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
      var maxX = minX + tileSize[0] * resolution;
      var maxY = minY + tileSize[1] * resolution;
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
    };

    /**
     * Get the tile coordinate for the given map coordinate and resolution.This
     * method considers that coordinates that intersect tile boundaries should be
     * assigned the higher tile coordinate.
     *
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     * @api
     */
    TileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {
      return this.getTileCoordForXYAndResolution_(
        coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
    };

    /**
     * Note that this method should not be called for resolutions that correspond
     * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.
     * @param {number} x X.
     * @param {number} y Y.
     * @param {number} resolution Resolution (for a non-integer zoom level).
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *   intersections go to the higher tile coordinate, let edge intersections
     *   go to the lower tile coordinate.
     * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     * @private
     */
    TileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
      var z = this.getZForResolution(resolution);
      var scale = resolution / this.getResolution(z);
      var origin = this.getOrigin(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);

      var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
      var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
      var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
      var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
      var tileCoordX = scale * xFromOrigin / tileSize[0];
      var tileCoordY = scale * yFromOrigin / tileSize[1];

      if (reverseIntersectionPolicy) {
        tileCoordX = Math.ceil(tileCoordX) - 1;
        tileCoordY = Math.ceil(tileCoordY) - 1;
      } else {
        tileCoordX = Math.floor(tileCoordX);
        tileCoordY = Math.floor(tileCoordY);
      }

      return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
    };

    /**
     * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
     * they should have separate implementations.This method is for integer zoom
     * levels.The other method should only be called for resolutions corresponding
     * to non-integer zoom levels.
     * @param {number} x Map x coordinate.
     * @param {number} y Map y coordinate.
     * @param {number} z Integer zoom level.
     * @param {boolean} reverseIntersectionPolicy Instead of letting edge
     *   intersections go to the higher tile coordinate, let edge intersections
     *   go to the lower tile coordinate.
     * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Temporary module:ol/tilecoord~TileCoord object.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     * @private
     */
    TileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
      var origin = this.getOrigin(z);
      var resolution = this.getResolution(z);
      var tileSize = toSize(this.getTileSize(z), this.tmpSize_);

      var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
      var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
      var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
      var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
      var tileCoordX = xFromOrigin / tileSize[0];
      var tileCoordY = yFromOrigin / tileSize[1];

      if (reverseIntersectionPolicy) {
        tileCoordX = Math.ceil(tileCoordX) - 1;
        tileCoordY = Math.ceil(tileCoordY) - 1;
      } else {
        tileCoordX = Math.floor(tileCoordX);
        tileCoordY = Math.floor(tileCoordY);
      }

      return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
    };

    /**
     * Get a tile coordinate given a map coordinate and zoom level.
     * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {number} z Zoom level.
     * @param {module:ol/tilecoord~TileCoord=} opt_tileCoord Destination module:ol/tilecoord~TileCoord object.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     * @api
     */
    TileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {
      return this.getTileCoordForXYAndZ_(
        coordinate[0], coordinate[1], z, false, opt_tileCoord);
    };

    /**
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @return {number} Tile resolution.
     */
    TileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {
      return this.resolutions_[tileCoord[0]];
    };

    /**
     * Get the tile size for a zoom level. The type of the return value matches the
     * `tileSize` or `tileSizes` that the tile grid was configured with. To always
     * get an `module:ol/size~Size`, run the result through `module:ol/size~Size.toSize()`.
     * @param {number} z Z.
     * @return {number|module:ol/size~Size} Tile size.
     * @api
     */
    TileGrid.prototype.getTileSize = function getTileSize (z) {
      if (this.tileSize_) {
        return this.tileSize_;
      } else {
        return this.tileSizes_[z];
      }
    };

    /**
     * @param {number} z Zoom level.
     * @return {module:ol/TileRange} Extent tile range for the specified zoom level.
     */
    TileGrid.prototype.getFullTileRange = function getFullTileRange (z) {
      if (!this.fullTileRanges_) {
        return null;
      } else {
        return this.fullTileRanges_[z];
      }
    };

    /**
     * @param {number} resolution Resolution.
     * @param {number=} opt_direction If 0, the nearest resolution will be used.
     *   If 1, the nearest lower resolution will be used. If -1, the nearest
     *   higher resolution will be used. Default is 0.
     * @return {number} Z.
     * @api
     */
    TileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {
      var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
      return clamp(z, this.minZoom, this.maxZoom);
    };

    /**
     * @param {!module:ol/extent~Extent} extent Extent for this tile grid.
     * @private
     */
    TileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {
        var this$1 = this;

      var length = this.resolutions_.length;
      var fullTileRanges = new Array(length);
      for (var z = this.minZoom; z < length; ++z) {
        fullTileRanges[z] = this$1.getTileRangeForExtentAndZ(extent, z);
      }
      this.fullTileRanges_ = fullTileRanges;
    };

    /**
     * @module ol/tilegrid
     */


    /**
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {!module:ol/tilegrid/TileGrid} Default tile grid for the
     * passed projection.
     */
    function getForProjection(projection) {
      var tileGrid = projection.getDefaultTileGrid();
      if (!tileGrid) {
        tileGrid = createForProjection(projection);
        projection.setDefaultTileGrid(tileGrid);
      }
      return tileGrid;
    }


    /**
     * @param {module:ol/tilegrid/TileGrid} tileGrid Tile grid.
     * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
     * @param {module:ol/proj/Projection} projection Projection.
     * @return {module:ol/tilecoord~TileCoord} Tile coordinate.
     */
    function wrapX(tileGrid, tileCoord, projection) {
      var z = tileCoord[0];
      var center = tileGrid.getTileCoordCenter(tileCoord);
      var projectionExtent = extentFromProjection(projection);
      if (!containsCoordinate(projectionExtent, center)) {
        var worldWidth = getWidth(projectionExtent);
        var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
        center[0] += worldWidth * worldsAway;
        return tileGrid.getTileCoordForCoordAndZ(center, z);
      } else {
        return tileCoord;
      }
    }


    /**
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
     * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
     */
    function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
      var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;

      var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

      return new TileGrid({
        extent: extent,
        origin: getCorner(extent, corner),
        resolutions: resolutions,
        tileSize: opt_tileSize
      });
    }


    /**
     * @typedef {Object} XYZOptions
     * @property {module:ol/extent~Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
     * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the
     * provided extent. If not provided, the extent of the EPSG:3857 projection is used.
     * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
     * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
     * @property {number} [minZoom=0] Minimum zoom.
     * @property {number|module:ol/size~Size} [tileSize=[256, 256]] Tile size in pixels.
     */


    /**
     * Creates a tile grid with a standard XYZ tiling scheme.
     * @param {module:ol/tilegrid~XYZOptions=} opt_options Tile grid options.
     * @return {!module:ol/tilegrid/TileGrid} Tile grid instance.
     * @api
     */
    function createXYZ(opt_options) {
      var options = /** @type {module:ol/tilegrid/TileGrid~Options} */ ({});
      assign(options, opt_options !== undefined ?
        opt_options : /** @type {module:ol/tilegrid~XYZOptions} */ ({}));
      if (options.extent === undefined) {
        options.extent = get$2('EPSG:3857').getExtent();
      }
      options.resolutions = resolutionsFromExtent(
        options.extent, options.maxZoom, options.tileSize);
      delete options.maxZoom;

      return new TileGrid(options);
    }


    /**
     * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
     * @param {module:ol/extent~Extent} extent Extent.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @return {!Array.<number>} Resolutions array.
     */
    function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {
      var maxZoom = opt_maxZoom !== undefined ?
        opt_maxZoom : DEFAULT_MAX_ZOOM;

      var height = getHeight(extent);
      var width = getWidth(extent);

      var tileSize = toSize(opt_tileSize !== undefined ?
        opt_tileSize : DEFAULT_TILE_SIZE);
      var maxResolution = Math.max(
        width / tileSize[0], height / tileSize[1]);

      var length = maxZoom + 1;
      var resolutions = new Array(length);
      for (var z = 0; z < length; ++z) {
        resolutions[z] = maxResolution / Math.pow(2, z);
      }
      return resolutions;
    }


    /**
     * @param {module:ol/proj~ProjectionLike} projection Projection.
     * @param {number=} opt_maxZoom Maximum zoom level (default is
     *     DEFAULT_MAX_ZOOM).
     * @param {number|module:ol/size~Size=} opt_tileSize Tile size (default uses
     *     DEFAULT_TILE_SIZE).
     * @param {module:ol/extent/Corner=} opt_corner Extent corner (default is `'top-left'`).
     * @return {!module:ol/tilegrid/TileGrid} TileGrid instance.
     */
    function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
      var extent = extentFromProjection(projection);
      return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
    }


    /**
     * Generate a tile grid extent from a projection.  If the projection has an
     * extent, it is used.  If not, a global extent is assumed.
     * @param {module:ol/proj~ProjectionLike} projection Projection.
     * @return {module:ol/extent~Extent} Extent.
     */
    function extentFromProjection(projection) {
      projection = get$2(projection);
      var extent = projection.getExtent();
      if (!extent) {
        var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();
        extent = createOrUpdate(-half, -half, half, half);
      }
      return extent;
    }

    /**
     * @module ol/source/Tile
     */

    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions]
     * @property {number} [cacheSize]
     * @property {module:ol/extent~Extent} [extent]
     * @property {boolean} [opaque]
     * @property {number} [tilePixelRatio]
     * @property {module:ol/proj~ProjectionLike} [projection]
     * @property {module:ol/source/State} [state]
     * @property {module:ol/tilegrid/TileGrid} [tileGrid]
     * @property {boolean} [wrapX=true]
     * @property {number} [transition]
     */


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for sources providing images divided into a tile grid.
     * @api
     */
    var TileSource = (function (Source$$1) {
      function TileSource(options) {

        Source$$1.call(this, {
          attributions: options.attributions,
          extent: options.extent,
          projection: options.projection,
          state: options.state,
          wrapX: options.wrapX
        });

        /**
         * @private
         * @type {boolean}
         */
        this.opaque_ = options.opaque !== undefined ? options.opaque : false;

        /**
         * @private
         * @type {number}
         */
        this.tilePixelRatio_ = options.tilePixelRatio !== undefined ?
          options.tilePixelRatio : 1;

        /**
         * @protected
         * @type {module:ol/tilegrid/TileGrid}
         */
        this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

        /**
         * @protected
         * @type {module:ol/TileCache}
         */
        this.tileCache = new TileCache(options.cacheSize);

        /**
         * @protected
         * @type {module:ol/size~Size}
         */
        this.tmpSize = [0, 0];

        /**
         * @private
         * @type {string}
         */
        this.key_ = '';

        /**
         * @protected
         * @type {module:ol/Tile~Options}
         */
        this.tileOptions = {transition: options.transition};

      }

      if ( Source$$1 ) TileSource.__proto__ = Source$$1;
      TileSource.prototype = Object.create( Source$$1 && Source$$1.prototype );
      TileSource.prototype.constructor = TileSource;

      /**
       * @return {boolean} Can expire cache.
       */
      TileSource.prototype.canExpireCache = function canExpireCache () {
        return this.tileCache.canExpireCache();
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @param {!Object.<string, module:ol/TileRange>} usedTiles Used tiles.
       */
      TileSource.prototype.expireCache = function expireCache (projection, usedTiles) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (tileCache) {
          tileCache.expireCache(usedTiles);
        }
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @param {number} z Zoom level.
       * @param {module:ol/TileRange} tileRange Tile range.
       * @param {function(module:ol/Tile):(boolean|undefined)} callback Called with each
       *     loaded tile.  If the callback returns `false`, the tile will not be
       *     considered loaded.
       * @return {boolean} The tile range is fully covered with loaded tiles.
       */
      TileSource.prototype.forEachLoadedTile = function forEachLoadedTile (projection, z, tileRange, callback) {
        var tileCache = this.getTileCacheForProjection(projection);
        if (!tileCache) {
          return false;
        }

        var covered = true;
        var tile, tileCoordKey, loaded;
        for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
          for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
            tileCoordKey = getKeyZXY(z, x, y);
            loaded = false;
            if (tileCache.containsKey(tileCoordKey)) {
              tile = /** @type {!module:ol/Tile} */ (tileCache.get(tileCoordKey));
              loaded = tile.getState() === TileState.LOADED;
              if (loaded) {
                loaded = (callback(tile) !== false);
              }
            }
            if (!loaded) {
              covered = false;
            }
          }
        }
        return covered;
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {number} Gutter.
       */
      TileSource.prototype.getGutter = function getGutter (projection) {
        return 0;
      };

      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @protected
       */
      TileSource.prototype.getKey = function getKey () {
        return this.key_;
      };

      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */
      TileSource.prototype.setKey = function setKey (key) {
        if (this.key_ !== key) {
          this.key_ = key;
          this.changed();
        }
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {boolean} Opaque.
       */
      TileSource.prototype.getOpaque = function getOpaque (projection) {
        return this.opaque_;
      };

      /**
       * @inheritDoc
       */
      TileSource.prototype.getResolutions = function getResolutions () {
        return this.tileGrid.getResolutions();
      };

      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {!module:ol/Tile} Tile.
       */
      TileSource.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {};

      /**
       * Return the tile grid of the tile source.
       * @return {module:ol/tilegrid/TileGrid} Tile grid.
       * @api
       */
      TileSource.prototype.getTileGrid = function getTileGrid () {
        return this.tileGrid;
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {!module:ol/tilegrid/TileGrid} Tile grid.
       */
      TileSource.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
        if (!this.tileGrid) {
          return getForProjection(projection);
        } else {
          return this.tileGrid;
        }
      };

      /**
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {module:ol/TileCache} Tile cache.
       * @protected
       */
      TileSource.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
        var thisProj = this.getProjection();
        if (thisProj && !equivalent(thisProj, projection)) {
          return null;
        } else {
          return this.tileCache;
        }
      };

      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      TileSource.prototype.getTilePixelRatio = function getTilePixelRatio (pixelRatio) {
        return this.tilePixelRatio_;
      };

      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {module:ol/size~Size} Tile size.
       */
      TileSource.prototype.getTilePixelSize = function getTilePixelSize (z, pixelRatio, projection) {
        var tileGrid = this.getTileGridForProjection(projection);
        var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
        var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
        if (tilePixelRatio == 1) {
          return tileSize;
        } else {
          return scale$3(tileSize, tilePixelRatio, this.tmpSize);
        }
      };

      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {module:ol/tilecoord~TileCoord} tileCoord Tile coordinate.
       * @param {module:ol/proj/Projection=} opt_projection Projection.
       * @return {module:ol/tilecoord~TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */
      TileSource.prototype.getTileCoordForTileUrlFunction = function getTileCoordForTileUrlFunction (tileCoord, opt_projection) {
        var projection = opt_projection !== undefined ?
          opt_projection : this.getProjection();
        var tileGrid = this.getTileGridForProjection(projection);
        if (this.getWrapX() && projection.isGlobal()) {
          tileCoord = wrapX(tileGrid, tileCoord, projection);
        }
        return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      };

      /**
       * @inheritDoc
       */
      TileSource.prototype.refresh = function refresh () {
        this.tileCache.clear();
        this.changed();
      };

      return TileSource;
    }(Source));


    /**
     * Marks a tile coord as being used, without triggering a load.
     * @param {number} z Tile coordinate z.
     * @param {number} x Tile coordinate x.
     * @param {number} y Tile coordinate y.
     * @param {module:ol/proj/Projection} projection Projection.
     */
    TileSource.prototype.useTile = UNDEFINED;


    /**
     * @classdesc
     * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
     * type.
     */
    var TileSourceEvent = (function (Event$$1) {
      function TileSourceEvent(type, tile) {

        Event$$1.call(this, type);

        /**
         * The tile related to the event.
         * @type {module:ol/Tile}
         * @api
         */
        this.tile = tile;

      }

      if ( Event$$1 ) TileSourceEvent.__proto__ = Event$$1;
      TileSourceEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      TileSourceEvent.prototype.constructor = TileSourceEvent;

      return TileSourceEvent;
    }(Event));

    /**
     * @module ol/source/TileEventType
     */

    /**
     * @enum {string}
     */
    var TileEventType = {

      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile~TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: 'tileloadstart',

      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile~TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: 'tileloadend',

      /**
       * Triggered if tile loading results in an error.
       * @event module:ol/source/Tile~TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: 'tileloaderror'

    };

    /**
     * @module ol/source/UrlTile
     */

    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions]
     * @property {number} [cacheSize]
     * @property {module:ol/extent~Extent} [extent]
     * @property {boolean} [opaque]
     * @property {module:ol/proj~ProjectionLike} [projection]
     * @property {module:ol/source/State} [state]
     * @property {module:ol/tilegrid/TileGrid} [tileGrid]
     * @property {module:ol/Tile~LoadFunction} tileLoadFunction
     * @property {number} [tilePixelRatio]
     * @property {module:ol/Tile~UrlFunction} [tileUrlFunction]
     * @property {string} [url]
     * @property {Array.<string>} [urls]
     * @property {boolean} [wrapX=true]
     * @property {number} [transition]
     */


    /**
     * @classdesc
     * Base class for sources providing tiles divided into a tile grid over http.
     *
     * @fires module:ol/source/TileEvent
     */
    var UrlTile = (function (TileSource$$1) {
      function UrlTile(options) {

        TileSource$$1.call(this, {
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          extent: options.extent,
          opaque: options.opaque,
          projection: options.projection,
          state: options.state,
          tileGrid: options.tileGrid,
          tilePixelRatio: options.tilePixelRatio,
          wrapX: options.wrapX,
          transition: options.transition
        });

        /**
         * @protected
         * @type {module:ol/Tile~LoadFunction}
         */
        this.tileLoadFunction = options.tileLoadFunction;

        /**
         * @protected
         * @type {module:ol/Tile~UrlFunction}
         */
        this.tileUrlFunction = this.fixedTileUrlFunction ?
          this.fixedTileUrlFunction.bind(this) : nullTileUrlFunction;

        /**
         * @protected
         * @type {!Array.<string>|null}
         */
        this.urls = null;

        if (options.urls) {
          this.setUrls(options.urls);
        } else if (options.url) {
          this.setUrl(options.url);
        }
        if (options.tileUrlFunction) {
          this.setTileUrlFunction(options.tileUrlFunction);
        }

        /**
         * @private
         * @type {!Object.<number, boolean>}
         */
        this.tileLoadingKeys_ = {};

      }

      if ( TileSource$$1 ) UrlTile.__proto__ = TileSource$$1;
      UrlTile.prototype = Object.create( TileSource$$1 && TileSource$$1.prototype );
      UrlTile.prototype.constructor = UrlTile;

      /**
       * Return the tile load function of the source.
       * @return {module:ol/Tile~LoadFunction} TileLoadFunction
       * @api
       */
      UrlTile.prototype.getTileLoadFunction = function getTileLoadFunction () {
        return this.tileLoadFunction;
      };

      /**
       * Return the tile URL function of the source.
       * @return {module:ol/Tile~UrlFunction} TileUrlFunction
       * @api
       */
      UrlTile.prototype.getTileUrlFunction = function getTileUrlFunction () {
        return this.tileUrlFunction;
      };

      /**
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array.<string>|null} URLs.
       * @api
       */
      UrlTile.prototype.getUrls = function getUrls () {
        return this.urls;
      };

      /**
       * Handle tile change events.
       * @param {module:ol/events/Event} event Event.
       * @protected
       */
      UrlTile.prototype.handleTileChange = function handleTileChange (event) {
        var tile = /** @type {module:ol/Tile} */ (event.target);
        var uid = getUid(tile);
        var tileState = tile.getState();
        var type;
        if (tileState == TileState.LOADING) {
          this.tileLoadingKeys_[uid] = true;
          type = TileEventType.TILELOADSTART;
        } else if (uid in this.tileLoadingKeys_) {
          delete this.tileLoadingKeys_[uid];
          type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR :
            (tileState == TileState.LOADED || tileState == TileState.ABORT) ?
              TileEventType.TILELOADEND : undefined;
        }
        if (type != undefined) {
          this.dispatchEvent(new TileSourceEvent(type, tile));
        }
      };

      /**
       * Set the tile load function of the source.
       * @param {module:ol/Tile~LoadFunction} tileLoadFunction Tile load function.
       * @api
       */
      UrlTile.prototype.setTileLoadFunction = function setTileLoadFunction (tileLoadFunction) {
        this.tileCache.clear();
        this.tileLoadFunction = tileLoadFunction;
        this.changed();
      };

      /**
       * Set the tile URL function of the source.
       * @param {module:ol/Tile~UrlFunction} tileUrlFunction Tile URL function.
       * @param {string=} opt_key Optional new tile key for the source.
       * @api
       */
      UrlTile.prototype.setTileUrlFunction = function setTileUrlFunction (tileUrlFunction, opt_key) {
        this.tileUrlFunction = tileUrlFunction;
        this.tileCache.pruneExceptNewestZ();
        if (typeof opt_key !== 'undefined') {
          this.setKey(opt_key);
        } else {
          this.changed();
        }
      };

      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */
      UrlTile.prototype.setUrl = function setUrl (url) {
        var urls = this.urls = expandUrl(url);
        this.setTileUrlFunction(this.fixedTileUrlFunction ?
          this.fixedTileUrlFunction.bind(this) :
          createFromTemplates(urls, this.tileGrid), url);
      };

      /**
       * Set the URLs to use for requests.
       * @param {Array.<string>} urls URLs.
       * @api
       */
      UrlTile.prototype.setUrls = function setUrls (urls) {
        this.urls = urls;
        var key = urls.join('\n');
        this.setTileUrlFunction(this.fixedTileUrlFunction ?
          this.fixedTileUrlFunction.bind(this) :
          createFromTemplates(urls, this.tileGrid), key);
      };

      /**
       * @inheritDoc
       */
      UrlTile.prototype.useTile = function useTile (z, x, y) {
        var tileCoordKey = getKeyZXY(z, x, y);
        if (this.tileCache.containsKey(tileCoordKey)) {
          this.tileCache.get(tileCoordKey);
        }
      };

      return UrlTile;
    }(TileSource));


    /**
     * @type {module:ol/Tile~UrlFunction|undefined}
     * @protected
     */
    UrlTile.prototype.fixedTileUrlFunction;

    /**
     * @module ol/source/TileImage
     */

    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
     * @property {number} [cacheSize=2048] Cache size.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
     * access pixel data with the Canvas renderer.  See
     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [opaque=true] Whether the layer is opaque.
     * @property {module:ol/proj~ProjectionLike} projection Projection.
     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {module:ol/source/State} [state] Source state.
     * @property {module:ol/ImageTile~TileClass} [tileClass] Class used to instantiate image tiles.
     * Default is {@link module:ol/ImageTile~ImageTile}.
     * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
     * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
     * service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
     * used instead of defining each one separately in the `urls` option.
     * @property {Array.<string>} [urls] An array of URL templates.
     * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
     * request out-of-bounds tiles from the server. When set to `false`, only one
     * world will be rendered. When set to `true`, tiles will be requested for one
     * world only, but they will be wrapped horizontally to render multiple worlds.
     * @property {number} [transition] Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */


    /**
     * @classdesc
     * Base class for sources providing images divided into a tile grid.
     *
     * @fires module:ol/source/Tile~TileSourceEvent
     * @api
     */
    var TileImage = (function (UrlTile$$1) {
      function TileImage(options) {

        UrlTile$$1.call(this, {
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          extent: options.extent,
          opaque: options.opaque,
          projection: options.projection,
          state: options.state,
          tileGrid: options.tileGrid,
          tileLoadFunction: options.tileLoadFunction ?
            options.tileLoadFunction : defaultTileLoadFunction,
          tilePixelRatio: options.tilePixelRatio,
          tileUrlFunction: options.tileUrlFunction,
          url: options.url,
          urls: options.urls,
          wrapX: options.wrapX,
          transition: options.transition
        });

        /**
         * @protected
         * @type {?string}
         */
        this.crossOrigin =
            options.crossOrigin !== undefined ? options.crossOrigin : null;

        /**
         * @protected
         * @type {function(new: module:ol/ImageTile, module:ol/tilecoord~TileCoord, module:ol/TileState, string,
         *        ?string, module:ol/Tile~LoadFunction, module:ol/Tile~Options=)}
         */
        this.tileClass = options.tileClass !== undefined ?
          options.tileClass : ImageTile;

        /**
         * @protected
         * @type {!Object.<string, module:ol/TileCache>}
         */
        this.tileCacheForProjection = {};

        /**
         * @protected
         * @type {!Object.<string, module:ol/tilegrid/TileGrid>}
         */
        this.tileGridForProjection = {};

        /**
         * @private
         * @type {number|undefined}
         */
        this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

        /**
         * @private
         * @type {boolean}
         */
        this.renderReprojectionEdges_ = false;
      }

      if ( UrlTile$$1 ) TileImage.__proto__ = UrlTile$$1;
      TileImage.prototype = Object.create( UrlTile$$1 && UrlTile$$1.prototype );
      TileImage.prototype.constructor = TileImage;

      /**
       * @inheritDoc
       */
      TileImage.prototype.canExpireCache = function canExpireCache () {
        var this$1 = this;
        if (this.tileCache.canExpireCache()) {
          return true;
        } else {
          for (var key in this$1.tileCacheForProjection) {
            if (this$1.tileCacheForProjection[key].canExpireCache()) {
              return true;
            }
          }
        }
        return false;
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.expireCache = function expireCache (projection, usedTiles) {
        var this$1 = this;
        var usedTileCache = this.getTileCacheForProjection(projection);

        this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
        for (var id in this$1.tileCacheForProjection) {
          var tileCache = this$1.tileCacheForProjection[id];
          tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
        }
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.getGutter = function getGutter (projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return 0;
        } else {
          return this.getGutterInternal();
        }
      };

      /**
       * @protected
       * @return {number} Gutter.
       */
      TileImage.prototype.getGutterInternal = function getGutterInternal () {
        return 0;
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.getOpaque = function getOpaque (projection) {
        if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
          return false;
        } else {
          return UrlTile$$1.prototype.getOpaque.call(this, projection);
        }
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.getTileGridForProjection = function getTileGridForProjection$1 (projection) {
        var thisProj = this.getProjection();
        if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
          return this.tileGrid;
        } else {
          var projKey = getUid(projection).toString();
          if (!(projKey in this.tileGridForProjection)) {
            this.tileGridForProjection[projKey] = getForProjection(projection);
          }
          return (
            /** @type {!module:ol/tilegrid/TileGrid} */ (this.tileGridForProjection[projKey])
          );
        }
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.getTileCacheForProjection = function getTileCacheForProjection (projection) {
        var thisProj = this.getProjection(); if (!thisProj || equivalent(thisProj, projection)) {
          return this.tileCache;
        } else {
          var projKey = getUid(projection).toString();
          if (!(projKey in this.tileCacheForProjection)) {
            this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
          }
          return this.tileCacheForProjection[projKey];
        }
      };

      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!module:ol/Tile} Tile.
       * @private
       */
      TileImage.prototype.createTile_ = function createTile_ (z, x, y, pixelRatio, projection, key) {
        var tileCoord = [z, x, y];
        var urlTileCoord = this.getTileCoordForTileUrlFunction(
          tileCoord, projection);
        var tileUrl = urlTileCoord ?
          this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
        var tile = new this.tileClass(
          tileCoord,
          tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY,
          tileUrl !== undefined ? tileUrl : '',
          this.crossOrigin,
          this.tileLoadFunction,
          this.tileOptions);
        tile.key = key;
        listen(tile, EventType.CHANGE,
          this.handleTileChange, this);
        return tile;
      };

      /**
       * @inheritDoc
       */
      TileImage.prototype.getTile = function getTile (z, x, y, pixelRatio, projection) {
        var sourceProjection = /** @type {!module:ol/proj/Projection} */ (this.getProjection());
        if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
          return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
        } else {
          var cache = this.getTileCacheForProjection(projection);
          var tileCoord = [z, x, y];
          var tile;
          var tileCoordKey = getKey$1(tileCoord);
          if (cache.containsKey(tileCoordKey)) {
            tile = /** @type {!module:ol/Tile} */ (cache.get(tileCoordKey));
          }
          var key = this.getKey();
          if (tile && tile.key == key) {
            return tile;
          } else {
            var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
            var targetTileGrid = this.getTileGridForProjection(projection);
            var wrappedTileCoord =
                this.getTileCoordForTileUrlFunction(tileCoord, projection);
            var newTile = new ReprojTile(
              sourceProjection, sourceTileGrid,
              projection, targetTileGrid,
              tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio),
              this.getGutterInternal(),
              function(z, x, y, pixelRatio) {
                return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
              }.bind(this), this.reprojectionErrorThreshold_,
              this.renderReprojectionEdges_);
            newTile.key = key;

            if (tile) {
              newTile.interimTile = tile;
              newTile.refreshInterimChain();
              cache.replace(tileCoordKey, newTile);
            } else {
              cache.set(tileCoordKey, newTile);
            }
            return newTile;
          }
        }
      };

      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!module:ol/proj/Projection} projection Projection.
       * @return {!module:ol/Tile} Tile.
       * @protected
       */
      TileImage.prototype.getTileInternal = function getTileInternal (z, x, y, pixelRatio, projection) {
        var tile = null;
        var tileCoordKey = getKeyZXY(z, x, y);
        var key = this.getKey();
        if (!this.tileCache.containsKey(tileCoordKey)) {
          tile = this.createTile_(z, x, y, pixelRatio, projection, key);
          this.tileCache.set(tileCoordKey, tile);
        } else {
          tile = this.tileCache.get(tileCoordKey);
          if (tile.key != key) {
            // The source's params changed. If the tile has an interim tile and if we
            // can use it then we use it. Otherwise we create a new tile.  In both
            // cases we attempt to assign an interim tile to the new tile.
            var interimTile = tile;
            tile = this.createTile_(z, x, y, pixelRatio, projection, key);

            //make the new tile the head of the list,
            if (interimTile.getState() == TileState.IDLE) {
              //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
              tile.interimTile = interimTile.interimTile;
            } else {
              tile.interimTile = interimTile;
            }
            tile.refreshInterimChain();
            this.tileCache.replace(tileCoordKey, tile);
          }
        }
        return tile;
      };

      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */
      TileImage.prototype.setRenderReprojectionEdges = function setRenderReprojectionEdges (render) {
        var this$1 = this;

        if (this.renderReprojectionEdges_ == render) {
          return;
        }
        this.renderReprojectionEdges_ = render;
        for (var id in this$1.tileCacheForProjection) {
          this$1.tileCacheForProjection[id].clear();
        }
        this.changed();
      };

      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {module:ol/proj~ProjectionLike} projection Projection.
       * @param {module:ol/tilegrid/TileGrid} tilegrid Tile grid to use for the projection.
       * @api
       */
      TileImage.prototype.setTileGridForProjection = function setTileGridForProjection (projection, tilegrid) {
        {
          var proj = get$2(projection);
          if (proj) {
            var projKey = getUid(proj).toString();
            if (!(projKey in this.tileGridForProjection)) {
              this.tileGridForProjection[projKey] = tilegrid;
            }
          }
        }
      };

      return TileImage;
    }(UrlTile));


    /**
     * @param {module:ol/ImageTile} imageTile Image tile.
     * @param {string} src Source.
     */
    function defaultTileLoadFunction(imageTile, src) {
      imageTile.getImage().src = src;
    }

    /**
     * @module ol/source/XYZ
     */

    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
     * @property {number} [cacheSize=2048] Cache size.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
     * access pixel data with the Canvas renderer.  See
     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [opaque=true] Whether the layer is opaque.
     * @property {module:ol/proj~ProjectionLike} [projection='EPSG:3857'] Projection.
     * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {number} [maxZoom=18] Optional max zoom level.
     * @property {number} [minZoom=0] Optional min zoom level.
     * @property {module:ol/tilegrid/TileGrid} [tileGrid] Tile grid.
     * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
     * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
     * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
     * should be set to `2`.
     * @property {number|module:ol/size~Size} [tileSize=[256, 256]] The tile size used by the tile service.
     * @property {module:ol/Tile~UrlFunction} [tileUrlFunction] Optional function to get
     * tile URL given a tile coordinate and the projection.
     * Required if url or urls are not provided.
     * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
     * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
     * may be used instead of defining each one separately in the `urls` option.
     * @property {Array.<string>} [urls] An array of URL templates.
     * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
     * @property {number} [transition] Duration of the opacity transition for rendering.
     * To disable the opacity transition, pass `transition: 0`.
     */


    /**
     * @classdesc
     * Layer source for tile data with URLs in a set XYZ format that are
     * defined in a URL template. By default, this follows the widely-used
     * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
     * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
     * using the `{-y}` placeholder in the URL template, so long as the
     * source does not have a custom tile grid. In this case,
     * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
     * such as:
     *
     *  tileUrlFunction: function(coordinate) {
     *    return 'http://mapserver.com/' + coordinate[0] + '/' +
     *        coordinate[1] + '/' + coordinate[2] + '.png';
     *    }
     *
     * @api
     */
    var XYZ = (function (TileImage$$1) {
      function XYZ(opt_options) {
        var options = opt_options || {};
        var projection = options.projection !== undefined ?
          options.projection : 'EPSG:3857';

        var tileGrid = options.tileGrid !== undefined ? options.tileGrid :
          createXYZ({
            extent: extentFromProjection(projection),
            maxZoom: options.maxZoom,
            minZoom: options.minZoom,
            tileSize: options.tileSize
          });

        TileImage$$1.call(this, {
          attributions: options.attributions,
          cacheSize: options.cacheSize,
          crossOrigin: options.crossOrigin,
          opaque: options.opaque,
          projection: projection,
          reprojectionErrorThreshold: options.reprojectionErrorThreshold,
          tileGrid: tileGrid,
          tileLoadFunction: options.tileLoadFunction,
          tilePixelRatio: options.tilePixelRatio,
          tileUrlFunction: options.tileUrlFunction,
          url: options.url,
          urls: options.urls,
          wrapX: options.wrapX !== undefined ? options.wrapX : true,
          transition: options.transition
        });

      }

      if ( TileImage$$1 ) XYZ.__proto__ = TileImage$$1;
      XYZ.prototype = Object.create( TileImage$$1 && TileImage$$1.prototype );
      XYZ.prototype.constructor = XYZ;

      return XYZ;
    }(TileImage));

    /**
     * @module ol/source/OSM
     */


    /**
     * The attribution containing a link to the OpenStreetMap Copyright and License
     * page.
     * @const
     * @type {string}
     * @api
     */
    var ATTRIBUTION = '&copy; ' +
          '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
          'contributors.';


    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
     * @property {number} [cacheSize=2048] Cache size.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
     * access pixel data with the Canvas renderer.  See
     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {number} [maxZoom=19] Max zoom.
     * @property {boolean} [opaque=true] Whether the layer is opaque.
     * @property {number} [reprojectionErrorThreshold=1.5] Maximum allowed reprojection error (in pixels).
     * Higher values can increase reprojection performance, but decrease precision.
     * @property {module:ol/Tile~LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
     * ```js
     * function(imageTile, src) {
     *   imageTile.getImage().src = src;
     * };
     * ```
     * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
     * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
     * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
     */


    /**
     * @classdesc
     * Layer source for the OpenStreetMap tile server.
     * @api
     */
    var OSM = (function (XYZ$$1) {
      function OSM(opt_options) {

        var options = opt_options || {};

        var attributions;
        if (options.attributions !== undefined) {
          attributions = options.attributions;
        } else {
          attributions = [ATTRIBUTION];
        }

        var crossOrigin = options.crossOrigin !== undefined ?
          options.crossOrigin : 'anonymous';

        var url = options.url !== undefined ?
          options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

        XYZ$$1.call(this, {
          attributions: attributions,
          cacheSize: options.cacheSize,
          crossOrigin: crossOrigin,
          opaque: options.opaque !== undefined ? options.opaque : true,
          maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
          reprojectionErrorThreshold: options.reprojectionErrorThreshold,
          tileLoadFunction: options.tileLoadFunction,
          url: url,
          wrapX: options.wrapX
        });

      }

      if ( XYZ$$1 ) OSM.__proto__ = XYZ$$1;
      OSM.prototype = Object.create( XYZ$$1 && XYZ$$1.prototype );
      OSM.prototype.constructor = OSM;

      return OSM;
    }(XYZ));

    /**
     * Default WMS version.
     * @type {string}
     */
    var DEFAULT_WMS_VERSION = '1.3.0';

    /**
     * @module ol/Image
     */


    /**
     * A function that takes an {@link module:ol/Image~Image} for the image and a
     * `{string}` for the src as arguments. It is supposed to make it so the
     * underlying image {@link module:ol/Image~Image#getImage} is assigned the
     * content specified by the src. If not specified, the default is
     *
     *     function(image, src) {
     *       image.getImage().src = src;
     *     }
     *
     * Providing a custom `imageLoadFunction` can be useful to load images with
     * post requests or - in general - through XHR requests, where the src of the
     * image element would be set to a data URI when the content is loaded.
     *
     * @typedef {function(module:ol/Image, string)} LoadFunction
     * @api
     */


    var ImageWrapper = (function (ImageBase$$1) {
      function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {

        ImageBase$$1.call(this, extent, resolution, pixelRatio, ImageState.IDLE);

        /**
         * @private
         * @type {string}
         */
        this.src_ = src;

        /**
         * @private
         * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
         */
        this.image_ = new Image();
        if (crossOrigin !== null) {
          this.image_.crossOrigin = crossOrigin;
        }

        /**
         * @private
         * @type {Array.<module:ol/events~EventsKey>}
         */
        this.imageListenerKeys_ = null;

        /**
         * @protected
         * @type {module:ol/ImageState}
         */
        this.state = ImageState.IDLE;

        /**
         * @private
         * @type {module:ol/Image~LoadFunction}
         */
        this.imageLoadFunction_ = imageLoadFunction;

      }

      if ( ImageBase$$1 ) ImageWrapper.__proto__ = ImageBase$$1;
      ImageWrapper.prototype = Object.create( ImageBase$$1 && ImageBase$$1.prototype );
      ImageWrapper.prototype.constructor = ImageWrapper;

      /**
       * @inheritDoc
       * @api
       */
      ImageWrapper.prototype.getImage = function getImage () {
        return this.image_;
      };

      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageError_ = function handleImageError_ () {
        this.state = ImageState.ERROR;
        this.unlistenImage_();
        this.changed();
      };

      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageLoad_ = function handleImageLoad_ () {
        if (this.resolution === undefined) {
          this.resolution = getHeight(this.extent) / this.image_.height;
        }
        this.state = ImageState.LOADED;
        this.unlistenImage_();
        this.changed();
      };

      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @override
       * @api
       */
      ImageWrapper.prototype.load = function load () {
        if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
          this.state = ImageState.LOADING;
          this.changed();
          this.imageListenerKeys_ = [
            listenOnce(this.image_, EventType.ERROR,
              this.handleImageError_, this),
            listenOnce(this.image_, EventType.LOAD,
              this.handleImageLoad_, this)
          ];
          this.imageLoadFunction_(this, this.src_);
        }
      };

      /**
       * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
       */
      ImageWrapper.prototype.setImage = function setImage (image) {
        this.image_ = image;
      };

      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageWrapper.prototype.unlistenImage_ = function unlistenImage_ () {
        this.imageListenerKeys_.forEach(unlistenByKey);
        this.imageListenerKeys_ = null;
      };

      return ImageWrapper;
    }(ImageBase));

    /**
     * @module ol/reproj/Image
     */


    /**
     * @typedef {function(module:ol/extent~Extent, number, number) : module:ol/ImageBase} FunctionType
     */


    /**
     * @classdesc
     * Class encapsulating single reprojected image.
     * See {@link module:ol/source/Image~ImageSource}.
     */
    var ReprojImage = (function (ImageBase$$1) {
      function ReprojImage(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction) {
        var maxSourceExtent = sourceProj.getExtent();
        var maxTargetExtent = targetProj.getExtent();

        var limitedTargetExtent = maxTargetExtent ?
          getIntersection(targetExtent, maxTargetExtent) : targetExtent;

        var targetCenter = getCenter(limitedTargetExtent);
        var sourceResolution = calculateSourceResolution(
          sourceProj, targetProj, targetCenter, targetResolution);

        var errorThresholdInPixels = ERROR_THRESHOLD;

        var triangulation = new Triangulation(
          sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,
          sourceResolution * errorThresholdInPixels);

        var sourceExtent = triangulation.calculateSourceExtent();
        var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
        var state = ImageState.LOADED;
        if (sourceImage) {
          state = ImageState.IDLE;
        }
        var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;

        ImageBase$$1.call(this, targetExtent, targetResolution, sourcePixelRatio, state);

        /**
         * @private
         * @type {module:ol/proj/Projection}
         */
        this.targetProj_ = targetProj;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.maxSourceExtent_ = maxSourceExtent;

        /**
         * @private
         * @type {!module:ol/reproj/Triangulation}
         */
        this.triangulation_ = triangulation;

        /**
         * @private
         * @type {number}
         */
        this.targetResolution_ = targetResolution;

        /**
         * @private
         * @type {module:ol/extent~Extent}
         */
        this.targetExtent_ = targetExtent;

        /**
         * @private
         * @type {module:ol/ImageBase}
         */
        this.sourceImage_ = sourceImage;

        /**
         * @private
         * @type {number}
         */
        this.sourcePixelRatio_ = sourcePixelRatio;

        /**
         * @private
         * @type {HTMLCanvasElement}
         */
        this.canvas_ = null;

        /**
         * @private
         * @type {?module:ol/events~EventsKey}
         */
        this.sourceListenerKey_ = null;
      }

      if ( ImageBase$$1 ) ReprojImage.__proto__ = ImageBase$$1;
      ReprojImage.prototype = Object.create( ImageBase$$1 && ImageBase$$1.prototype );
      ReprojImage.prototype.constructor = ReprojImage;

      /**
       * @inheritDoc
       */
      ReprojImage.prototype.disposeInternal = function disposeInternal () {
        if (this.state == ImageState.LOADING) {
          this.unlistenSource_();
        }
        ImageBase$$1.prototype.disposeInternal.call(this);
      };

      /**
       * @inheritDoc
       */
      ReprojImage.prototype.getImage = function getImage () {
        return this.canvas_;
      };

      /**
       * @return {module:ol/proj/Projection} Projection.
       */
      ReprojImage.prototype.getProjection = function getProjection () {
        return this.targetProj_;
      };

      /**
       * @private
       */
      ReprojImage.prototype.reproject_ = function reproject_ () {
        var sourceState = this.sourceImage_.getState();
        if (sourceState == ImageState.LOADED) {
          var width = getWidth(this.targetExtent_) / this.targetResolution_;
          var height = getHeight(this.targetExtent_) / this.targetResolution_;

          this.canvas_ = render$2(width, height, this.sourcePixelRatio_,
            this.sourceImage_.getResolution(), this.maxSourceExtent_,
            this.targetResolution_, this.targetExtent_, this.triangulation_, [{
              extent: this.sourceImage_.getExtent(),
              image: this.sourceImage_.getImage()
            }], 0);
        }
        this.state = sourceState;
        this.changed();
      };

      /**
       * @inheritDoc
       */
      ReprojImage.prototype.load = function load () {
        if (this.state == ImageState.IDLE) {
          this.state = ImageState.LOADING;
          this.changed();

          var sourceState = this.sourceImage_.getState();
          if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
            this.reproject_();
          } else {
            this.sourceListenerKey_ = listen(this.sourceImage_,
              EventType.CHANGE, function(e) {
                var sourceState = this.sourceImage_.getState();
                if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {
                  this.unlistenSource_();
                  this.reproject_();
                }
              }, this);
            this.sourceImage_.load();
          }
        }
      };

      /**
       * @private
       */
      ReprojImage.prototype.unlistenSource_ = function unlistenSource_ () {
        unlistenByKey(/** @type {!module:ol/events~EventsKey} */ (this.sourceListenerKey_));
        this.sourceListenerKey_ = null;
      };

      return ReprojImage;
    }(ImageBase));

    /**
     * @module ol/source/Image
     */


    /**
     * @enum {string}
     */
    var ImageSourceEventType = {

      /**
       * Triggered when an image starts loading.
       * @event ol/source/Image~ImageSourceEvent#imageloadstart
       * @api
       */
      IMAGELOADSTART: 'imageloadstart',

      /**
       * Triggered when an image finishes loading.
       * @event ol/source/Image~ImageSourceEvent#imageloadend
       * @api
       */
      IMAGELOADEND: 'imageloadend',

      /**
       * Triggered if image loading results in an error.
       * @event ol/source/Image~ImageSourceEvent#imageloaderror
       * @api
       */
      IMAGELOADERROR: 'imageloaderror'

    };


    /**
     * @classdesc
     * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this
     * type.
     */
    var ImageSourceEvent = (function (Event$$1) {
      function ImageSourceEvent(type, image) {

        Event$$1.call(this, type);

        /**
         * The image related to the event.
         * @type {module:ol/Image}
         * @api
         */
        this.image = image;

      }

      if ( Event$$1 ) ImageSourceEvent.__proto__ = Event$$1;
      ImageSourceEvent.prototype = Object.create( Event$$1 && Event$$1.prototype );
      ImageSourceEvent.prototype.constructor = ImageSourceEvent;

      return ImageSourceEvent;
    }(Event));


    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions]
     * @property {module:ol/extent~Extent} [extent]
     * @property {module:ol/proj~ProjectionLike} projection
     * @property {Array.<number>} [resolutions]
     * @property {module:ol/source/State} [state]
     */


    /**
     * @classdesc
     * Abstract base class; normally only used for creating subclasses and not
     * instantiated in apps.
     * Base class for sources providing a single image.
     * @api
     */
    var ImageSource = (function (Source$$1) {
      function ImageSource(options) {
        Source$$1.call(this, {
          attributions: options.attributions,
          extent: options.extent,
          projection: options.projection,
          state: options.state
        });

        /**
         * @private
         * @type {Array.<number>}
         */
        this.resolutions_ = options.resolutions !== undefined ?
          options.resolutions : null;


        /**
         * @private
         * @type {module:ol/reproj/Image}
         */
        this.reprojectedImage_ = null;


        /**
         * @private
         * @type {number}
         */
        this.reprojectedRevision_ = 0;
      }

      if ( Source$$1 ) ImageSource.__proto__ = Source$$1;
      ImageSource.prototype = Object.create( Source$$1 && Source$$1.prototype );
      ImageSource.prototype.constructor = ImageSource;

      /**
       * @return {Array.<number>} Resolutions.
       * @override
       */
      ImageSource.prototype.getResolutions = function getResolutions () {
        return this.resolutions_;
      };

      /**
       * @protected
       * @param {number} resolution Resolution.
       * @return {number} Resolution.
       */
      ImageSource.prototype.findNearestResolution = function findNearestResolution (resolution) {
        if (this.resolutions_) {
          var idx = linearFindNearest(this.resolutions_, resolution, 0);
          resolution = this.resolutions_[idx];
        }
        return resolution;
      };

      /**
       * @param {module:ol/extent~Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {module:ol/ImageBase} Single image.
       */
      ImageSource.prototype.getImage = function getImage (extent, resolution, pixelRatio, projection) {
        var sourceProjection = this.getProjection();
        if (!sourceProjection ||
            !projection ||
            equivalent(sourceProjection, projection)) {
          if (sourceProjection) {
            projection = sourceProjection;
          }
          return this.getImageInternal(extent, resolution, pixelRatio, projection);
        } else {
          if (this.reprojectedImage_) {
            if (this.reprojectedRevision_ == this.getRevision() &&
                equivalent(
                  this.reprojectedImage_.getProjection(), projection) &&
                this.reprojectedImage_.getResolution() == resolution &&
                equals$2(this.reprojectedImage_.getExtent(), extent)) {
              return this.reprojectedImage_;
            }
            this.reprojectedImage_.dispose();
            this.reprojectedImage_ = null;
          }

          this.reprojectedImage_ = new ReprojImage(
            sourceProjection, projection, extent, resolution, pixelRatio,
            function(extent, resolution, pixelRatio) {
              return this.getImageInternal(extent, resolution,
                pixelRatio, sourceProjection);
            }.bind(this));
          this.reprojectedRevision_ = this.getRevision();

          return this.reprojectedImage_;
        }
      };

      /**
       * @abstract
       * @param {module:ol/extent~Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @return {module:ol/ImageBase} Single image.
       * @protected
       */
      ImageSource.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {};

      /**
       * Handle image change events.
       * @param {module:ol/events/Event} event Event.
       * @protected
       */
      ImageSource.prototype.handleImageChange = function handleImageChange (event) {
        var image = /** @type {module:ol/Image} */ (event.target);
        switch (image.getState()) {
          case ImageState.LOADING:
            this.dispatchEvent(
              new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART,
                image));
            break;
          case ImageState.LOADED:
            this.dispatchEvent(
              new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND,
                image));
            break;
          case ImageState.ERROR:
            this.dispatchEvent(
              new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR,
                image));
            break;
          default:
            // pass
        }
      };

      return ImageSource;
    }(Source));


    /**
     * Default image load function for image sources that use module:ol/Image~Image image
     * instances.
     * @param {module:ol/Image} image Image.
     * @param {string} src Source.
     */
    function defaultImageLoadFunction(image, src) {
      image.getImage().src = src;
    }

    /**
     * @module ol/source/WMSServerType
     */

    /**
     * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
     *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
     *     specification that OpenLayers can make use of.
     * @enum {string}
     */
    var WMSServerType = {
      CARMENTA_SERVER: 'carmentaserver',
      GEOSERVER: 'geoserver',
      MAPSERVER: 'mapserver',
      QGIS: 'qgis'
    };

    /**
     * @module ol/uri
     */


    /**
     * Appends query parameters to a URI.
     *
     * @param {string} uri The original URI, which may already have query data.
     * @param {!Object} params An object where keys are URI-encoded parameter keys,
     *     and the values are arbitrary types or arrays.
     * @return {string} The new URI.
     */
    function appendParams(uri, params) {
      var keyParams = [];
      // Skip any null or undefined parameter values
      Object.keys(params).forEach(function(k) {
        if (params[k] !== null && params[k] !== undefined) {
          keyParams.push(k + '=' + encodeURIComponent(params[k]));
        }
      });
      var qs = keyParams.join('&');
      // remove any trailing ? or &
      uri = uri.replace(/[?&]$/, '');
      // append ? or & depending on whether uri has existing parameters
      uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
      return uri + qs;
    }

    /**
     * @module ol/source/ImageWMS
     */


    /**
     * @const
     * @type {module:ol/size~Size}
     */
    var GETFEATUREINFO_IMAGE_SIZE = [101, 101];


    /**
     * @typedef {Object} Options
     * @property {module:ol/source/Source~AttributionLike} [attributions] Attributions.
     * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
     * you must provide a `crossOrigin` value if you are using the WebGL renderer or if you want to
     * access pixel data with the Canvas renderer.  See
     * https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
     * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
     * the image from the remote server.
     * @property {module:ol/source/WMSServerType|string} [serverType] The type of
     * the remote WMS server: `mapserver`, `geoserver` or `qgis`. Only needed if `hidpi` is `true`.
     * @property {module:ol/Image~LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.
     * @property {Object.<string,*>} params WMS request parameters.
     * At least a `LAYERS` param is required. `STYLES` is
     * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
     * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
     * @property {module:ol/proj~ProjectionLike} projection Projection.
     * @property {number} [ratio=1.5] Ratio. `1` means image requests are the size of the map viewport, `2` means
     * twice the width and height of the map viewport, and so on. Must be `1` or
     * higher.
     * @property {Array.<number>} [resolutions] Resolutions.
     * If specified, requests will be made for these resolutions only.
     * @property {string} url WMS service URL.
     */


    /**
     * @classdesc
     * Source for WMS servers providing single, untiled images.
     *
     * @fires ol/source/Image~ImageSourceEvent
     * @api
     */
    var ImageWMS = (function (ImageSource$$1) {
      function ImageWMS(opt_options) {

        var options = opt_options || {};

        ImageSource$$1.call(this, {
          attributions: options.attributions,
          projection: options.projection,
          resolutions: options.resolutions
        });

        /**
         * @private
         * @type {?string}
         */
        this.crossOrigin_ =
            options.crossOrigin !== undefined ? options.crossOrigin : null;

        /**
         * @private
         * @type {string|undefined}
         */
        this.url_ = options.url;

        /**
         * @private
         * @type {module:ol/Image~LoadFunction}
         */
        this.imageLoadFunction_ = options.imageLoadFunction !== undefined ?
          options.imageLoadFunction : defaultImageLoadFunction;

        /**
         * @private
         * @type {!Object}
         */
        this.params_ = options.params || {};

        /**
         * @private
         * @type {boolean}
         */
        this.v13_ = true;
        this.updateV13_();

        /**
         * @private
         * @type {module:ol/source/WMSServerType|undefined}
         */
        this.serverType_ = /** @type {module:ol/source/WMSServerType|undefined} */ (options.serverType);

        /**
         * @private
         * @type {boolean}
         */
        this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;

        /**
         * @private
         * @type {module:ol/Image}
         */
        this.image_ = null;

        /**
         * @private
         * @type {module:ol/size~Size}
         */
        this.imageSize_ = [0, 0];

        /**
         * @private
         * @type {number}
         */
        this.renderedRevision_ = 0;

        /**
         * @private
         * @type {number}
         */
        this.ratio_ = options.ratio !== undefined ? options.ratio : 1.5;

      }

      if ( ImageSource$$1 ) ImageWMS.__proto__ = ImageSource$$1;
      ImageWMS.prototype = Object.create( ImageSource$$1 && ImageSource$$1.prototype );
      ImageWMS.prototype.constructor = ImageWMS;

      /**
       * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
       * projection. Return `undefined` if the GetFeatureInfo URL cannot be
       * constructed.
       * @param {module:ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {module:ol/proj~ProjectionLike} projection Projection.
       * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
       *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
       *     in the `LAYERS` parameter will be used. `VERSION` should not be
       *     specified here.
       * @return {string|undefined} GetFeatureInfo URL.
       * @api
       */
      ImageWMS.prototype.getGetFeatureInfoUrl = function getGetFeatureInfoUrl (coordinate, resolution, projection, params) {
        if (this.url_ === undefined) {
          return undefined;
        }
        var projectionObj = get$2(projection);
        var sourceProjectionObj = this.getProjection();

        if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
          resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
          coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
        }

        var extent = getForViewAndSize(coordinate, resolution, 0,
          GETFEATUREINFO_IMAGE_SIZE);

        var baseParams = {
          'SERVICE': 'WMS',
          'VERSION': DEFAULT_WMS_VERSION,
          'REQUEST': 'GetFeatureInfo',
          'FORMAT': 'image/png',
          'TRANSPARENT': true,
          'QUERY_LAYERS': this.params_['LAYERS']
        };
        assign(baseParams, this.params_, params);

        var x = Math.floor((coordinate[0] - extent[0]) / resolution);
        var y = Math.floor((extent[3] - coordinate[1]) / resolution);
        baseParams[this.v13_ ? 'I' : 'X'] = x;
        baseParams[this.v13_ ? 'J' : 'Y'] = y;

        return this.getRequestUrl_(
          extent, GETFEATUREINFO_IMAGE_SIZE,
          1, sourceProjectionObj || projectionObj, baseParams);
      };

      /**
       * Get the user-provided params, i.e. those passed to the constructor through
       * the "params" option, and possibly updated using the updateParams method.
       * @return {Object} Params.
       * @api
       */
      ImageWMS.prototype.getParams = function getParams () {
        return this.params_;
      };

      /**
       * @inheritDoc
       */
      ImageWMS.prototype.getImageInternal = function getImageInternal (extent, resolution, pixelRatio, projection) {

        if (this.url_ === undefined) {
          return null;
        }

        resolution = this.findNearestResolution(resolution);

        if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
          pixelRatio = 1;
        }

        var imageResolution = resolution / pixelRatio;

        var center = getCenter(extent);
        var viewWidth = Math.ceil(getWidth(extent) / imageResolution);
        var viewHeight = Math.ceil(getHeight(extent) / imageResolution);
        var viewExtent = getForViewAndSize(center, imageResolution, 0,
          [viewWidth, viewHeight]);
        var requestWidth = Math.ceil(this.ratio_ * getWidth(extent) / imageResolution);
        var requestHeight = Math.ceil(this.ratio_ * getHeight(extent) / imageResolution);
        var requestExtent = getForViewAndSize(center, imageResolution, 0,
          [requestWidth, requestHeight]);

        var image = this.image_;
        if (image &&
            this.renderedRevision_ == this.getRevision() &&
            image.getResolution() == resolution &&
            image.getPixelRatio() == pixelRatio &&
            containsExtent(image.getExtent(), viewExtent)) {
          return image;
        }

        var params = {
          'SERVICE': 'WMS',
          'VERSION': DEFAULT_WMS_VERSION,
          'REQUEST': 'GetMap',
          'FORMAT': 'image/png',
          'TRANSPARENT': true
        };
        assign(params, this.params_);

        this.imageSize_[0] = Math.round(getWidth(requestExtent) / imageResolution);
        this.imageSize_[1] = Math.round(getHeight(requestExtent) / imageResolution);

        var url = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio,
          projection, params);

        this.image_ = new ImageWrapper(requestExtent, resolution, pixelRatio,
          url, this.crossOrigin_, this.imageLoadFunction_);

        this.renderedRevision_ = this.getRevision();

        listen(this.image_, EventType.CHANGE,
          this.handleImageChange, this);

        return this.image_;

      };

      /**
       * Return the image load function of the source.
       * @return {module:ol/Image~LoadFunction} The image load function.
       * @api
       */
      ImageWMS.prototype.getImageLoadFunction = function getImageLoadFunction () {
        return this.imageLoadFunction_;
      };

      /**
       * @param {module:ol/extent~Extent} extent Extent.
       * @param {module:ol/size~Size} size Size.
       * @param {number} pixelRatio Pixel ratio.
       * @param {module:ol/proj/Projection} projection Projection.
       * @param {Object} params Params.
       * @return {string} Request URL.
       * @private
       */
      ImageWMS.prototype.getRequestUrl_ = function getRequestUrl_ (extent, size, pixelRatio, projection, params) {

        assert(this.url_ !== undefined, 9); // `url` must be configured or set using `#setUrl()`

        params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();

        if (!('STYLES' in this.params_)) {
          params['STYLES'] = '';
        }

        if (pixelRatio != 1) {
          switch (this.serverType_) {
            case WMSServerType.GEOSERVER:
              var dpi = (90 * pixelRatio + 0.5) | 0;
              if ('FORMAT_OPTIONS' in params) {
                params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
              } else {
                params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
              }
              break;
            case WMSServerType.MAPSERVER:
              params['MAP_RESOLUTION'] = 90 * pixelRatio;
              break;
            case WMSServerType.CARMENTA_SERVER:
            case WMSServerType.QGIS:
              params['DPI'] = 90 * pixelRatio;
              break;
            default:
              assert(false, 8); // Unknown `serverType` configured
              break;
          }
        }

        params['WIDTH'] = size[0];
        params['HEIGHT'] = size[1];

        var axisOrientation = projection.getAxisOrientation();
        var bbox;
        if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
          bbox = [extent[1], extent[0], extent[3], extent[2]];
        } else {
          bbox = extent;
        }
        params['BBOX'] = bbox.join(',');

        return appendParams(/** @type {string} */ (this.url_), params);
      };

      /**
       * Return the URL used for this WMS source.
       * @return {string|undefined} URL.
       * @api
       */
      ImageWMS.prototype.getUrl = function getUrl () {
        return this.url_;
      };

      /**
       * Set the image load function of the source.
       * @param {module:ol/Image~LoadFunction} imageLoadFunction Image load function.
       * @api
       */
      ImageWMS.prototype.setImageLoadFunction = function setImageLoadFunction (imageLoadFunction) {
        this.image_ = null;
        this.imageLoadFunction_ = imageLoadFunction;
        this.changed();
      };

      /**
       * Set the URL to use for requests.
       * @param {string|undefined} url URL.
       * @api
       */
      ImageWMS.prototype.setUrl = function setUrl (url) {
        if (url != this.url_) {
          this.url_ = url;
          this.image_ = null;
          this.changed();
        }
      };

      /**
       * Update the user-provided params.
       * @param {Object} params Params.
       * @api
       */
      ImageWMS.prototype.updateParams = function updateParams (params) {
        assign(this.params_, params);
        this.updateV13_();
        this.image_ = null;
        this.changed();
      };

      /**
       * @private
       */
      ImageWMS.prototype.updateV13_ = function updateV13_ () {
        var version = this.params_['VERSION'] || DEFAULT_WMS_VERSION;
        this.v13_ = compareVersions(version, '1.3') >= 0;
      };

      return ImageWMS;
    }(ImageSource));

    /**
     * @module ol/layer/Image
     */


    /**
     * @typedef {Object} Options
     * @property {number} [opacity=1] Opacity (0, 1).
     * @property {boolean} [visible=true] Visibility.
     * @property {module:ol/extent~Extent} [extent] The bounding extent for layer rendering.  The layer will not be
     * rendered outside of this extent.
     * @property {number} [zIndex=0] The z-index for layer rendering.  At rendering time, the layers
     * will be ordered, first by Z-index and then by position.
     * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
     * visible.
     * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
     * be visible.
     * @property {module:ol/PluggableMap} [map] Sets the layer as overlay on a map. The map will not manage
     * this layer in its layers collection, and the layer will be rendered on top. This is useful for
     * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
     * use {@link module:ol/Map#addLayer}.
     * @property {module:ol/source/Image} [source] Source for this layer.
     */


    /**
     * @classdesc
     * Server-rendered images that are available for arbitrary extents and
     * resolutions.
     * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
     * property on the layer object; for example, setting `title: 'My Title'` in the
     * options means that `title` is observable, and has get/set accessors.
     *
     * @fires module:ol/render/Event~RenderEvent
     * @api
     */
    var ImageLayer = (function (Layer$$1) {
      function ImageLayer(opt_options) {
        var options = opt_options ? opt_options : {};
        Layer$$1.call(this, options);

        /**
         * The layer type.
         * @protected
         * @type {module:ol/LayerType}
         */
        this.type = LayerType.IMAGE;

      }

      if ( Layer$$1 ) ImageLayer.__proto__ = Layer$$1;
      ImageLayer.prototype = Object.create( Layer$$1 && Layer$$1.prototype );
      ImageLayer.prototype.constructor = ImageLayer;

      return ImageLayer;
    }(Layer));


    /**
     * Return the associated {@link module:ol/source/Image source} of the image layer.
     * @function
     * @return {module:ol/source/Image} Source.
     * @api
     */
    ImageLayer.prototype.getSource;

    var ID = 1;
    var ImageAdapter = /** @class */ (function () {
        function ImageAdapter() {
        }
        ImageAdapter.prototype.addLayer = function (options) {
            this.name = options.id || 'image-' + ID++;
            // const options = {
            //   maxResolution: item.maxResolution ? item.maxResolution : undefined,
            //   minResolution: item.minResolution ? item.minResolution : undefined,
            //   visible: item.visibility,
            //   opacity: item.transparency ? (1 - item.transparency / 100) : 1.0,
            // };
            var source = new ImageWMS({
                url: options.url,
                params: {
                    resource: options.styleId,
                },
                ratio: 1,
                imageLoadFunction: function (image, src) {
                    var url = src.split('?')[0];
                    var query = src.split('?')[1];
                    var queryObject = queryToObject(query);
                    image.getImage().src = url
                        + '?resource=' + queryObject.resource
                        + '&extent=' + queryObject.BBOX
                        + '&size=' + queryObject.WIDTH + ',' + queryObject.HEIGHT
                        + '#' + Date.now(); // in-memory cache busting
                },
            });
            var layer = new ImageLayer({ source: source });
            return layer;
        };
        return ImageAdapter;
    }());
    // TODO: move to utils or rewrite with native js methods
    function queryToObject(str) {
        var dec = decodeURIComponent;
        var qp = str.split('&');
        var ret = {};
        var name;
        var val;
        for (var i = 0, l = qp.length, item = void 0; i < l; ++i) {
            item = qp[i];
            if (item.length) {
                var s = item.indexOf('=');
                if (s < 0) {
                    name = dec(item);
                    val = '';
                }
                else {
                    name = dec(item.slice(0, s));
                    val = dec(item.slice(s + 1));
                }
                if (typeof ret[name] === 'string') { // inline'd type check
                    ret[name] = [ret[name]];
                }
                if (Array.isArray(ret[name])) {
                    ret[name].push(val);
                }
                else {
                    ret[name] = val;
                }
            }
        }
        return ret; // Object
    }

    var OlMapAdapter = /** @class */ (function () {
        function OlMapAdapter() {
            this.displayProjection = 'EPSG:3857';
            this.lonlatProjection = 'EPSG:4326';
            this._layers = {};
            this._order = 0;
            this._length = 9999; // TODO: get real layers length count, after all registered
            this.DPI = 1000 / 39.37 / 0.28;
            this.IPM = 39.37;
        }
        // private _layers: {[name: string]: LayerMem} = {};
        // create(options: MapOptions = {target: 'map'}) {
        OlMapAdapter.prototype.create = function (options) {
            if (options === void 0) { options = { target: 'map' }; }
            var view = new View({
                center: [-9101767, 2822912],
                zoom: 14,
                projection: this.displayProjection,
            });
            var defOpt = {
                logo: false,
                controls: [],
                view: view,
                layers: [
                    new TileLayer({
                        source: new OSM(),
                    }),
                ],
            };
            var mapInitOptions = __assign({}, defOpt, options);
            this.map = new Map(mapInitOptions);
            // this._olMap.addLayer(new TileLayer({ source: new OSM()}));
            this._olView = this.map.getView();
            // olView.on('change:resolution', (evt) => {
            //   this.set('resolution', olView.getResolution());
            // });
            // olView.on('change:center', (evt) => {
            //   this.set('center', olView.getCenter());
            // });
        };
        OlMapAdapter.prototype.setCenter = function (latLng) {
            this._olView.setCenter(fromLonLat(latLng));
        };
        OlMapAdapter.prototype.setZoom = function (zoom) {
            this._olView.setZoom(zoom);
        };
        OlMapAdapter.prototype.fit = function (extent) {
            extent = transformExtent(extent, this.lonlatProjection, this.displayProjection);
            this._olView.fit(extent);
        };
        OlMapAdapter.prototype.setRotation = function (angle) {
            this._olView.setRotation(angle);
        };
        OlMapAdapter.prototype.getLayerAdapter = function (name) {
            return OlMapAdapter.layerAdapters[name];
        };
        OlMapAdapter.prototype.registrateWmsLayer = function (layerName, options) {
            // if (!layerName) {
            //   throw new Error('layerName is required parameter');
            // }
            // let layer = this._layers[layerName];
            // if (!layer) {
            //   layer = this._imageAdapter(options);
            //   this._layers[layerName] = {layer, order: options.order || ORDER++};
            //   // LENGTH++;
            // }
            // return layer;
        };
        OlMapAdapter.prototype.addLayer = function (adapterDef, options) {
            var adapterEngine;
            if (typeof adapterDef === 'string') {
                adapterEngine = this.getLayerAdapter(adapterDef);
            }
            if (adapterEngine) {
                var adapter = new adapterEngine(this.map, options);
                var layer = adapter.addLayer(options);
                this._layers[options.id] = { layer: layer, order: options.order || this._order++ };
                this._length++;
                return adapter;
            }
        };
        OlMapAdapter.prototype.showLayer = function (layerName) {
            this._toggleLayer(true, layerName);
        };
        OlMapAdapter.prototype.hideLayer = function (layerName) {
            this._toggleLayer(false, layerName);
        };
        OlMapAdapter.prototype.getScaleForResolution = function (res, mpu) {
            return parseFloat(res) * (mpu * this.IPM * this.DPI);
        };
        OlMapAdapter.prototype.getResolutionForScale = function (scale, mpu) {
            return parseFloat(scale) / (mpu * this.IPM * this.DPI);
        };
        OlMapAdapter.prototype._toggleLayer = function (status, layerName) {
            var _this = this;
            var action = function (source, l) {
                if (status) {
                    if (source instanceof Map) {
                        source.addLayer(l.layer);
                        l.layer.setZIndex(_this._order - l.order);
                    }
                }
                else {
                    source.removeLayer(l.layer);
                }
            };
            var layer = this._layers[layerName];
            if (layer) {
                action(this.map, layer);
            }
        };
        OlMapAdapter.layerAdapters = {
            IMAGE: ImageAdapter,
        };
        return OlMapAdapter;
    }());

    exports.OlMapAdapter = OlMapAdapter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map
